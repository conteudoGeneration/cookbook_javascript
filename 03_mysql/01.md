<h1>Introdução a Banco de Dados com MySQL</h1>



O que veremos por aqui:

1. Introdução a Banco de Dados
2. Tipos de Banco de Dados
3. Introdução ao Banco de dados Relacional
4. Introdução a Banco de dados Não Relacional

<br />

<h2>1. Introdução ao Banco de Dados</h2>



Segundo Korth, um Banco de dados é <i>"uma coleção de dados inter-relacionados, representando informações sobre um domínio específico”</i>, ou seja, sempre que for possível agrupar informações que se relacionam e tratam de um mesmo assunto, posso dizer que tenho um Banco de dados. 

**Exemplos:**

- As informações armazenadas de uma lista telefônica;
- Os registros de usuários em um sistema de e-commerce;
- Um sistema de controle de RH de uma empresa, entre outros.

Um **Sistema de Gerenciamento de Banco de Dados (SGBD)** é um software que possui os recursos necessários para manipular os Objetos e os Dados do Banco de dados, além de interagir com o usuário. Os SGBD's são classificados em 2 categorias:

- **Relacionais**
- **Não Relacionais**

O principal objetivo de um SGBD é **gerenciar** os dados armazenados em um banco de dados, garantindo a **integridade**, a **segurança** e a **disponibilidade** dos dados. 

O SGBD é responsável por gerenciar o acesso aos dados, permitindo que vários usuários possam acessar o banco de dados simultaneamente, sem que ocorram conflitos ou perda de dados. Além disso, o SGBD é capaz de garantir a **consistência** dos dados, evitando que informações conflitantes sejam armazenadas no banco de dados. 

O SGBD também é responsável por garantir a **confidencialidade** dos dados, permitindo que apenas usuários autorizados possam acessar informações sensíveis. 

Um banco de dados é geralmente controlado por um sistema de gerenciamento de banco de dados (SGBD). A união entre os dados, o SGBD e os aplicativos associados ao SGBD, são chamados de **Sistema de Banco de dados**, ou simplesmente Banco de dados. 

O objetivo de um **Sistema de Banco de Dados** é ocultar do usuário os detalhes internos do Banco de dados (abstração dos dados) e promover a independência dos dados em relação às aplicações, ou seja, tornar o Banco de dados independente de aplicação, estratégia de acesso e forma de armazenamento.

<br />

<h2>2. Tipos de Banco de Dados</h2>



Há dois tipos Bancos de dados no mercado, que são classificados de acordo com a maneira como organizam as  informações: **Relacional** e **Não Relacional**. 

<br />

<h3>2.1. Bancos de dados Relacionais</h3>



Um **Banco de dados Relacional** é um tipo específico de Banco de dados que organiza e armazena os dados em tabelas com uma estrutura pré-definida. Nesse modelo, os dados são organizados em linhas e colunas, onde cada tabela representa uma entidade ou um conjunto de entidades relacionadas. Os dados geralmente são estruturados em várias tabelas, que podem ser unidas por meio de uma **Chave Primária** e de uma **Chave Estrangeira**, criando um **Relacionamento entre Tabelas**. 

Esta forma de organização dos Bancos de dados se caracteriza por organizar as informações em tabelas. As tabelas dependem da integração entre as colunas e as linhas.

<div align="center"><img src="https://i.imgur.com/iPQikMM.png" title="source: imgur.com" width="60%"/></div>

Desta forma, os Atributos (campos) ficam nas colunas da tabela, e o conteúdo dos Atributos ficas nas linhas (registros). O modelo relacional é ideal quando precisa-se armazenar informações tabulares de pouca complexidade, que precisam ser recuperadas agilmente. O modelo relacional é a forma de armazenamento mais utilizada e popular no mercado, pois oferece alta confiabilidade. Porém, é necessário criar uma estrutura de relacionamento entre tabelas para que as informações possam ser recuperadas.

A linguagem usada para manipular essas informações é o **SQL (Structured Query Language)**, que permite tanto criar a Estrutura de tabelas e relacionamentos, quanto manipular os dados armazenados. Na imagem abaixo temos alguns exemplos de Sistemas Gerenciadores de Banco de dados que utilizam o Modelo Relacional.

<div align="center"><img src="https://i.imgur.com/xukkZD0.png" title="source: imgur.com" /></div>

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="80px"/> | <div align="left"> **ATENÇÃO:** *Todos os Banco de dados Relacionais utilizam a Linguagem SQL para criar a estrutura do Banco de dados e manipular os dados armazenados, ou seja, é a Linguagem Universal dos Banco de dados Relacionais.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h3>2.2. Bancos de dados Não Relacionais</h3>



Um **Banco de dados Não Relacional** é um tipo de banco de dados que não utiliza o modelo relacional para armazenar e recuperar dados. Em vez disso, os bancos de dados não relacionais utilizam outros modelos de armazenamento de dados, que são classificados em 4 categorias:

- **Documentos;**
- **Chave-Valor;**
- **Grafos;**
- **Colunas.** 

Os Bancos de dados Não Relacionais são mais flexíveis em relação à estrutura dos dados e não requerem um esquema fixo, como o Banco de dados Relacional. Eles permitem que os dados sejam armazenados de maneiras mais intuitivas e fáceis de entender, ou mais próximas da maneira como os dados são usados pelos aplicativos - com menos transformações necessárias ao armazenar ou recuperar os dados armazenados. 

Os bancos de dados Não Relacionais são amplamente usados em aplicativos da web em tempo real e Big Data, devido a sua alta escalabilidade e disponibilidade. Além disso, os bancos de dados Não Relacionais permitem que os dados sejam analisados e transformados em informações úteis para a tomada de decisões estratégicas das empresas.

> A **Escalabilidade** em Bancos de dados é a capacidade de aumentar a capacidade de um sistema de banco de dados para lidar com mais carga de trabalho. Existem dois tipos principais de escalabilidade: **Escalabilidade Vertical** e **Escalabilidade Horizontal**.
>
> A **Escalabilidade Vertical** é a capacidade de aumentar a capacidade de um servidor adicionando mais recursos, como CPU, memória ou armazenamento, a uma única máquina. Isso significa que o servidor pode lidar com mais carga de trabalho sem precisar adicionar mais servidores.
>
> <div align="center"><img src="https://i.imgur.com/yrmutpc.png" title="source: imgur.com" width="75%"/></div>
>
> Por outro lado, a **Escalabilidade Horizontal** é a capacidade de aumentar a capacidade de um sistema adicionando mais servidores ao conjunto de recursos. Isso significa que o sistema pode lidar com mais carga de trabalho, adicionando mais servidores em vez de aumentar a capacidade de um único servidor.
>
> <div align="center"><img src="https://i.imgur.com/aDixJ6w.png" title="source: imgur.com" width="75%"/></div>
>
> A **Disponibilidade** de um banco de dados é a capacidade de manter o sistema em funcionamento e acessível aos usuários, mesmo em caso de falhas ou interrupções. A alta disponibilidade é um requisito importante para muitas empresas, pois garante que os dados estejam sempre disponíveis para consulta e atualização.
>

A linguagem utilizada pelos Bancos de dados Não Relacionais é o **NoSQL (Not Only SQL)**, que é um termo genérico que se refere aos bancos de dados não relacionais que não utilizam o modelo relacional para armazenar e recuperar dados. Na imagem abaixo temos alguns exemplos de Banco de dados Não Relacionais:

<div align="center"><img src="https://i.imgur.com/zcpaJ43.png" title="source: imgur.com" /></div>

Na imagem acima, os SGBDS listados são classificados da seguinte forma:

- **Documentos:** *Elastic, Mongo DB e Couch DB*;
- **Chave-Valor:** *Memcached, Redis, Apache Ignite e Amazon Dynamo DB*;
- **Grafos:** *Allegro Graph, Neo4J e Orient DB*;
- **Colunas:** *Apache HBase e Cassandra*.

<br />

<h3>2.3. Banco de dados Relacional vs Banco de dados Não Relacional?</h3>



Na tabela abaixo, vemos uma comparação entre os dois modelos de Banco de dados:

| SQL                                                          | NoSQL                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Armazenamento de Dados Estruturados por Tabela               | Armazenamento de Dados estruturados e não-estruturados por colunas, grafos, chave-valor e documentos. |
| Esquema estático                                             | Esquema dinâmico                                             |
| Maturidade de suporte maior (geralmente pago)                | Suporte por comunidade independente (open source)            |
| Escalabilidade vertical                                      | Escalabilidade horizontal                                    |
| Pago e Gratuito                                              | Gratuito                                                     |
| O desempenho não é alto em todas as consultas. Não suporta pesquisas e cruzamentos muito complexos. | Alto desempenho em consultas                                 |
| Necessidade de predefinição de  um esquema de tabela antes da  adição de qualquer dado | Altamente flexível (fácil adição de colunas e campos de dados não estruturados) |

<br />

<h3>2.4. Quando usar um Banco de dados Relacional e Não Relacional?</h3>



A escolha entre **bancos de dados relacionais** (SQL) e **não relacionais** (NoSQL) é uma decisão fundamental no desenvolvimento de sistemas, pois depende das características e necessidades do projeto. A seguir, detalhamos os cenários ideais para cada tipo de banco de dados.

Os bancos de dados relacionais são baseados em tabelas, onde os dados são organizados em linhas e colunas. Utilizam a linguagem SQL para consultas e seguem um esquema fixo, o que garante uma estrutura bem definida. Geralmente eles são utilizados nas seguintes situações:

1. **Dados Estruturados e Relacionados**: Esse tipo de banco é ideal quando os dados possuem relacionamentos bem definidos.
   - **Exemplo:** Em um sistema bancário, onde contas, transações e clientes estão interconectados.
2. **Necessidade de Consistência**: Em aplicações onde a consistência dos dados é crítica, como em sistemas financeiros e de inventário.
   - **Exemplo:** Controle de estoque em tempo real, onde erros podem causar grandes prejuízos.
3. **Transações Complexas**: Bancos relacionais são ideais para operações que envolvem várias tabelas e exigem transações ACID (atômicas, consistentes, isoladas e duráveis).
   - **Exemplo:** Processamento de pagamentos.
4. **Histórico e Relatórios**: Quando é necessário armazenar grandes volumes de dados históricos e gerar relatórios complexos.
   - **Exemplo:** Sistemas de ERP (Planejamento de Recursos Empresariais).

Os bancos de dados não relacionais são mais flexíveis e não seguem esquemas fixos. Eles são organizados em formatos como documentos, chave-valor, grafo ou colunas, sendo ideais para dados não estruturados ou semi-estruturados. Geralmente eles são utilizados nas seguintes situações:

1. **Dados Não Estruturados ou Semi-estruturados**: Indicados para cenários onde os dados não possuem uma estrutura fixa ou mudam frequentemente.
   - **Exemplo:** Armazenar posts de redes sociais, imagens ou logs de eventos.
2. **Alta Escalabilidade**: Quando o sistema precisa lidar com grandes volumes de dados e alto tráfego, priorizando velocidade e disponibilidade.
   - **Exemplo:** Aplicativos de streaming ou e-commerce com milhões de usuários simultâneos.
3. **Rapidez na Leitura/Escrita**: Em cenários onde a performance é essencial, como em caches ou gerenciamento de sessões.
   - **Exemplo:** Sistemas de recomendação, como algoritmos de sugestão de produtos.
4. **Flexibilidade no Modelo de Dados**: Ideal para projetos onde o modelo de dados pode evoluir com o tempo ou variações significativas entre registros são frequentes.
   - **Exemplo:** Aplicativos que armazenam diferentes tipos de dados para diferentes usuários.
5. **Análise em Tempo Real**: Utilizado para armazenar e processar grandes volumes de dados rapidamente.
   - **Exemplo:** Monitoramento de IoT (Internet das Coisas) ou análise de dados em tempo real.

Não existe um modelo que seja melhor do que o outro, pois cada um tem seus pontos fortes e fracos. Tudo dependerá do contexto e da necessidade da empresa.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left"> **IMPORTANTE:** *Em nosso treinamento utilizaremos o Banco de Dados Relacional MySQL.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h3>2.5. Qual é a importância de um Banco de dados para um Sistema WEB?</h3>



Um banco de dados é fundamental para um sistema web, pois possibilita o **armazenamento**, **organização** e **gerenciamento de dados** de forma eficiente e segura, desempenhando um papel essencial no funcionamento de qualquer aplicação.

Ele permite guardar informações cruciais, como dados de usuários, produtos e pedidos, de maneira estruturada e persistente. Além disso, **centraliza os dados** em um único local, o que facilita consultas, atualizações e manutenção, eliminando redundâncias e inconsistências.

Com um banco de dados, é possível **criar consultas personalizadas** para obter informações específicas de maneira rápida e precisa, atendendo às necessidades dinâmicas do sistema.

Quando bem projetado, um banco de dados acompanha o crescimento do sistema, suportando grandes volumes de dados e alto tráfego sem comprometer o desempenho. Em outras palavras, ele é um **sistema escalável**, capaz de atender às demandas crescentes de forma eficiente e confiável.

Os bancos de dados contam com **ferramentas de segurança**, como autenticação, criptografia e controle de acesso, que garantem a proteção de informações sensíveis contra acessos não autorizados. Além disso, eles asseguram a consistência das informações mesmo em situações de falhas, graças ao uso de **transações atômicas (ACID)**.

Um exemplo clássico de transação atômica é a transferência de valores entre contas bancárias: a operação só é concluída se ambas as contas forem atualizadas corretamente; caso contrário, nenhuma alteração é aplicada, garantindo integridade tanto na conta de origem quanto na conta de destino.

Como base para aplicações dinâmicas e interativas, o banco de dados possibilita que sistemas web exibam dados em tempo real e respondam de forma ágil às interações dos usuários, além de permitir a **integração com outros sistemas**, garantindo a troca eficiente de informações entre diferentes plataformas e serviços.

Sem um banco de dados, um sistema web estaria restrito a dados estáticos, limitando sua capacidade de personalização, interatividade e armazenamento. Assim, ele é o núcleo de qualquer aplicação dinâmica, garantindo operações confiáveis, escaláveis e seguras.

<br />

<h2>3. Introdução ao Modelo Relacional</h2>



Todos os  Bancos de dados Relacionais são constituídos por 4 elementos básicos: campos, colunas, linhas e tabelas.

- **Campos** são os espaços reservados para inserção de um determinado dado (em vermelho na figura);
- **Colunas** são os registros de um campo específico (em verde na figura); 
- **Linhas (tuplas)** são os registros de um conjunto de campos (em azul na figura); 
- **Tabelas** são o conjunto de linhas, campos e colunas. 

<div align="center"><img src="https://i.imgur.com/nxRXSq2.png" title="source: imgur.com" /></div>

<br />

<h3>3.1. Linguagem SQL</h3>



**SQL** significa **Structured Query Language** e é a linguagem padrão utilizada pelos Banco de dados relacionais. O SQL está dividido em 2 categorias de instruções principais:

- **DML - Linguagem de Manipulação de Dados:** instruções DML indicam uma ação para o SGBD executar. Utilizados para recuperar, inserir e modificar um registro no Banco de dados. Seus principais comandos são: **INSERT, DELETE, UPDATE e  SELECT;**
- **DDL - Linguagem de Definição de Dados:** instruções DDL são responsáveis pela criação, alteração e exclusão dos objetos no Banco de dados, ou seja, pela estrutura do Banco de dados e das suas respectivas Tabelas. Seus principais comandos são: **CREATE DATABASE, CREATE TABLE, ALTER TABLE e DROP TABLE;**

<br />

<h3>3.2. Tipos de Dados utilizados pelos Bancos de dados Relacionais</h3>



Agora que entendemos o conceito de Banco de Dados, também, precisamos entender que assim como nas linguagens de programação, geralmente precisamos definir a <i>**“Tipagem”**</i> (tipo) dos dados, no SQL também precisamos fzaer o mesmo. Como este material está focado no SGBD MySQL, vamos conhecer os tipos de dados mais utilizados pelo MySQL.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="80px"/> | <div align="left"> **ATENÇÃO:** *Os demais Banco de dados Relacionais possuem alguns tipos de dados diferentes em relação ao MySQL. Para checar os tipos de dados de cada um, consulte as respectivas documentações.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h4>3.2.1. Tipos de dados numéricos</h4>



Os tipos de dados numéricos armazenam números exatos, como números binários, números inteiros, números decimais ou valores monetários.

| Tipo                 | Descrição                                                    |
| -------------------- | ------------------------------------------------------------ |
| BOOLEAN              | Zero é considerado falso, valores diferentes de zero são considerados verdadeiros. |
| INT(*size*)          | Um número inteiro médio, no intervalo -2147483648 a 2147483647. O parâmetro *size* especifica a largura máxima de exibição (que é 255) |
| BIGINT(*size*)       | Um número inteiro grande, no intervalo -9223372036854775808 a 9223372036854775807. O parâmetro *size* especifica a largura máxima de exibição (que é 255) |
| FLOAT(*size*)        | Um número de ponto flutuante. O número total de dígitos é especificado em *size*. |
| DOUBLE(*size*)       | Um número de ponto flutuante de tamanho normal. O número total de dígitos é especificado em *size*. |
| DECIMAL(*size*, *d*) | Um número exato de ponto fixo. O número total de dígitos é especificado em *size*. O número de dígitos após o ponto decimal é especificado no parâmetro *d*. O número máximo para o *tamanho* é 65. O número máximo para *d* é 30. O valor padrão para *tamanho* é 10. O valor padrão para *d* é 0.<br />Importante destacar que o o valor do parâmetro **d** faz parte do parâmetro size. <br />**Exemplo:** DECIMAL(10,2) 🡪 o atributo possui 10 dígitos, onde os 2 últimos dígitos representam a parte decimal. 00000000.00 |

<br />

<h4>3.2.2. Tipos de dados de cadeia de caracteres (string)</h4>



Os tipos de dados de cadeias de caracteres permitem que você armazene  dados de comprimento fixo (char) ou de comprimento variável (varchar). O tipo de dados de texto pode armazenar dados não Unicode na página de código do servidor, além de imagens no formato BLOB.

| Tipo          | Descrição                                                    |
| ------------- | ------------------------------------------------------------ |
| CHAR(size)    | Uma string de comprimento FIXO (pode conter letras, números e caracteres especiais). O parâmetro *size* especifica o comprimento da coluna em caracteres - pode ser de 0 a 255. O padrão é 1 |
| VARCHAR(size) | Uma string de comprimento VARIÁVEL (pode conter letras, números e caracteres especiais). O parâmetro *size* especifica o comprimento máximo da string em caracteres - pode ser de 0 a 65.535 |
| BLOB(size)    | Armazena campos do tipo BLOB (objetos binários grandes como imagens, por exemplo). Armazena até 65.535 bytes de dados |

<br />

<h4>3.2.3. Tipos de dados de data e hora</h4>



Os tipos de dados de data e hora armazenam data e hora.

| Tipo             | Descrição                                                    |
| ---------------- | ------------------------------------------------------------ |
| DATE             | Armazena data no formato: YYYY-MM-DD.                        |
| DATETIME(*fsp*)  | Armazena data e hora no formato: YYYY-MM-DD hh:mm:ss.        |
| TIMESTAMP(*fsp*) | Armazena data e hora no formato Timestamp. Os valores TIMESTAMP são armazenados como o número de segundos desde a época Unix ('1970-01-01 00:00:00' UTC). Formato: AAAA-MM-DD hh:mm:ss. O intervalo suportado é de '1970-01-01 00:00:01' UTC a '2038-01-09 03:14:07' UTC. <br />A inicialização e atualização automáticas para a data e hora atuais podem ser especificadas usando DEFAULT CURRENT_TIMESTAMP e ON UPDATE CURRENT_TIMESTAMP na definição da coluna. |

<br />

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_datatypes.asp" target="_blank"><b>Documentação: <i>Tipos de Dados - W3Schools</i></b></a></div>

<br />

<h3>3.3. Chaves</h3>



<h4>3.3.1. Chave Primária (PK)</h4>



A **Chave Primária** é o atributo que torna uma linha ou registro de uma tabela em um dado único. Geralmente, é utilizada uma sequência numérica automática para a geração dessa chave para que ela não venha a se repetir. Nenhuma linha possuirá o mesmo valor na coluna que é chave primária, ou seja, o atributo chave primária será um identificador único do registro.

<br />

<h4>3.3.2. Chave Estrangeira (FK)</h4>



A **Chave Estrangeira** define um relacionamento entre tabelas, comumente chamado de **Integridade Referencial**. Esta regra baseia-se no fato de que uma chave estrangeira em uma tabela é a chave primária em outra. Na imagem abaixo, a tabela produtos possui o atributo **categoria_id (Chave Estrangeira)**, isto é, ela pode se repetir na tabela de produtos. No entanto, deve ser único na tabela de categorias **(Chave Primária)**, pois assim terá uma referência exclusiva.

<div align="center"><img src="https://i.imgur.com/wNQow94.png" title="source: imgur.com" /></div>

<br />

<h3>3.4. MER - Modelo Entidade Relacionamento</h3>



Assim como todo o projeto, devemos iniciar por um “esboço” do que de fato será nossa base de dados. No Modelo Relacional, quando desenhamos esta estrutura, á chamamos de **MER - Modelo Entidade Relacionamento**, onde com apenas um papel e uma caneta podemos desenhar o modelo do nosso Banco de dados expondo todos os relacionamento entre as tabelas.

<div align="center"><img src="https://i.imgur.com/a2YtAyL.png" title="source: imgur.com" /></div>

Um Modelo Entidade Relacionamento é uma maneira sistemática de descrever e definir um processo de negócio. O processo é modelado como componentes (Entidades) que são ligadas umas as outras por Relacionamentos que expressam as dependências e exigências entre elas. 

No exemplo acima, uma Categoria pode possuir zero ou mais Produtos, mas um Produto só pode ser classificado em apenas uma Categoria. 

Entidades podem ter várias propriedades (Atributos) que os caracterizam. Uma Entidade e seus Atributos se transformam em uma ou mais Tabelas no Banco de dados, dependendo do tipo Relacionamento.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="250px"/> | <div align="left"> **IMPORTANTE:** *Uma boa prática é nomearmos os relacionamentos com verbos ou expressões que representa a forma como as entidades (tabelas) interagem, ou a ação que uma exerce sobre a outra, este nome pode mudar de acordo com com a direção que se lê o relacionamento.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br/>

<h3>3.5. DER - Diagrama Entidade Relacionamento</h3>



O **DER - Diagrama Entidade Relacional** também pode ser visto como um “esboço” mais detalhado em comparação ao **MER**, porém ele é feito através de uma ferramenta especifica, onde podemos compartilhar de uma forma segura com os demais membros de nossa equipe, e também extrair do nosso **DER** o código SQL usado para criar o Banco de dados.

<div align="center"><img src="https://i.imgur.com/V4YbgWz.png" title="source: imgur.com" /></div>

O MySQL possui uma Ferramenta Nativa, chamada **MySQL Workbench**, que permite criar o Diagrama de Entidade Relacionamento. Além do MySQL Workbench, existem diversas ferramentas no mercado para criação do DER, entre elas podemos citar:

- **[DB Designer](https://www.dbdesigner.net/)** (gratuito até 2 Diagramas);
- **[Visual Paradigm](https://www.visual-paradigm.com/)** (gratuito);
- **[Draw IO](https://www.drawio.com/)** (gratuito);

<br />

<h3>3.6. Entendendo: Relacionamento entre Tabelas</h3>



Um **Relacionamento entre tabelas** é uma conexão entre duas tabelas de dados, com base em uma coluna de cada tabela. As relações são baseadas em campos comuns de uma ou mais tabelas, geralmente envolvendo chaves primárias e estrangeiras. A chave primária é uma coluna ou conjunto de colunas que identifica exclusivamente cada linha em uma tabela. A chave estrangeira é uma coluna ou conjunto de colunas em uma tabela que se refere à chave primária de outra tabela. 

Os relacionamentos permitem que os dados sejam armazenados de maneira mais eficiente e organizada, evitando a redundância de informações e garantindo a integridade dos dados. Eles também permitem que os dados sejam combinados de várias tabelas para criar consultas e relatórios mais complexos, através de instruções de junção (JOIN) para recuperar os dados. 

Através do DER, o **Database Administrator (DBA)**, ou seja, o Administrador do Sistema de Banco dados, representa graficamente estas relações entre as tabelas e na sequência, utiliza o DER como referência para construir o Banco de dados.

No modelo relacional a única forma de relacionar dados que existem em uma tabela com dados que existem em outra
tabela é através de atributos comuns, que são a Chave Primária e a Chave Estrangeira da tabela. Sem as Chaves não existe relacionamento. A tabela que não possui a Chave Estrangeira será a tabela que manda no relacionamento.

De acordo com a quantidade de objetos envolvidos em cada lado do relacionamento (Cardinalidade), os Relacionamentos entre tabelas são classificados de três formas:

* **Relacionamento 1…1 (um para um):** Cada uma das duas entidades envolvidas referenciam obrigatoriamente apenas uma unidade da outra. **Exemplo:** Em um Banco de dados de currículos, cada usuário cadastrado pode cadastrar apenas um currículo e cada currículo só pode pertencer a um único usuário cadastrado.

No exemplo abaixo temos uma Relação **1:1**.

<div align="center"><img src="https://i.imgur.com/FWwpPIb.png" title="source: imgur.com" /></div>

* **Relacionamento 1…n (um para muitos):** Uma das entidades envolvidas pode referenciar várias unidades da outra, porém, do outro lado cada uma das várias unidades referenciadas só pode estar ligada a uma unidade da outra entidade. **Exemplo:** Em um sistema de plano de saúde, um usuário pode ter vários dependentes, mas cada dependente só pode estar ligado a um usuário principal.

No exemplo abaixo temos uma Relação **1:N**.

<div align="center"><img src="https://i.imgur.com/2UlJEYo.png" title="source: imgur.com" /></div>

* **Relacionamento n…n (muitos para muitos):** Cada entidade, de ambos os lados, podem  referenciar múltiplas unidades da outra. **Exemplo:** Em um sistema de  biblioteca, um livro pode ser escrito por vários autores, ao mesmo  tempo em que um autor pode escrever vários livros. Assim, um autor pode referenciar múltiplos livros, e vice  versa.

No exemplo abaixo temos uma relação **N:N**.

<div align="center"><img src="https://i.imgur.com/sjq20xU.png" title="source: imgur.com" /></div>

Observe que da forma como a Relação foi representada, a Entidade **PRODUTO** teria que possuir uma Chave Estrangeira relacionada com **PEDIDO** e vice versa. Como não é possível armazenar Chaves Estrangeiras nas duas entidades relacionadas simultaneamente, será necessário criar uma terceira Entidade(**ITEM-PEDIDO**), para armazenar as 2 Chaves Estrangeiras, como mostra o Diagrama abaixo.

<div align="center"><img src="https://i.imgur.com/kprdPGy.png" title="source: imgur.com" /></div>

Observe que tanto PRODUTO quanto PEDIDO possuem uma relação 1:N com ITEM_PEDIDO.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="80px"/> | <div align="left"> **ATENÇÃO:** *O assunto Relacionamento será estudado em detalhes, na prática, nos próximos conteúdos.*</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h2>4. Introdução ao Banco de dados Não Relacional</h2>



Bancos de dados Não Relacional são softwares que armazenam dados de forma diferente dos bancos de dados relacionais tradicionais. Eles não usam tabelas, mas outros esquemas de organização e armazenamento, que veremos a seguir. Eles também não adotam a linguagem SQL como linguagem padrão, cada Banco possui a sua linguagem própria. Algumas são parecidas com SQL tanto na sintaxe quanto nos fundamentos, mas ainda assim são diferentes do SQL tradicional.

> **Uma curiosidade:** 
>
> NoSQL não significa “não SQL”, mas *“not only SQL”* (“não somente SQL”, em tradução livre).

Existem 4 esquemas de armazenamento para Bancos de dados Não Relacionais:

- Documentos
- Chave - Valor
- Grafos
- Colunas

<br />

<h3>4.1. Documentos</h3>



Um Banco de dados de documentos é um tipo de Banco de dados não relacional, projetado para armazenar e consultar dados como documentos do tipo JSON. Os bancos de dados de documentos permitem que as pessoas  desenvolvedoras armazenem e consultem dados usando o mesmo modelo de documento que usam no código do aplicativo. No exemplo abaixo, temos um documento, que descreve um Produto de uma quitanda:

```json
{
  "id" : 1,
  "nome" : "Tomate",
  "quantidade" : 100,
  "dataValidade" : "2022-04-10",
  "preco" : 8.00
}
```

> **JSON (JavaScript Object Notation):** é um modelo para armazenamento e  transmissão de informações no formato texto. Apesar de muito simples,  tem sido bastante utilizado por aplicações Web devido a sua capacidade  de estruturar informações de uma forma bem mais compacta, tornando mais rápida a interpretação dessas informações.

Em um sistema de Banco de dados relacional, você deve definir um  esquema (schema), antes de adicionar registros no Banco de dados. O  esquema é a estrutura descrita em uma linguagem formal suportada pelo  Banco de dados e fornece uma "planta baixa" para as tabelas no Banco de dados e  as relações entre as tabelas de dados. Dentro de uma tabela, você  precisa definir restrições em termos de linhas e colunas nomeadas, bem  como o tipo de dado que pode ser armazenado em cada coluna. Na imagem abaixo, temos uma tabela de Produtos de uma quitanda:

<div align="center"><img src="https://i.imgur.com/iPQikMM.png" title="source: imgur.com" /></div>

Num Banco de dados orientado a documentos  (document-oriented), são os registros que descrevem o dado no  documento, bem como o dado atual. Documentos podem ser tão complexos  quanto você queira; você pode usar dados aninhados para fornecer  sub-categorias adicionais de informação sobre seu objeto. Você pode usar também um ou mais documentos para representar um objeto da vida real. Na imagem abaixo, vemos a tabela de Produtos do exemplo anterior, convertida em Documentos, ou seja, cada registro (linha) da tabela se transforma em um Documento.

<div align="center"><img src="https://i.imgur.com/MRiydye.png" title="source: imgur.com" /></div>

Na tabela abaixo podemos observar as equivalências entre o Modelo Relacional e o Modelo Não Relacional - Documentos:

| Modelo Relacional  |      | Modelo Não Relacional - Documentos |
| :----------------: | :--: | :--------------------------------: |
|   Banco de dados   |  🡪   |           Banco de dados           |
|      Tabelas       |  🡪   |              Coleções              |
| Linhas (registros) |  🡪   |             Documentos             |
|  Colunas (campos)  |  🡪   |             Atributos              |

Bancos de dados de documentos são eficientes e eficazes para o armazenamento de informações de um catálogo de produtos de um site de comércio eletrônico, entretanto, para gerenciar milhares de atributos em bancos de dados relacionais é ineficiente e afeta a performance de leitura. Ao usar um Banco de dados de documentos, os atributos de cada produto podem ser descritos em um único documento para gerenciamento fácil e maior velocidade de leitura. Alterar os atributos de um produto não afetará os outros. 

**MongoDB, Elasticsearch e CouchDB** são exemplos populares de bancos NoSQL baseados em documentos. Na imagem abaixo, vemos um Banco de dados criado no **MongoDB**:

<div align="center"><img src="https://i.imgur.com/u7xhzb7.png" title="source: imgur.com" /></div>

<br />

<div align="left"><img src="https://i.imgur.com/fzBLbwL.png" title="source: imgur.com" width="30px"/> <a href="https://www.mongodb.com/" target="_blank"><b>Site Oficial: <i>MongoDB</i></b></a></div>

<br />

<h3>4.2. Chave-valor</h3>



Um Banco de dados de chave-valor é um tipo de Banco de dados não relacional que usa um método de chave-valor simples para armazenar dados. Um Banco de dados de chave-valor armazena dados como um conjunto de pares de chave-valor em que uma chave funciona como um identificador exclusivo. A chave e os valores podem ser qualquer coisa, desde objetos simples até objetos compostos complexos. 

<div align="center"><img src="https://i.imgur.com/hpNXbTl.png" title="source: imgur.com" /></div>

Os bancos de dados de chave-valor são altamente particionáveis e permitem escalabilidade horizontal em um nível que outros tipos de bancos de dados não conseguem alcançar. Eles são mais flexíveis em relação à estrutura dos dados e não requerem um esquema fixo.

Banco de dados do tipo Chave-Valor são muito utilizados em sites de comércio eletrônico para armazenar os dados do carrinho de compras. Como eles podem lidar com grandes volumes de dados e mudanças de estado, enquanto atendem a milhões de usuários simultâneos, realizam as consultas com muita rapidez. O segredo é que podemos associar muitos campos de dados diferentes em uma única chave, bastando acessar tal chave para recuperar todos os dados.

**Redis**, **Apache Ignite**, **Memcached** e **Amazon Dynamo DB** são exemplos populares de bancos não relacionais que usam o esquema chave-valor. Na imagem abaixo, vemos um Banco de dados criado no **Redis**:

<div align="center"><img src="https://i.imgur.com/WSZYu8E.png" title="source: imgur.com" /></div>

<br />

<div align="left"><img src="https://i.imgur.com/Qm4ppJ6.png" title="source: imgur.com" width="30px"/> <a href="https://redis.io/" target="_blank"><b>Site Oficial: <i>Redis</i></b></a></div>

<br />

<h3>4.3. Grafos</h3>



Um **Banco de dados de Grafos** é um tipo de banco de dados NoSQL que usa a Teoria de Grafos para armazenar, mapear e consultar relacionamentos. Em um banco de dados de grafos, os dados são armazenados como um conjunto de nós e arestas, onde cada nó representa uma entidade e cada aresta representa uma relação entre duas entidades. Os bancos de dados de grafos são altamente escaláveis e permitem que os dados sejam consultados de maneira eficiente, mesmo em grandes conjuntos de dados.

Os bancos de dados de grafos são amplamente utilizados em aplicativos da web em tempo real e big data, porque suas principais vantagens são alta escalabilidade e alta disponibilidade. Eles são especialmente úteis para aplicativos que precisam lidar com dados complexos e altamente conectados, como redes sociais, sistemas de recomendação e análise de dados de sensores.

Veja no exemplo abaixo, que podemos representar facilmente as relações entre pessoas em uma Rede Social, através de um Banco de dados do tipo Grafo: 

<div align="center"><img src="https://i.imgur.com/Fz7n4Ki.png" title="source: imgur.com" width="70%"/></div>

Na imagem acima, considerando as pessoas (nós) e seus relacionamentos (arestas), é possível descobrir quem são os “amigos dos amigos” de uma pessoa específica, por exemplo. 

Outro uso interessante dos Banco de dados NoSQL do tipo grafos é a detecção de fraude (comparar se o número de cartão de crédito usado por um usuário é sempre o mesmo, por exemplo).

São exemplos populares de bancos não relacionais baseados em grafos: **Neo4J**, **OrientDB** e **AllegroGraph**. Na imagem abaixo, vemos um Banco de dados criado no **Neo4J**:

<div align="center"><img src="https://i.imgur.com/MqtqNJr.png" title="source: imgur.com" /></div>

<br />

<div align="left"><img src="https://i.imgur.com/F2bnG4z.png" title="source: imgur.com" width="30px"/> <a href="https://neo4j.com/" target="_blank"><b>Site Oficial: <i>Neo4J</i></b></a>
<br />

<h3>4.4. Colunas</h3>



Os **bancos de dados do tipo Coluna** utilizam **colunas** para armazenar dados, em vez de linhas, como nos **bancos de dados relacionais**. Embora o conceito de banco de dados em colunas possa parecer similar ao modelo relacional à primeira vista, o verdadeiro poder desse tipo de banco de dados reside na sua abordagem **não normalizada** para a organização e estruturação dos dados.  Na imagem abaixo, vemos a estrutura básica de uma coluna:

<div align="center"><img src="https://i.imgur.com/OH0a0tj.png" title="source: imgur.com"/></div>

Em um banco de dados de colunas, os dados são armazenados em unidades chamadas **colunas**, em vez de linhas. Isso significa que cada coluna de uma tabela é armazenada separadamente, o que proporciona vantagens em termos de compressão e eficiência de leitura de grandes volumes de dados. Para ilustrar, considere a tabela de **Usuários** abaixo, com as colunas "Nome", "Usuário" e "Senha":

| Nome             | Usuario               | Senha      |
| ---------------- | --------------------- | ---------- |
| Paula Antunes    | paula@email.com.br    | x@123wk3#  |
| Mariana Silva    | mariana@email.com.br  | x@4A56wW3# |
| Fabrízia Pereira | fabrizia@email.com.br | z@434ywW3# |
| João dos Santos  | joao@email.com.br     | x@4AfgyW3# |

No modelo tradicional de **linhas** (utilizado em bancos relacionais), os dados seriam armazenados como registros completos, ou seja, cada linha representaria um cliente com suas informações. No banco de dados de colunas, os dados seriam armazenados da seguinte forma:

- **Coluna "Nome":** [Paula Antunes, Mariana Silva, Fabrízia Pereira, João dos Santos]
- **Coluna "Usuario":** [paula@email.com.br, mariana@email.com.br, fabrizia@email.com.br, joao@email.com.br]
- **Coluna "Senha":** [x@123wk3#, x@4A56wW3#, z@434ywW3#, x@4AfgyW3#]

Cada coluna é armazenada de forma contígua, o que facilita a compressão e a leitura rápida de grandes volumes de dados de uma única coluna.

Para uma melhor compreensão do banco de dados de colunas, é fundamental entender os conceitos: **Row Key**, **Keyspace**, **Famílias de Colunas**.

- **Row Key**: Assim como nos bancos de dados relacionais, funciona como uma espécie de chave primária em um banco de dados de colunas, que é utilizada para identificar de forma única cada linha da **Família de Colunas**. Isso é fundamental para o particionamento e distribuição dos dados no cluster, garantindo que os dados sejam armazenados e acessados de maneira eficiente. 

> Em um contexto de bancos de dados distribuídos, um **cluster** é um conjunto de **nós** (servidores) que trabalham em conjunto para fornecer um serviço de banco de dados escalável, resiliente e distribuído. Nesse ambiente, os dados são distribuídos e replicados entre os nós, permitindo que o sistema lide com grandes volumes de dados, mantendo a alta disponibilidade e o desempenho aprimorado.

<br />

> [!TIP]
>
> A **Row Key** em uma família de colunas pode ser composta apenas pelo **identificador único** (um ID, do tipo UUID) ou por uma combinação de campos (por exemplo, ID + data de criação), onde o segundo campo define a ordenação dos dados dentro da partição.

<br />

>**UUID** (sigla para *Universally Unique Identifier*) é um identificador único universal, amplamente utilizado em sistemas computacionais para identificar de maneira exclusiva objetos, registros ou entidades em diferentes contextos. Um UUID tem 128 bits e geralmente é representado como uma sequência de 32 caracteres hexadecimais divididos em 5 grupos, separados por hifens.

- **Keyspace**: É um **container** ou **namespace** onde as tabelas (famílias de colunas) são armazenadas. Em termos simples, é equivalente a um banco de dados do modelo relacional.
- **Família de Colunas (Column Family)**: É uma coleção de colunas, que compõem uma estrutura semelhante a uma  tabela, no banco de dados de colunas. Cada família de colunas é composta por várias colunas, organizadas pela **Row Key**, o que permite agrupar os dados de forma eficiente.

Na imagem abaixo, vemos uma representação gráfica de um **Keyspace**, que contém várias **Famílias de Colunas**:

<div align="center"><img src="https://i.imgur.com/rDm7Xm8.png" title="source: imgur.com" /></div>

Na imagem abaixo, vemos uma representação gráfica da **Família de Colunas de Usuário**:

<div align="center"><img src="https://i.imgur.com/d9mYiAC.png" title="source: imgur.com" /></div>

Na tabela abaixo, apresentamos uma comparação entre o modelo **relacional** e o modelo **não relacional** baseado em colunas:

| Modelo Relacional |      | Modelo Não Relacional - Colunas |
| :---------------: | :--: | :-----------------------------: |
|  Banco de dados   |  🡪   |            Keyspace             |
|      Tabelas      |  🡪   |       Família de Colunas        |
|  Chave Primária   |  🡪   |             Row Key             |
|      Colunas      |  🡪   |             Colunas             |

Os **bancos de dados de colunas** são otimizados para a **recuperação rápida de dados**, o que os torna ideais para **aplicativos analíticos** e **consultas de leitura intensiva**, como aplicações Big Data. O armazenamento orientado a colunas melhora a performance de consultas analíticas, pois reduz significativamente os requisitos de **E/S de disco** e diminui a quantidade de dados que precisam ser carregados do disco.

Alguns exemplos de bancos de dados baseados em colunas incluem **Cassandra**, **Apache HBase** e o **Scylla DB**.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
