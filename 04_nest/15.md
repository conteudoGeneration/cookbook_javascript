<h1>Introdu√ß√£o a Seguran√ßa do Backend</h1>



<div align="center"><img src="https://i.imgur.com/iyARgVe.png" title="source: imgur.com" /></div>

No universo da tecnologia, especialmente na Internet, nenhuma aplica√ß√£o em execu√ß√£o na nuvem pode ignorar a implanta√ß√£o de medidas de seguran√ßa robustas. Isso se deve aos in√∫meros riscos presentes no mundo virtual, como ataques de hackers, invas√µes de servidores e roubos de dados, entre outros. No ecossistema **NestJS**, a seguran√ßa da aplica√ß√£o √© refor√ßada por meio das **Bibliotecas Passport e JWT**.

Antes de explorarmos essas duas bibliotecas, √© fundamental compreender alguns conceitos b√°sicos sobre seguran√ßa de aplica√ß√µes no contexto do protocolo HTTP:

<br />

<h2>1. Seguran√ßa da Aplica√ß√£o</h2>



Neste t√≥pico vamos estudar 3 conceitos importantes da Seguran√ßa da Informa√ß√£o:

<br />

<h3>1.1. Autentica√ß√£o</h3>



<div align="center"><img src="https://i.imgur.com/oljXzoD.png" title="source: imgur.com" /></div>

Este √© o primeiro passo no processo de **Seguran√ßa da Informa√ß√£o** de uma aplica√ß√£o, amplamente conhecido como **login no sistema**. Nesse momento, o usu√°rio fornece suas credenciais de acesso, geralmente compostas por e-mail (usu√°rio) e senha. Em seguida, o sistema verifica a validade dessas informa√ß√µes para determinar se o acesso ser√° concedido.

<br />


<h3>1.2. Token</h3>



<div align="center"><img src="https://i.imgur.com/ETfJYCg.png?1" title="source: imgur.com" /></div>

Parte essencial do processo de autentica√ß√£o, um **token** √© um dado aparentemente sem significado ou uso por si s√≥, mas que, quando combinado ao sistema de seguran√ßa adequado, torna-se fundamental para a prote√ß√£o de uma aplica√ß√£o. A autentica√ß√£o baseada em token funciona garantindo que cada requisi√ß√£o enviada ao servidor contenha um token assinado, cuja autenticidade √© verificada antes que o servidor responda √† requisi√ß√£o.

Um exemplo pr√°tico do uso de tokens pode ser observado em aplicativos de Internet Banking, onde um novo token √© gerado para autorizar cada transa√ß√£o financeira, garantindo maior seguran√ßa.

A imagem acima ilustra a valida√ß√£o de um **Token Bearer**, que verifica se o token de autoriza√ß√£o enviado no cabe√ßalho da requisi√ß√£o est√° correto. Se o token enviado seguir o padr√£o Bearer, o sistema valida a autentica√ß√£o do usu√°rio e permite o encaminhamento da requisi√ß√£o para a classe controladora correspondente. Esse processo funciona como um filtro ou funil: apenas as requisi√ß√µes com tokens v√°lidos conseguem passar e alcan√ßar o recurso solicitado.

√â importante destacar que o **token** √© gerado durante o processo de autentica√ß√£o do usu√°rio e retornado na resposta √† requisi√ß√£o de login. Sua principal fun√ß√£o √© eliminar a necessidade de o usu√°rio autenticar-se novamente a cada requisi√ß√£o enviada para o sistema, funcionando como um indicador de que o usu√°rio que est√° enviando a requisi√ß√£o j√° foi autenticado.

Al√©m disso, o token geralmente possui um **tempo limite de validade**, que, ao expirar (normalmente ap√≥s 15 minutos), exige que o usu√°rio realize uma nova autentica√ß√£o para continuar acessando o sistema de forma segura.

<br />

<h3>1.3. Autoriza√ß√£o</h3>



<div align="center"><img src="https://i.imgur.com/kazNpLz.png" title="source: imgur.com" /></div>

Este √© o segundo passo no processo de **Seguran√ßa da Informa√ß√£o** do sistema, amplamente conhecido como **direitos de acesso (Roles)** no sistema. Nesse est√°gio, ap√≥s a autentica√ß√£o do usu√°rio, o sistema verifica quais a√ß√µes o usu√°rio est√° autorizado a realizar, determinando suas permiss√µes. Isso inclui identificar quais m√≥dulos, funcionalidades e endpoints da aplica√ß√£o o usu√°rio pode acessar, garantindo que ele tenha acesso apenas ao que √© permitido conforme seu perfil de usu√°rio (user, admin, entre outros).

<br />

<h2>3. Conhecendo o HTTP Authentication</h2>



O **IETF (*Internet Engineering Task Force*)** tem como miss√£o identificar e propor solu√ß√µes para problemas relacionados ao uso da Internet, al√©m de estabelecer a padroniza√ß√£o de tecnologias e protocolos associados. Ele tamb√©m √© respons√°vel por definir a estrutura de autentica√ß√£o HTTP que pode ser utilizada por um servidor para solicitar a autentica√ß√£o de um cliente.

No caso de uma autentica√ß√£o por token, quando o cliente tenta acessar um recurso sem as devidas credenciais ou com credenciais inv√°lidas, o servidor responde com um **HTTP Status 401 (N√£o autorizado)**. Al√©m disso, a resposta geralmente inclui um cabe√ßalho **WWW-Authenticate**, contendo informa√ß√µes sobre como o cliente pode se autenticar.

Para autenticar-se, o cliente deve incluir suas credenciais no cabe√ßalho da pr√≥xima requisi√ß√£o, utilizando o campo **Authorization**, conforme as especifica√ß√µes definidas pelo cabe√ßalho **WWW-Authenticate**.

No diagrama de sequ√™ncia abaixo, √© poss√≠vel observar esse processo de intera√ß√£o:

<div align="center"><img src="https://i.imgur.com/skGtKqr.png" title="source: imgur.com" /></div>

No caso de um **Token de autentica√ß√£o no formato ‚ÄúBearer‚Äù** (como ilustrado na figura acima), a troca de informa√ß√µes deve ocorrer por meio de uma conex√£o HTTP segura (**TLS - *Transport Layer Security***), a fim de garantir a prote√ß√£o contra vulnerabilidades.

> O **Token Bearer** √© um tipo de token utilizado em autentica√ß√£o, utilizado para garantir que o cliente tenha acesso a determinados recursos em um servidor. Ele √© comumente usado em APIs e sistemas que adotam um sistema de autentica√ß√£o baseada em tokens para facilitar os processos de autentica√ß√£o e autoriza√ß√£o.

Na primeira parte da imagem, observe que o servidor recebeu um token inv√°lido. Note que a aplica√ß√£o responder√° a requisi√ß√£o com o **HTTP Status 401 (N√£o autorizado)**, indicando que o usu√°rio deve fornecer um token v√°lido ou autenticar-se novamente no sistema para obter um novo token.

Na segunda parte da imagem, observe o servidor recebeu um token v√°lido, mas o usu√°rio n√£o possui as permiss√µes necess√°rias para acessar um determinado recurso. Note que a aplica√ß√£o responder√° a requisi√ß√£o com o **HTTP Status 403 (Proibido)**, indicando que, embora o usu√°rio esteja autenticado (token v√°lido), ele n√£o possui as permiss√µes necess√°rias para acessar o recurso solicitado devido a restri√ß√µes de **roles** (direitos de acesso). Neste caso, o usu√°rio ter√° que contatar o administrador do sistema e solicitar o acesso ao recurso. 

> O **TLS (Transport Layer Security)** √© um protocolo criptogr√°fico projetado para fornecer comunica√ß√£o segura em redes de computadores, especialmente na Internet. Ele garante a confidencialidade, integridade e autenticidade dos dados transmitidos entre as partes envolvidas, como um navegador e um servidor web.
>
> O TLS √© amplamente utilizado em protocolos como **HTTPS** (HTTP Seguro), garantindo que a navega√ß√£o na web seja segura para transa√ß√µes banc√°rias, compras online e outros tipos de comunica√ß√£o sens√≠vel. √â a evolu√ß√£o do antigo protocolo **SSL (Secure Sockets Layer)**, que foi substitu√≠do devido a algumas vulnerabilidades.

O token de autentica√ß√£o √© enviado no **cabe√ßalho da requisi√ß√£o HTTP**, na chave **Authorization**, por meio de uma string que cont√©m as credenciais para autenticar um usu√°rio em um servidor. O formato dessa string √© composto pelo tipo de autoriza√ß√£o (neste caso, **Bearer**), seguido das credenciais. Essas credenciais podem ser codificadas ou criptografadas, dependendo do esquema de autentica√ß√£o utilizado.

> **Cabe√ßalho HTTP:** Os cabe√ßalhos HTTP permitem que o cliente e o servidor enviem informa√ß√µes adicionais junto √† requisi√ß√£o ou resposta HTTP. Um cabe√ßalho de requisi√ß√£o √© composto por um nome **case-insensitive** (ou seja, n√£o diferencia letras mai√∫sculas ou min√∫sculas), denominado **key** (chave), seguido por dois pontos `:` e pelo seu valor (sem quebras de linha), denominado **value** (valor).
>
> **WWW-Authenticate:** Define o m√©todo de autentica√ß√£o que o cliente deve utilizar para obter acesso ao recurso solicitado.
>
> **Authorization:** Cont√©m as credenciais (geralmente um token) para autenticar um **User-Agent** junto ao servidor.

<br />

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status/401" target="_blank"><b>Documenta√ß√£o: HTTP Status Code 401 - Unauthorized</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status/403" target="_blank"><b>Documenta√ß√£o: HTTP Status Code 403 - Forbidden</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/WWW-Authenticate" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho HTTP WWW-Authenticate</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Authorization" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho de Requisi√ß√£o HTTP Authorization</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers" target="_blank"><b>Documenta√ß√£o: Cabe√ßalhos HTTP</b></a></div>

<br />

<h3>3.1. Esquema Bearer</h3>



A estrutura geral de autentica√ß√£o HTTP √© utilizada por diversos esquemas de autentica√ß√£o. Esses esquemas podem variar em termos de for√ßa de seguran√ßa e disponibilidade de software para clientes e servidores. Os esquemas mais comuns de autentica√ß√£o s√£o o **Basic** e o **Bearer**, mas existem outros esquemas fornecidos por servi√ßos de hospedagem, como AWS, Google e Microsoft.

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left">**ATEN√á√ÉO:** Para melhor compreens√£o no momento, vamos focar apenas no entendimento do formato Bearer, que √© considerado um dos esquemas mais populares. Vale mencionar que para aprender os demais √© necess√°rio tempo e muita dedica√ß√£o.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

No projeto **Blog Pessoal**, utilizaremos o esquema **Bearer**, que, segundo a sua documenta√ß√£o, consiste em um conjunto de caracteres codificados posicionados ap√≥s a palavra **"Bearer"** (o espa√ßo em branco ap√≥s a palavra **Bearer** √© obrigat√≥rio), formando um ***Authorization Token*** que ser√° enviado ao sistema. No trecho de c√≥digo abaixo, podemos observar um exemplo simples de um **Token Bearer**:

```bash
Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbkBlbWFpbC5jb20uYnIiLCJpYXQiOjE3MDk3ODk1OTMsImV4cCI6MTcwOTc5MzE5M30.tLm4bkpANFOKOynIETNi6oN8EtSanXLbbo1Uvfu7ZhU
```

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | ALERTA DE BSM: Mantenha a Aten√ß√£o aos Detalhes ao escrever o Token no formato Bearer, o mesmo √© representado pela palavra "*Bearer* " com um espa√ßo em branco na frente + um conjunto de caracteres codificados, que ser√£o fornecidos ao se autenticar no sistema. |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Authorization" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho de Requisi√ß√£o HTTP Authorization</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://www.rfc-editor.org/rfc/rfc6750.html" target="_blank"><b>Documenta√ß√£o: Esquema de autentica√ß√£o Bearer</b></a></div>

<br />

<h3>3.2. Token JWT</h3>



Existem diversas maneiras de gerar um **Token Bearer**, e no **Projeto Blog Pessoal**, utilizaremos o padr√£o **JWT - JSON Web Token**. O JWT √© um padr√£o amplamente utilizado e muito popular no mercado, que define como transmitir e armazenar objetos JSON de forma compacta e segura entre diferentes aplica√ß√µes. Os dados contidos no JWT podem ser validados a qualquer momento, pois o token √© assinado digitalmente. Na imagem abaixo, vemos a estrutura de um Token JWT:

<div align="center"><img src="https://i.imgur.com/QHRc3WG.png" title="source: imgur.com" /></div>

Um Token JWT √© formado por tr√™s se√ß√µes: **Header, Payload e Signature.**

O **Header** (cabe√ßalho do token) √© um objeto JSON que define informa√ß√µes sobre o tipo do token (geralmente **JWT**) e o algoritmo de criptografia utilizado na assinatura (**alg**), sendo o mais comum o **HMAC SHA256**. No c√≥digo abaixo, vemos um exemplo de cabe√ßalho:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

O **Payload** √© um objeto JSON que cont√©m as **claims** (informa√ß√µes) da entidade tratada, geralmente o usu√°rio autenticado.

As claims do payload podem ser de 3 tipos:

| Tipo         | Descri√ß√£o                                                    |
| ------------ | ------------------------------------------------------------ |
| **Reserved** | S√£o os atributos n√£o obrigat√≥rios (mas recomendados), que s√£o usados na valida√ß√£o do token pelos protocolos de seguran√ßa das APIs. |
| **Public**   | S√£o os atributos que usamos em nossas aplica√ß√µes. Normalmente armazenamos as informa√ß√µes do usu√°rio autenticado na aplica√ß√£o. |
| **Private**  | S√£o os atributos definidos especialmente para compartilhar informa√ß√µes entre aplica√ß√µes, tais como nome do usu√°rio e os direitos de acesso (**Roles:** admin, usuario comum, entre outros). |

Na tabela abaixo, temos a lista com as principais Claims utilizadas no payload:

| Claim                | Descri√ß√£o                                                    |
| -------------------- | ------------------------------------------------------------ |
| **sub (subject)**    | Entidade √† quem o token pertence.                            |
| **iss (issuer)**     | Emissor do token.                                            |
| **exp (expiration)** | Timestamp de quando o token ir√° expirar.                     |
| **iat (issued at)**  | Timestamp de quando o token foi criado.                      |
| **aud (audience)**   | Destinat√°rio do token, representa a aplica√ß√£o que ir√° us√°-lo. |

<br />

No c√≥digo abaixo, vemos o Payload, que utilizaremos no Projeto Blog Pessoal:

```json
{
  "sub": "admin@email.com.br",
  "iat": 1659642790,
  "exp": 1659729190
}
```

Observe que a Claim **iat** e a Claim **exp** s√£o inseridas pelo gerador do Token e ambas as datas est√£o no formato **Timestamp**.

<br />

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="100px"/> | <div align="left">**DICA:** *Para saber qual √© a data e hora, utilize um conversor Timestamp ü°™ Date. Um bom exemplo √© o site: Epoch Converter (link abaixo).*</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | ALERTA DE BSM: Mantenha a Aten√ß√£o aos Detalhes ao criar o Token JWT. Por seguran√ßa recomenda-se n√£o armazenar informa√ß√µes confidenciais ou sens√≠veis no payload do token como a senha, por exemplo. |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

A **Signature** (assinatura) √© gerada pela concatena√ß√£o de tr√™s partes:

1. A string gerada a partir da **codifica√ß√£o do Header** utilizando o algoritmo de codifica√ß√£o **base64UrlEncode**.
2. Um **ponto final** (`.`).
3. A string gerada a partir da **codifica√ß√£o do Payload** utilizando o algoritmo de codifica√ß√£o **base64UrlEncode**.
4. Um **ponto final** (`.`).
5. A chave secreta (**Secret Key**).

Essa string concatenada √© ent√£o criptografada usando o algoritmo **HMAC SHA256**, gerando a assinatura do Token JWT. Abaixo, vemos o modelo de gera√ß√£o da assinatura:

<div align="center"><img src="https://i.imgur.com/pwEUNz3.png" title="source: imgur.com" /></div>

Essa assinatura assegura que o token n√£o foi alterado, j√° que qualquer modifica√ß√£o no Header ou Payload invalidaria a assinatura, tornando o token inv√°lido.

Observe que as sess√µes s√£o concatenadas com um ponto (.), separando as sess√µes, seguindo a estrutura: **header.payload.secretKey**.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left">**ATEN√á√ÉO:** N√£o se preocupe em aprender como cada um destes algoritmos de codifica√ß√£o e criptografia funcionam internamente. O mais importante agora √© saber que eles existem e como us√°-los.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

Para decodificar o Token JWT, podemos utilizar a **Ferramenta Debugger do pr√≥prio JWT**. Com ela √© poss√≠vel **decodificar o cabe√ßalho e o payload**, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/YJpWB7M.png" title="source: imgur.com" /></div>

Para decodificar um Token JWT, insira a parte **codificada do Token** (tudo, exceto a palavra "Bearer") no campo **Encoded**. Em seguida, marque a op√ß√£o **secret base64 encoded** e confira o resultado no campo **Decoded**.

A **Assinatura** n√£o √© t√£o simples de decodificar, pois, al√©m de utilizar o algoritmo **HMAC SHA256**, tamb√©m seria necess√°rio criar um algoritmo espec√≠fico para validar a assinatura, assim como a Biblioteca Passport faz no Nest. Al√©m disso, √© imprescind√≠vel conhecer a **Secret Key** previamente, pois √© ela que garante a integridade e a autenticidade do token.

<br />

<div align="left"><img src="https://i.imgur.com/EbNCWSI.png" title="source: imgur.com" width="35px"/> <a href="https://www.epochconverter.com/" target="_blank"><b>Ferramenta: Epoch Converter</b></a></div>

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="35px"/> <a href="https://jwt.io/introduction" target="_blank"><b>Documenta√ß√£o: JWT - JSON WEB Token</b></a></div>

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="35px"/> <a href="https://jwt.io/#debugger-io" target="_blank"><b>Ferramenta: JWT Debugger</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://pt.wikipedia.org/wiki/Base64" target="_blank"><b>Artigo: Modelo Base 64</b></a> - Como funciona o modelo de Codifica√ß√£o Base 64.</div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://pt.wikipedia.org/wiki/HMAC" target="_blank"><b>Artigo: Modelo HMAC SHA256</b></a> - Como funciona o modelo de Codifica√ß√£o HMAC SHA256.</div>

<br />

O Token gerado ser√° enviado no Header (cabe√ßalho) de todas as Requisi√ß√µes com endpoints protegidos. Se o token n√£o for enviado, todos os endpoints protegidos por autentica√ß√£o retornar√£o como resposta o status acesso negado (**UNAUTHORIZED ü°™ 401**).

<br />

<h2>4. Biblioteca Passport</h2>



Analisando o **Projeto Blog Pessoal**, podemos perceber que nossa API, at√© o momento, n√£o possui nenhum mecanismo de seguran√ßa, ou seja, qualquer pessoa pode acessar livremente todos os endpoints de todos os m√≥dulos. A maioria das aplica√ß√µes desenvolvidas lida com informa√ß√µes sens√≠veis, como dados pessoais e banc√°rios, e, por isso, √© fundamental garantir que tanto a aplica√ß√£o quanto esses dados estejam devidamente protegidos contra acessos n√£o autorizados. Para implementar essa prote√ß√£o em aplicativos **NestJS**, utilizaremos a biblioteca JavaScript/TypeScript chamada **Passport**.

<br />

<div align="left"><img src="https://i.imgur.com/51OZ5ug.png" title="source: imgur.com" width="30px"/> <a href="https://www.passportjs.org/docs/" target="_blank"><b>Documenta√ß√£o: Passport</b></a></div>

<br />

O **Passport** √© uma biblioteca NodeJS muito popular, amplamente utilizada para **autentica√ß√£o de usu√°rios**. Ela oferece mais de 500 estrat√©gias de autentica√ß√£o diferentes, que v√£o desde a tradicional autentica√ß√£o por usu√°rio e senha at√© solu√ß√µes de autentica√ß√£o com servi√ßos de terceiros, como Google, Facebook, GitHub, entre outros. Essas estrat√©gias implementam diversos mecanismos de autentica√ß√£o.

Nos aplicativos web modernos, a autentica√ß√£o pode ser realizada de v√°rias maneiras. A mais comum √© o tradicional login, onde os usu√°rios fornecem um nome de usu√°rio (geralmente o e-mail) e uma senha. Al√©m disso, as redes sociais criaram o conceito de **login √∫nico (SSO - Single Sign-On)**, permitindo que os usu√°rios fa√ßam login utilizando suas contas do Facebook, Google, GitHub, entre outros. Inova√ß√µes mais recentes tamb√©m possibilitam o uso de **impress√£o digital** ou **reconhecimento facial** como m√©todos de autentica√ß√£o.

> **SSO** (*Single Sign-On*) √© um processo de autentica√ß√£o que permite aos usu√°rios acessarem m√∫ltiplos sistemas ou aplica√ß√µes com um √∫nico conjunto de credenciais (nome de usu√°rio e senha). Com o SSO, uma vez que o usu√°rio fa√ßa login em um servi√ßo, ele poder√° acessar outros servi√ßos integrados ao SSO sem precisar fazer login novamente. Isso oferece uma experi√™ncia mais fluida e pr√°tica para os usu√°rios, al√©m de facilitar o gerenciamento de credenciais para os administradores de sistemas.
>
> Por exemplo, ao usar **SSO**, um usu√°rio que se autentica em um servi√ßo como o **Google** ou **Facebook** pode, automaticamente, acessar outras plataformas ou aplicativos que estejam configurados para aceitar esse login, sem precisar inserir as credenciais novamente.

Para oferecer suporte a aplicativos web, m√≥veis e desktop nativos, a l√≥gica do lado do servidor ser√° exposta como uma API (endpoints), acessada por aplicativos em dispositivos m√≥veis, desktops ou navegadores executando JavaScript no lado do cliente. O acesso a essas APIs √© protegido por credenciais baseadas em token, geralmente emitidos durante o processo de autentica√ß√£o. O Passport fornece uma estrutura flex√≠vel que permite que um aplicativo utilize qualquer um desses mecanismos de autentica√ß√£o, garantindo a seguran√ßa e a flexibilidade necess√°rias para diferentes tipos de aplica√ß√£o.

<br />

<h3>4.1 Modelos de Autentica√ß√£o</h3>



Existem v√°rios modelos de autentica√ß√£o, na imagem abaixo, vemos os modelos mais utilizados:

<div align="center"><img src="https://i.imgur.com/tSIBSoU.png?1" title="source: imgur.com" /></div>

**Autentica√ß√£o baseada em sess√£o**: Utiliza cookies do navegador juntamente com "sess√µes" de back-end para gerenciar o estado de usu√°rios conectados e desconectados. Ap√≥s o login, o servidor cria uma sess√£o que √© identificada por um cookie armazenado no navegador, e esse cookie √© enviado junto com as requisi√ß√µes subsequentes, permitindo ao servidor identificar e autenticar o usu√°rio at√© que a sess√£o expire ou o usu√°rio fa√ßa logout.

**Autentica√ß√£o baseada em token**: √â um m√©todo de autentica√ß√£o sem estado em que um token (geralmente armazenado no gerenciador de estado global da aplica√ß√£o Frontend ou Mobile), que √© usado para representar a identidade do usu√°rio. O token cont√©m informa√ß√µes sobre o usu√°rio e √© assinado com uma chave secreta, de modo que o servidor possa verificar sua autenticidade. Como a autentica√ß√£o baseada em token n√£o depende de sess√µes, ela √© mais adequada para sistemas distribu√≠dos, como API's REST.

**Autentica√ß√£o OAuth**: √â um m√©todo de autentica√ß√£o moderno em que um aplicativo utiliza outro servi√ßo para autenticar seus usu√°rios. Em vez de gerenciar credenciais diretamente, o aplicativo delega a autentica√ß√£o a um provedor de identidade confi√°vel (como **Google**, **Facebook**, ou **GitHub**). O provedor autentica o usu√°rio e retorna um token de acesso ao aplicativo, que pode ser usado para acessar os dados do usu√°rio ou fazer chamadas em nome dele. O OAuth facilita a implementa√ß√£o de login √∫nico (SSO) e aumenta a seguran√ßa, pois os aplicativos n√£o precisam lidar diretamente com senhas do usu√°rio.

No projeto Blog Pessoal vamos utilizar a **Autentica√ß√£o Baseada em Tokens JWT**.

<br />

<h3>4.2 Strategies (Estrat√©gias)</h3>



As **estrat√©gias de autentica√ß√£o** s√£o respons√°veis por validar as requisi√ß√µes, implementando mecanismos espec√≠ficos de autentica√ß√£o. Esses mecanismos definem como codificar uma credencial, como uma senha, em uma requisi√ß√£o e como verificar a autenticidade dessa credencial. Se a credencial fornecida for validada com sucesso, a requisi√ß√£o ser√° considerada autenticada. Dessa forma, as estrat√©gias garantem que apenas usu√°rios devidamente autenticados tenham acesso aos recursos da aplica√ß√£o.

No projeto Blog Pessoal usaremos as **Estrat√©gias Local e JWT**. 

<br />

<h4>4.2.1 Local Strategy</h4>



A **Estrat√©gia Local faz a autentica√ß√£o atrav√©s de um usu√°rio e uma senha**. 

O **Passport Local** executa uma s√©rie de etapas conforme descrito abaixo:

1. **Autentica√ß√£o do usu√°rio**: O processo come√ßa com a verifica√ß√£o das credenciais do usu√°rio, que geralmente consistem em um nome de usu√°rio e uma senha.
2. **Gerenciamento do estado de autentica√ß√£o**: Ap√≥s a valida√ß√£o das credenciais, um token de autentica√ß√£o √© gerado para manter o estado da sess√£o do usu√°rio.
3. **Inclus√£o do token e dados do usu√°rio na resposta**: O token gerado e os dados do usu√°rio s√£o adicionados ao corpo da resposta, permitindo que o cliente acesse e utilize esses dados para futuras intera√ß√µes.

Para simplificar a implementa√ß√£o, o m√≥dulo **@nestjs/passport** envolve o padr√£o de uso do Passport de forma que se integra perfeitamente √† estrutura do **NestJS**. Isso reduz a complexidade do processo de implementa√ß√£o de autentica√ß√£o usando o Passport no NestJS. A imagem abaixo ilustra o processo de autentica√ß√£o utilizando a **Passport Local Strategy**.

<div align="center"><img src="https://i.imgur.com/ZIVm3y5.png" title="source: imgur.com" /></div>

1. O usu√°rio informa suas credenciais (usu√°rio e senha).
2. Uma **requisi√ß√£o HTTP do tipo POST** √© gerada, e as credenciais s√£o enviadas no corpo da requisi√ß√£o, no formato JSON.
3. O **Passport** recebe a requisi√ß√£o e verifica se o endpoint que recebeu a requisi√ß√£o est√° decorado com a estrat√©gia **Local Strategy**.
4. O **Passport Local Strategy** √© o respons√°vel pela autentica√ß√£o da aplica√ß√£o. Ele realiza a pesquisa no banco de dados para **validar o usu√°rio e a senha** atrav√©s da Classe **UsuarioService**, al√©m de **gerar o payload** que ser√° enviado para a classe **JwtService** da biblioteca **JWT** do NestJS, para gerar o **Token JWT** do usu√°rio.
5. A classe **JwtService** recebe o payload, gera o Token JWT e o envia para o **Passport Local Strategy** anexar ao corpo da resposta da requisi√ß√£o de login.
6. Se as credenciais forem validadas e o token for gerado corretamente, o **Passport Local Strategy** gera uma resposta para a requisi√ß√£o confirmando a autentica√ß√£o (**OK ü°™ 200**) e envia, no corpo da resposta, o **Token JWT** gerado.
7. Caso o usu√°rio ou a senha n√£o sejam v√°lidos, o **Passport Local Strategy** gera uma resposta negando o acesso ao usu√°rio (**UNAUTHORIZED ü°™ 401**).

<br />

<div align="left"><img src="https://i.imgur.com/51OZ5ug.png" title="source: imgur.com" width="30px"/> <a href="https://www.passportjs.org/packages/passport-local/" target="_blank"><b>Documenta√ß√£o: Passport Local Strategy</b></a></div>

<br />

<h4>4.2.2 JWT Strategy</h4>



A estrat√©gia **JWT** tem a fun√ß√£o de **validar o Token JWT** nos endpoints protegidos da aplica√ß√£o. √â importante destacar que o **Passport JWT** n√£o cria o Token JWT; ele apenas valida o token. Como mencionado no t√≥pico anterior, o **Token JWT** √© gerado pela **Biblioteca JWT do NestJS** durante o processo de autentica√ß√£o local.

O **Passport JWT** executa uma s√©rie de etapas, conforme listado abaixo:

1. O Passport JWT **extrai o Token** do cabe√ßalho da requisi√ß√£o.
2. **Valida o Token** para garantir que ele seja leg√≠timo e que n√£o tenha expirado.
3. **Autoriza o usu√°rio** a acessar o recurso solicitado, caso o token seja v√°lido.

Para facilitar a implementa√ß√£o, o m√≥dulo **@nestjs/passport** envolve todo o padr√£o de uso do Passport em constru√ß√µes familiares ao NestJS, simplificando o processo de implementa√ß√£o da autentica√ß√£o. Na imagem abaixo, vemos um resumo do processo de valida√ß√£o do Token ao criar uma nova postagem no projeto **Blog Pessoal**:

<div align="center"><img src="https://i.imgur.com/yye9NOH.png" title="source: imgur.com" /></div>

1. O **usu√°rio cria uma nova postagem**.
2. Uma **requisi√ß√£o HTTP do tipo POST** √© gerada, e os dados da postagem s√£o enviados no corpo da requisi√ß√£o, no formato JSON. Al√©m disso, o **Token JWT**, recebido durante a autentica√ß√£o, √© enviado no **cabe√ßalho da requisi√ß√£o**, na chave **Authorization**.
3. O **Passport** recebe a requisi√ß√£o e verifica se o endpoint que recebeu a requisi√ß√£o est√° decorado com a estrat√©gia **JWT Strategy**.
4. O **Passport JWT Strategy** recebe o **Token JWT** do usu√°rio e inicia o processo de valida√ß√£o.
5. Ap√≥s a valida√ß√£o, o **Passport JWT Strategy** autoriza o acesso ao endpoint, caso o **token seja validado**. O **endpoint /postagens** ent√£o gera uma resposta para a requisi√ß√£o, confirmando a cria√ß√£o da nova postagem (**CREATED ü°™ 201**) e envia, no corpo da resposta, os dados da nova postagem.
6. Caso o **Token JWT n√£o seja validado**, o **Passport JWT Strategy** gera uma resposta para a requisi√ß√£o negando o acesso ao usu√°rio (**UNAUTHORIZED ü°™ 401**).

<br />

<div align="left"><img src="https://i.imgur.com/51OZ5ug.png" title="source: imgur.com" width="30px"/> <a href="https://www.passportjs.org/packages/passport-jwt/" target="_blank"><b>Documenta√ß√£o: Passport JWT Strategy</b></a></div>

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
