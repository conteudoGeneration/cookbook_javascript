<h1>Teste de Software - Jest - Introdu√ß√£o</h1>

O teste de software √© uma forma de avaliar a qualidade da aplica√ß√£o e reduzir os riscos de falhas no c√≥digo ao ser colocado  em Produ√ß√£o (na nuvem). Testar n√£o se resume apenas em executar testes simples e verificar os resultados. **Executar** testes √© apenas umas das atividades. Planejamento, an√°lise, modelagem e implementa√ß√£o dos testes,  relat√≥rios de progresso, resultado e avalia√ß√£o da qualidade, tamb√©m s√£o partes de um **processo de testes**.

Testar software n√£o √© somente **verificar** se os requisitos foram atendidos, atribui-se ao teste de software tamb√©m a **valida√ß√£o**, ou  seja, verificar se o sistema atende √†s necessidades do usu√°rio e de outras partes interessadas em seu(s) ambiente(s) operacional(is).

Outro ponto importante dos testes, que muitas vezes √© ignorado pelas pessoas desenvolvedoras, √© que n√£o basta testar apenas o melhor cen√°rio, deve-se testar tamb√©m os cen√°rios que podem causar erros (enviar um atributo nulo ou repetido, por exemplo), ou seja, checar se a aplica√ß√£o est√° fazendo todas a valida√ß√µes necess√°rias e respeitando todas as Regras de Neg√≥cio da aplica√ß√£o para minimizar ao m√°ximo os erros em produ√ß√£o.

<h2>1. A Pir√¢mide de Testes</h2>

A **Pir√¢mide de Testes** √© uma representa√ß√£o gr√°fica que nos diz para agrupar testes de software em diferentes tipos. A pir√¢mide ilustra de forma impl√≠cita a quantidade de testes que devem ser realizados em rela√ß√£o ao tipo, aos custos e ao tempo de dura√ß√£o.

<div align="center"><img src="https://i.imgur.com/seQZN6f.png" title="source: imgur.com" width="75%"/></div>

Observe que os testes na base s√£o mais r√°pidos e baratos do que os testes no topo da pir√¢mide.

Existem tr√™s tipos de teste:

- Teste de Unidade
- Teste de Integra√ß√£o
- Teste End to End (E2E)

<h3>1.1. Teste de unidade</h3>

Uma unidade pode ser uma fun√ß√£o, uma classe, um pacote ou um subsistema. Portanto, o termo teste de unidade refere-se √† pr√°tica de testar pequenas unidades do seu c√≥digo, para garantir que funcionem conforme o esperado.

O Teste de Unidade √© o teste mais comum, porqu√™ al√©m de ser muito r√°pido √© o teste mais barato porqu√™ pode ser criado pela pr√≥pria pessoa desenvolvedora durante o processo de codifica√ß√£o.

<h3>1.2. Teste de integra√ß√£o</h3>

Teste de Integra√ß√£o √© a fase do teste de software em que os m√≥dulos s√£o combinados e testados em conjunto, para checar como os m√≥dulos se comportam quando interagem entre si.

Um exemplo pr√°tico deste tipo de testes √© o da **‚Äúporta e  da fechadura‚Äù** em que o requisito √© a fechadura trancar a porta. Como  apenas foram feitos testes unit√°rios dos componentes isoladamente, quando houve a integra√ß√£o dos mesmos n√£o cumpriam o requisito, porque aquele tipo de fechadura n√£o tranca portas de deslizar. Assim, atrav√©s dos testes de integra√ß√£o conseguimos perceber se os componentes que foram desenvolvidos isoladamente quando interligados cumprem ou n√£o com  os requisitos do neg√≥cio.

<div align="center"><img src="https://i.imgur.com/sjACFFr.gif" title="source: imgur.com" /></div>

O Teste de Integra√ß√£o √© um pouco mais lento e um pouco mais caro do que o Teste de Unidade porqu√™ aumenta a complexidade.

<h3>1.3. Teste End to End</h3>

O Teste End to End (ponta a ponta) √© uma metodologia de teste de software para  testar um fluxo do aplicativo do in√≠cio ao fim. O objetivo deste teste √© simular um cen√°rio real do usu√°rio e validar o sistema em teste e seus componentes para integra√ß√£o e integridade dos dados.

O Teste End to End √© mais lento (depende de pessoas para testarem o software como um todo em produ√ß√£o ou vers√£o beta), o que o torna muito mais caro do que os Testes de Unidade e Integra√ß√£o, o que explica serem realizados em menor quantidade.

Os frameworks de teste atuais oferecem a possibilidade de escrever testes End to End, entretanto se faz necess√°rio escrever diversos testes, dependendo do tamanho e da complexidade da aplica√ß√£o, para cobrir todo o software.

<h3>1.4. O que deve ser testado?</h3>

A prioridade sempre ser√° escrever testes para as partes mais complexas ou cr√≠ticas de seu c√≥digo, ou seja, aquilo que √© essencial para que o c√≥digo traga o resultado esperado. **Exemplo:** Em um e-commerce a finaliza√ß√£o da compra √© um ponto cr√≠tico da aplica√ß√£o.

<h2>2. NestJS Testing</h2>

O **NestJS Testing** √© parte integrante do Nest e oferece suporte a testes de unidade, integra√ß√£o e E2E, utilizando o  Framework de Testes JavaScript **Jest**. 
Ao criar um projeto com o Nest, automaticamente os pacotes de teste j√° s√£o inseridos no projeto como veremos adiante.

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="25px"/> <a href="https://docs.nestjs.com/fundamentals/testing" target="_blank"><b>Documenta√ß√£o:  NestJS Testing</b></a>
<h3>2.1. NestJS Testing - Classes principais</h3>

<table width=100%>
	<tr>
        <td width=15%><b>Classes</b></td>
		<td width=70%><b>Descri√ß√£o</td>
	</tr>
	<tr>
        <td><i>Test</i></td>
        <td><p align="justify">A classe Test cria o ambiente para escrever e executar os testes com o Jest. A classe Test possui o M√©todo <b>createTestingModule()</b>, que inicializa um M√≥dulo de Testes atrav√©s de um Objeto do M√≥dulo da aplica√ß√£o (AppModule) ou um array contendo um Objeto de cada M√≥dulo que ser√° testado. Esse M√©todo tamb√©m recebe as configura√ß√µes do Banco de dados de teste.</td>
	</tr>
    <tr>
        <td><i>TestingModule</i></td>
        <td><p align="justify">Fornece alguns m√©todos para testes de unidade. O M√©todo mais  importante √© o m√©todo <b>compile()</b>. Esse m√©todo inicializa o M√≥dulo com suas depend√™ncias (semelhante √† maneira como um aplicativo √© inicializado no arquivo <b>main.ts</b> convencional usando o M√©todo <b>NestFactory.create()</b>) e retorna um m√≥dulo que est√° pronto para teste.</td>
	</tr>
</table>
<h2>3. O framework Jest</h2>

O Jest √© um Framework de testes de c√≥digo aberto para a linguagem JavaScript, que √© usado para escrever e executar testes automatizados e repetitivos, para que possamos ter certeza que nosso c√≥digo funciona conforme o esperado. O Jest √© um Framework com foco na simplicidade. Funciona com projetos usando: Nest, TypeScript, Node, React, Angular, Vue e muito mais!

Jest √© uma estrutura de teste JavaScript projetada para garantir a exatid√£o de qualquer base de c√≥digo JavaScript. Ele permite que voc√™ escreva testes com uma API acess√≠vel, familiar e rica em recursos que fornece resultados rapidamente. O Jest est√° bem documentado, requer pouca configura√ß√£o e pode ser estendido para atender √†s suas necessidades.

O Jest fornece:

- Testes Instant√¢neos que validam Objetos grandes com facilidade. 
- Testes paralelizados, executando-os em seus pr√≥prios processos para maximizar o desempenho. 
- Um kit de ferramentas de teste em um s√≥ lugar, amplamente documentado.

O Jest √© usado para testar:

* Um objeto inteiro
* Parte de um objeto, como um m√©todo ou alguns m√©todos de intera√ß√£o
* Intera√ß√£o entre v√°rios objetos 
* Um M√≥dulo inteiro

<div align="left"><img src="https://i.imgur.com/3tsv1lE.png" title="source: imgur.com" width="30px"/> <a href="https://jestjs.io/pt-BR/docs/api" target="_blank"><b>Documenta√ß√£o: Jest</b></a>


<h3>3.1. Principais M√©todos do Jest</h3>

<table width=100%>
	<tr>
        <td width=15%><b>M√©todos</b></td>
		<td width=70%><b>Descri√ß√£o</td>
	</tr>
	<tr>
		<td><i>describe</i></td>
        <td>Podemos definir o describe como uma suite de testes, ou seja, um describe pode ter um conjunto de testes. Dentro dos describes podemos ainda colocar outros describes com outros conjuntos de testes<br /><b>Exemplo:</b> Testes do M√≥dulo Usuario e Auth.</td>
	</tr>
    <tr>
		<td><i>it</i></td>
        <td>S√£o os nossos testes, cada it √© um teste, logo os describes aglomeram um conjunto de its.</td>
	</tr>
	<tr>
		<td><i>beforeEach</i></td>
        <td>Executa um conjunto de a√ß√µes antes de cada teste ser iniciado, para criar as pr√©-condi√ß√µes necess√°rias para cada teste (criar Objetos, vari√°veis, entre outros).</td>
	</tr>
	<tr>
		<td><i>beforeAll</i></td>
        <td>Executa  um conjunto de a√ß√µes, apenas uma vez, antes de iniciar a s√©rie de testes, para criar as pr√©-condi√ß√µes necess√°rias para todos os testes (criar Objetos, vari√°veis, entre outros).</td>
	</tr>
	<tr>
		<td><i>afterEach</i></td>
        <td>Executa um conjunto de a√ß√µes depois de cada teste ser finalizado, para redefinir algumas condi√ß√µes ap√≥s a execu√ß√£o de cada teste (limpar o Banco de dados, redefinir Objetos e Vari√°veis, entre outros).</td>
	</tr>
	<tr>
		<td><i>afterAll</i></td>
        <td>Executa  um conjunto de a√ß√µes, apenas uma vez, depois de todos os testes serem finalizados, para redefinir algumas condi√ß√µes ap√≥s a execu√ß√£o de todos os testes (limpar o Banco de dados, redefinir Objetos e Vari√°veis, entre outros).</td>
	</tr>
	<tr>
		<td><i>test.skip</i></td>
		<td>Desabilita temporariamente a execu√ß√£o de um teste espec√≠fico. Cada teste criado com o M√©todo test.skip n√£o ser√°  executado.</td>
	</tr>
	<tr>
		<td><i>test.only</i></td>
        <td>Desabilita temporariamente a execu√ß√£o de todos os testes, exceto o teste criado com o M√©todo test.only.</td>
	</tr>
</table>


<h3>3.2. M√©todo expect() do Jest</h3>

O **M√©todo expect() do Jest** permite checar se os valores satisfazem certas condi√ß√µes, al√©m de lhe dar acesso a in√∫meros "matchers" (M√©todos para testar valores), que permitem validar diferentes coisas, atrav√©s de asser√ß√µes (afirma√ß√µes). **Exemplo:** 1+1 √© igual 2

Veja alguns exemplos abaixo:

| M√©todo                                     | Descri√ß√£o                                           |
| ------------------------------------------ | --------------------------------------------------- |
| **expect(soma).toBe(2);**                  | Afirma que a vari√°vel soma √© igual a 2.             |
| **expect(soma).not.toBe(0);**              | Afirma que a vari√°vel soma n√£o √© igual a 0.         |
| **expect(nome).toEqual('Jo√£o da Silva');** | Afirma que a vari√°vel nome √© igual a Jo√£o da Silva. |
| **expect(foto).toBeNull();**               | Afirma que a vari√°vel foto n√£o √© nula.              |

<div align="left"><img src="https://i.imgur.com/3tsv1lE.png" title="source: imgur.com" width="30px"/> <a href="https://jestjs.io/pt-BR/docs/expect" target="_blank"><b>Documenta√ß√£o: M√©todo Expect - Jest</b></a>


<h2>4. Biblioteca SuperTest</h2>

**SuperTest** √© uma Biblioteca Node.js que ajuda as pessoas desenvolvedoras a testar API's. Ela estende outra Biblioteca chamada **SuperAgent** (um cliente HTTP JavaScript para Node.js, semelhante ao Insomnia e o Postman, mas sem Interface Gr√°fica), que complementa o Framework Jest, oferecendo M√©todos para testar Requisi√ß√µes HTTP de forma simples e r√°pida. 

<div align="left"><img src="https://i.imgur.com/kuK7aM3.png" title="source: imgur.com" width="35px"/> <a href="https://github.com/visionmedia/supertest#readme" target="_blank"><b>Documenta√ß√£o: Supertest</b></a>


<h3>4.1. M√©todos da Biblioteca SuperTest</h3>

| M√©todo        | Descri√ß√£o                                                    |
| ------------- | ------------------------------------------------------------ |
| **request()** | Cria uma nova Requisi√ß√£o. Este m√©todo recebe como par√¢metro o Ambiente de Testes que foi criado pelas Classes **Test e TestingModule** e inicializada pelo M√©todo **init()** do Nest. |
| **get()**     | Define que a Requisi√ß√£o ser√° do tipo **HTTP GET**. Este M√©todo recebe como par√¢metro o endere√ßo do endpoint. |
| **post()**    | Define que a Requisi√ß√£o ser√° do tipo **HTTP POST**. Este M√©todo recebe como par√¢metro o endere√ßo do endpoint. |
| **put()**     | Define que a Requisi√ß√£o ser√° do tipo **HTTP PUT**. Este M√©todo recebe como par√¢metro o endere√ßo do endpoint. |
| **delete()**  | Define que a Requisi√ß√£o ser√° do tipo **HTTP DELETE**. Este M√©todo recebe como par√¢metro o endere√ßo do endpoint. |
| **set()**     | Permite enviar dados atrav√©s do **Cabe√ßalho (Header)** da Requisi√ß√£o. Um uso muito comum √© enviar o **Token JWT** nas Requisi√ß√µes cujo o endpoint est√° protegido. |
| **expect()**  | Define a Resposta HTTP (Status), que se espera da requisi√ß√£o. Caso a Resposta seja a esperada, o teste Passa, caso n√£o seja a Resposta esperada, o teste Falha. <br />**Exemplo:** Ao persistir um Objeto no Banco de dados, espera-se que o **HTTP Status da Resposta** da Requisi√ß√£o seja **201 ü°™ CREATED**. O teste s√≥ vai Passar se esta for a resposta obtida. |
| **then()**    | Permite analisar o **Corpo da Resposta** (Request Body) do teste. Para analisarmos o conte√∫do do Corpo da Resposta utilizaremos o M√©todo **expect()**, mas n√£o do SuperTest e sim o **M√©todo expect() do Jest**. |

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="150px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao escrever os testes da aplica√ß√£o. N√£o confunda o M√©todo expect() do Framework Jest com o M√©todo expect() da Biblioteca SuperTest.. Embora a escrita seja a mesma, os M√©todos possuem fun√ß√µes diferentes.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |


<h2>5. Quais testes faremos?</h2>

Vamos criar testes nos M√≥dulos **Usuario e Auth** do Projeto Blog Pessoal, atrav√©s de Requisi√ß√µes HTTP, semelhantes as que j√° foram feitas no Insomnia, por√©m automatizadas atrav√©s do Jest e do SuperTest.
Para executarmos os testes, faremos algumas configura√ß√µes na pasta <b>test</b>, localizada na raiz do projeto, no arquivo <b>app.e2e-spec.ts</b> e faremos a instala√ß√£o da Biblioteca **SuperTest**.
Antes de prosseguir, assegure que o seu projeto Blog Pessoal n√£o esteja em execu√ß√£o no VSCode e principalmente que **o c√≥digo da sua aplica√ß√£o esteja com os 4 M√≥dulos 100% funcionais e sem erros!**

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>

