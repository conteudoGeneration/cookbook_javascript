<h1>Introdu√ß√£o ao Teste de Software com Jest</h1>



<br />

O teste de software √© uma forma de avaliar a qualidade da aplica√ß√£o e reduzir os riscos de falhas no c√≥digo ao ser colocado  em opera√ß√£o (Produ√ß√£o). Testar n√£o se resume apenas em executar testes e verificar os resultados. **Executar** testes √© apenas uma das atividades. Planejamento, an√°lise, modelagem e implementa√ß√£o dos testes,  relat√≥rios de progresso, resultado e avalia√ß√£o da qualidade, tamb√©m s√£o  partes de um **processo de testes**.
Testar software n√£o √© somente **verificar** se os requisitos foram atendidos, atribui-se ao teste de software tamb√©m a **valida√ß√£o**, ou  seja, verificar se o sistema atender√° √†s necessidades do usu√°rio e de outras partes interessadas em seu(s) ambiente(s) operacional(is).

<br />

<h2>1. A Pir√¢mide de Testes</h2>



A **Pir√¢mide de Testes** √© uma representa√ß√£o gr√°fica que orienta a distribui√ß√£o dos testes de software em diferentes n√≠veis. Ela sugere a quantidade ideal de testes para cada tipo, destacando tamb√©m seus respectivos custos e tempos de execu√ß√£o ‚Äî quanto mais pr√≥ximo da base, mais r√°pidos e baratos os testes tendem a ser.

<div align="center"><img src="https://i.imgur.com/Od62OuJ.png" title="source: imgur.com" width="75%"/></div>

Observe que os testes na base s√£o mais r√°pidos e baratos do que os testes no topo da pir√¢mide.

De acordo com a **Pir√¢mide de Testes**, existem tr√™s tipos de teste:

- Teste de Unidade
- Teste de Integra√ß√£o
- Teste End to End (E2E)

<br />

<h3>1.1. Teste de unidade</h3>



O **teste de unidade** √© uma t√©cnica de verifica√ß√£o que consiste em testar partes individuais e isoladas de um sistema, geralmente fun√ß√µes ou m√©todos. Essas **unidades** podem ser m√©todos, classes, pacotes ou componentes menores de um subsistema.

O objetivo principal √© garantir que cada unidade de c√≥digo **funcione de forma correta e independente**, conforme o comportamento esperado.

Por se concentrar em blocos pequenos de c√≥digo, o teste de unidade √©:

- **R√°pido**, pois n√£o depende de servi√ßos externos ou banco de dados;
- **Barato**, porque pode ser escrito e executado diretamente pela pessoa desenvolvedora durante a codifica√ß√£o;
- **Determin√≠stico**, ou seja, fornece os mesmos resultados sob as mesmas condi√ß√µes.

Devido a essas caracter√≠sticas, os testes de unidade est√£o na base da **Pir√¢mide de Testes** e s√£o considerados o tipo de teste mais frequente e fundamental no processo de desenvolvimento orientado a testes (**TDD**).

**Exemplos de Testes Unit√°rios:**

- **Fun√ß√£o matem√°tica simples:** Testar uma fun√ß√£o que calcula a m√©dia entre dois n√∫meros. O teste verifica se, ao receber os valores 8 e 6, o resultado retornado √© 7.
- **Valida√ß√£o de senha:** Testar uma fun√ß√£o que verifica se a senha digitada atende aos crit√©rios de seguran√ßa, como ter pelo menos 8 caracteres e conter n√∫meros. O teste avalia se a entrada "12345678" √© considerada v√°lida.
- **Convers√£o de temperatura:** Testar um m√©todo que converte Celsius para Fahrenheit. O teste valida se, ao informar 0¬∞C, o retorno √© 32¬∞F.
- **C√°lculo de desconto em um produto:** Testar a l√≥gica de c√°lculo de desconto em um item de um carrinho de compras. Por exemplo, um produto de R$ 100,00 com 10% de desconto deve retornar R$ 90,00.
- **Formata√ß√£o de CPF:** Testar uma fun√ß√£o que recebe um CPF num√©rico (12345678900) e retorna o CPF formatado ("123.456.789-00").
- **Gera√ß√£o de sauda√ß√£o personalizada:** Testar se a fun√ß√£o que gera mensagens retorna "Bom dia, Jo√£o!" ao receber o nome "Jo√£o" e a hora 9h da manh√£.

<br />

<h3>1.2. Teste de Integra√ß√£o</h3>



O **Teste de Integra√ß√£o** √© uma etapa fundamental no processo de testes de software que tem como objetivo verificar a **intera√ß√£o entre dois ou mais m√≥dulos do sistema**. Diferente do teste de unidade, que avalia partes isoladas do c√≥digo, o teste de integra√ß√£o foca em **como os componentes trabalham juntos** e se essa integra√ß√£o mant√©m o comportamento esperado do sistema.

Segundo o ISTQB Glossary, o Teste de Integra√ß√£o √© definido como:

> "Um n√≠vel de teste no qual unidades s√£o combinadas e testadas em conjunto para avaliar se as interfaces entre elas se comportam conforme especificado."
>
> *O **ISTQB** (International Software Testing Qualifications Board) √© uma organiza√ß√£o internacional sem fins lucrativos respons√°vel por definir um **padr√£o global de certifica√ß√µes em teste de software**.*

Mesmo que cada m√≥dulo funcione corretamente de forma isolada, **falhas podem surgir quando esses m√≥dulos interagem**. Isso pode ocorrer por diverg√™ncia em formatos de dados, contratos de APIs, erros de comunica√ß√£o entre classes, ou regras de neg√≥cio mal implementadas em conjunto. 

Para uma melhor compreens√£o, vamos analisar a situa√ß√£o abaixo:

Imagine que voc√™ testou separadamente:

- Uma **fechadura** que responde corretamente ao comando de travar;
- Uma **porta** que pode ser trancada se receber esse comando.

No entanto, ao integrar os dois, percebe-se que a fechadura foi feita apenas para portas de giro, e a porta em quest√£o √© de correr. **Ambos funcionam individualmente**, mas n√£o s√£o compat√≠veis quando combinados ‚Äî evidenciando a import√¢ncia do Teste de Integra√ß√£o, como vemos na anima√ß√£o abaixo:

<div align="center"><img src="https://i.imgur.com/sjACFFr.gif" title="source: imgur.com" /></div>

<br />

- Os **Testes de Integra√ß√£o** apresentam caracter√≠sticas distintas quando comparados aos **Testes Unit√°rios**:
  - **Mais complexos**: envolvem a intera√ß√£o entre dois ou mais componentes do sistema, o que aumenta o n√≠vel de depend√™ncia e l√≥gica conjunta a ser verificada.
  - **Mais lentos**: muitas vezes dependem de recursos externos, como banco de dados, APIs, arquivos ou servi√ßos, o que aumenta o tempo de execu√ß√£o.
  - **Mais custosos**: exigem um ambiente de testes mais robusto e, em alguns casos, o uso de mocks, containers ou dados reais, elevando o esfor√ßo de configura√ß√£o e manuten√ß√£o.

**Exemplos de Testes de Integra√ß√£o:**

1. **Autentica√ß√£o e acesso a dados:** Verificar se, ao fazer login com usu√°rio e senha v√°lidos, o sistema acessa corretamente o banco de dados e retorna os dados do usu√°rio.
2. **Cadastro com envio de e-mail:** Testar se, ao cadastrar um novo cliente, o sistema salva os dados no banco e envia um e-mail de confirma√ß√£o com sucesso.
3. **Fluxo de compra em e-commerce:** Validar se, ao adicionar um produto ao carrinho e finalizar a compra, o sistema calcula corretamente os valores, atualiza o estoque e gera o pedido.
4. **Consulta via API externa:** Testar a integra√ß√£o com um servi√ßo externo de CEP para garantir que o endere√ßo seja preenchido corretamente ao digitar o n√∫mero do CEP.
5. **Cria√ß√£o de usu√°rio com valida√ß√£o de CPF:** Verificar se, ao criar um novo usu√°rio, o sistema consulta um servi√ßo interno para validar o CPF e, caso esteja v√°lido, persiste os dados.

<br />

<h3>1.3. Teste End to End</h3>



O **Teste End-to-End (E2E)** √© uma metodologia de teste de software que tem como objetivo verificar o **funcionamento completo de um sistema**, simulando o comportamento real de um usu√°rio, desde o in√≠cio at√© o fim de um fluxo funcional. Esse tipo de teste valida a **comunica√ß√£o entre os diferentes componentes, camadas e servi√ßos da aplica√ß√£o**, garantindo que todas as partes estejam corretamente integradas e operem como esperado em um cen√°rio real.

De acordo com a documenta√ß√£o oficial do Cypress, testes E2E:

> ‚Äú...testam todo o sistema como um todo, do ponto de vista do usu√°rio, garantindo que os fluxos principais funcionem corretamente.‚Äù
>
> *O **Cypress** √© uma ferramenta moderna de automa√ß√£o de testes focada em **testes end-to-end (E2E)** para aplica√ß√µes **web**.*

Esses testes s√£o essenciais para validar:

- A **experi√™ncia do usu√°rio**;
- A **integra√ß√£o entre sistemas e servi√ßos**;
- A **confiabilidade dos dados ao longo de um processo completo**, como uma compra ou autentica√ß√£o.

Os testes E2E costumam ser:

- **Mais lentos**: envolvem m√∫ltiplas camadas (back-end, banco de dados, servi√ßos externos e at√© mesmo o front-end e/ou app mobile), o que exige mais tempo para execu√ß√£o.
- **Mais caros**: requerem ambientes de teste realistas, dados simulados, automa√ß√µes ou at√© mesmo testadores humanos.
- **Mais complexos**: verificam o sistema de forma hol√≠stica, o que aumenta o n√∫mero de vari√°veis e a possibilidade de falhas externas.

Por esses motivos, s√£o utilizados em menor escala, priorizando os fluxos **mais cr√≠ticos da aplica√ß√£o**, como login, pagamento, cadastro ou finaliza√ß√£o de pedidos.

**Exemplos de testes E2E:**

1. **Autentica√ß√£o completa:** Simular o login de um usu√°rio, validando o acesso a endpoints restritos com base mas permiss√µes do usu√°rio.
2. **Finaliza√ß√£o de compra em e-commerce:** Realizar todo o processo de compra: adicionar itens ao carrinho, informar dados de entrega, escolher o meio de pagamento e receber a confirma√ß√£o do pedido.
3. **Cadastro de usu√°rio e confirma√ß√£o por e-mail:** Preencher os dados do usu√°rio, submeter os dados, verificar a chegada do e-mail de confirma√ß√£o e validar a ativa√ß√£o da conta.
4. **Simula√ß√£o de agendamento:** Agendar um servi√ßo em um sistema de reservas, verificar se os hor√°rios dispon√≠veis s√£o atualizados e se o agendamento aparece na agenda.
5. **Preenchimento de formul√°rio com m√∫ltiplas etapas (front-end):** Completar um formul√°rio dividido em v√°rias telas (exemplo: cadastro de curr√≠culo), garantindo que os dados sejam salvos corretamente em cada etapa.

<br />

<h3>1.4. O que deve ser testado?</h3>



Ao planejar os testes de software, a prioridade deve ser dada √†s **partes mais cr√≠ticas, complexas ou sens√≠veis da aplica√ß√£o**, ou seja, aquelas que impactam diretamente o funcionamento, a seguran√ßa ou a experi√™ncia do usu√°rio final.

Esses pontos geralmente incluem:

- **Regras de neg√≥cio essenciais** (ex: c√°lculo de desconto, valida√ß√£o de CPF);
- **Funcionalidades que envolvem transa√ß√µes** (ex: pagamento, envio de pedido);
- **Integra√ß√µes com sistemas externos** (ex: gateways de pagamento, APIs de terceiros);
- **Fluxos principais da aplica√ß√£o** (ex: login, cadastro, finaliza√ß√£o de compra);
- **√Åreas com alta probabilidade de falha ou alta frequ√™ncia de uso**.

Focar os testes nesses pontos **reduz riscos em produ√ß√£o**, melhora a estabilidade do sistema e ajuda a detectar falhas antes que impactem os usu√°rios.

> üí° **Exemplo pr√°tico:**
>  Em um e-commerce, a **finaliza√ß√£o da compra** √© um fluxo essencial. Se houver qualquer falha nesse processo (exemplo: erro no c√°lculo do valor final, falha no pagamento ou n√£o gera√ß√£o do pedido), isso afeta diretamente o cliente e gera preju√≠zo ao neg√≥cio. Por isso, esse √© um dos primeiros pontos que deve ser testado.

<br />

**O que n√£o vale a pena testar?**

Alguns trechos de c√≥digo s√£o t√£o simples, triviais ou irrelevantes para a l√≥gica do sistema que o esfor√ßo de test√°-los n√£o se justifica. Isso se aplica principalmente a:

- **Getters e setters autom√°ticos** (sem l√≥gica interna);
- **C√≥digos gerados automaticamente por frameworks**;
- **Estiliza√ß√£o ou layout est√°tico em componentes front-end** (quando n√£o afetam a l√≥gica ou a experi√™ncia do usu√°rio).

> ‚ùå **Exemplo de teste irrelevante:**
> Testar se um m√©todo `getNome()` simplesmente retorna o valor de uma vari√°vel `nome` **sem nenhuma l√≥gica adicional**. Esse tipo de teste n√£o traz ganho real e apenas aumenta o volume de testes sem valor agregado.

<br />

<h2>2. NestJS Testing</h2>



O **NestJS Testing** √© parte integrante do Nest e oferece suporte a testes de unidade, integra√ß√£o e E2E, utilizando o  Framework de Testes JavaScript **Jest**. 
Ao criar um projeto com o Nest, automaticamente os pacotes de teste j√° s√£o inseridos no projeto como veremos adiante.

<br />

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="25px"/> <a href="https://docs.nestjs.com/fundamentals/testing" target="_blank"><b>Documenta√ß√£o:  NestJS Testing</b></a></div>

<br />


<h3>2.1. NestJS Testing - Classes principais</h3>



<table width=100%>
	<tr>
        <td width=15%><b>Classes</b></td>
		<td width=70%><b>Descri√ß√£o</td>
	</tr>
	<tr>
        <td><i>Test</i></td>
        <td><p align="justify">A classe Test cria o ambiente para escrever e executar os testes com o Jest. A classe Test possui o M√©todo <b>createTestingModule()</b>, que inicializa um M√≥dulo de Testes atrav√©s de um Objeto do M√≥dulo da aplica√ß√£o (AppModule) ou um array contendo um Objeto de cada M√≥dulo que ser√° testado. Esse M√©todo tamb√©m recebe as configura√ß√µes do Banco de dados de teste.</td>
	</tr>
    <tr>
        <td><i>TestingModule</i></td>
        <td><p align="justify">Fornece alguns m√©todos para testes de unidade. O M√©todo mais  importante √© o m√©todo <b>compile()</b>. Esse m√©todo inicializa o M√≥dulo com suas depend√™ncias (semelhante √† maneira como um aplicativo √© inicializado no arquivo <b>main.ts</b> convencional usando o M√©todo <b>NestFactory.create()</b>) e retorna um m√≥dulo que est√° pronto para teste.</td>
	</tr>
</table>
<br />

<h2>3. O framework Jest</h2>



O Jest √© um Framework de testes de c√≥digo aberto para a linguagem JavaScript, que √© usado para escrever e executar testes automatizados e repetitivos, para que possamos ter certeza que nosso c√≥digo funciona conforme o esperado. O Jest √© um Framework com foco na simplicidade. Funciona com projetos usando: Nest, TypeScript, Node, React, Angular, Vue e muito mais!

Jest √© uma estrutura de teste JavaScript projetada para garantir a exatid√£o de qualquer base de c√≥digo JavaScript. Ele permite que voc√™ escreva testes com uma API acess√≠vel, familiar e rica em recursos que fornece resultados rapidamente. O Jest est√° bem documentado, requer pouca configura√ß√£o e pode ser estendido para atender √†s suas necessidades.

O Jest fornece:

- Testes Instant√¢neos que validam Objetos grandes com facilidade. 
- Testes paralelizados, executando-os em seus pr√≥prios processos para maximizar o desempenho. 
- Um kit de ferramentas de teste em um s√≥ lugar, amplamente documentado.

O Jest √© usado para testar:

* Um objeto inteiro
* Parte de um objeto, como um m√©todo ou alguns m√©todos de intera√ß√£o
* Intera√ß√£o entre v√°rios objetos 
* Um M√≥dulo inteiro

<br />

<div align="left"><img src="https://i.imgur.com/3tsv1lE.png" title="source: imgur.com" width="30px"/> <a href="https://jestjs.io/pt-BR/docs/api" target="_blank"><b>Documenta√ß√£o: Jest</b></a></div>

<br />

<h3>3.1. Principais M√©todos do Jest</h3>



<table width=100%>
	<tr>
        <td width=15%><b>M√©todos</b></td>
		<td width=70%><b>Descri√ß√£o</td>
	</tr>
	<tr>
		<td><i>describe</i></td>
        <td>Podemos definir o describe como uma suite de testes, ou seja, um describe pode ter um conjunto de testes. Dentro dos describes podemos ainda colocar outros describes com outros conjuntos de testes<br /><b>Exemplo:</b> Testes do M√≥dulo Usuario e Auth.</td>
	</tr>
    <tr>
		<td><i>it</i></td>
        <td>S√£o os nossos testes, cada it √© um teste, logo os describes aglomeram um conjunto de its.</td>
	</tr>
	<tr>
		<td><i>beforeEach</i></td>
        <td>Executa um conjunto de a√ß√µes antes de cada teste ser iniciado, para criar as pr√©-condi√ß√µes necess√°rias para cada teste (criar Objetos, vari√°veis, entre outros).</td>
	</tr>
	<tr>
		<td><i>beforeAll</i></td>
        <td>Executa  um conjunto de a√ß√µes, apenas uma vez, antes de iniciar a s√©rie de testes, para criar as pr√©-condi√ß√µes necess√°rias para todos os testes (criar Objetos, vari√°veis, entre outros).</td>
	</tr>
	<tr>
		<td><i>afterEach</i></td>
        <td>Executa um conjunto de a√ß√µes depois de cada teste ser finalizado, para redefinir algumas condi√ß√µes ap√≥s a execu√ß√£o de cada teste (limpar o Banco de dados, redefinir Objetos e Vari√°veis, entre outros).</td>
	</tr>
	<tr>
		<td><i>afterAll</i></td>
        <td>Executa  um conjunto de a√ß√µes, apenas uma vez, depois de todos os testes serem finalizados, para redefinir algumas condi√ß√µes ap√≥s a execu√ß√£o de todos os testes (limpar o Banco de dados, redefinir Objetos e Vari√°veis, entre outros).</td>
	</tr>
	<tr>
		<td><i>test.skip</i></td>
		<td>Desabilita temporariamente a execu√ß√£o de um teste espec√≠fico. Cada teste criado com o M√©todo test.skip n√£o ser√°  executado.</td>
	</tr>
	<tr>
		<td><i>test.only</i></td>
        <td>Desabilita temporariamente a execu√ß√£o de todos os testes, exceto o teste criado com o M√©todo test.only.</td>
	</tr>
</table>
<br />

<h3>3.2. M√©todo expect() do Jest</h3>



O **M√©todo expect() do Jest** permite checar se os valores satisfazem certas condi√ß√µes, al√©m de lhe dar acesso a in√∫meros "matchers" (M√©todos para testar valores), que permitem validar diferentes coisas, atrav√©s de asser√ß√µes (afirma√ß√µes). **Exemplo:** 1+1 √© igual 2

Veja alguns exemplos abaixo:

| M√©todo                                     | Descri√ß√£o                                           |
| ------------------------------------------ | --------------------------------------------------- |
| **expect(soma).toBe(2);**                  | Afirma que a vari√°vel soma √© igual a 2.             |
| **expect(soma).not.toBe(0);**              | Afirma que a vari√°vel soma n√£o √© igual a 0.         |
| **expect(nome).toEqual('Jo√£o da Silva');** | Afirma que a vari√°vel nome √© igual a Jo√£o da Silva. |
| **expect(foto).toBeNull();**               | Afirma que a vari√°vel foto n√£o √© nula.              |

<br />

<div align="left"><img src="https://i.imgur.com/3tsv1lE.png" title="source: imgur.com" width="30px"/> <a href="https://jestjs.io/pt-BR/docs/expect" target="_blank"><b>Documenta√ß√£o: M√©todo Expect - Jest</b></a></div>

<br />

<h2>4. Biblioteca SuperTest</h2>



**SuperTest** √© uma Biblioteca Node.js que ajuda as pessoas desenvolvedoras a testar API's. Ela estende outra Biblioteca chamada **SuperAgent** (um cliente HTTP JavaScript para Node.js, semelhante ao Insomnia e o Postman, mas sem Interface Gr√°fica), que complementa o Framework Jest, oferecendo M√©todos para testar Requisi√ß√µes HTTP de forma simples e r√°pida. 

<br />

<div align="left"><img src="https://i.imgur.com/kuK7aM3.png" title="source: imgur.com" width="35px"/> <a href="https://github.com/visionmedia/supertest#readme" target="_blank"><b>Documenta√ß√£o: Supertest</b></a></div>

<br />

<h3>4.1. M√©todos da Biblioteca SuperTest</h3>



| M√©todo        | Descri√ß√£o                                                    |
| ------------- | ------------------------------------------------------------ |
| **request()** | Cria uma nova Requisi√ß√£o. Este m√©todo recebe como par√¢metro o Ambiente de Testes que foi criado pelas Classes **Test e TestingModule** e inicializada pelo M√©todo **init()** do Nest. |
| **get()**     | Define que a Requisi√ß√£o ser√° do tipo **HTTP GET**. Este M√©todo recebe como par√¢metro o endere√ßo do endpoint. |
| **post()**    | Define que a Requisi√ß√£o ser√° do tipo **HTTP POST**. Este M√©todo recebe como par√¢metro o endere√ßo do endpoint. |
| **put()**     | Define que a Requisi√ß√£o ser√° do tipo **HTTP PUT**. Este M√©todo recebe como par√¢metro o endere√ßo do endpoint. |
| **delete()**  | Define que a Requisi√ß√£o ser√° do tipo **HTTP DELETE**. Este M√©todo recebe como par√¢metro o endere√ßo do endpoint. |
| **set()**     | Permite enviar dados atrav√©s do **Cabe√ßalho (Header)** da Requisi√ß√£o. Um uso muito comum √© enviar o **Token JWT** nas Requisi√ß√µes cujo o endpoint est√° protegido. |
| **expect()**  | Define a Resposta HTTP (Status), que se espera da requisi√ß√£o. Caso a Resposta seja a esperada, o teste Passa, caso n√£o seja a Resposta esperada, o teste Falha. <br />**Exemplo:** Ao persistir um Objeto no Banco de dados, espera-se que o **HTTP Status da Resposta** da Requisi√ß√£o seja **201 ü°™ CREATED**. O teste s√≥ vai Passar se esta for a resposta obtida. |
| **then()**    | Permite analisar o **Corpo da Resposta** (Request Body) do teste. Para analisarmos o conte√∫do do Corpo da Resposta utilizaremos o M√©todo **expect()**, mas n√£o do SuperTest e sim o **M√©todo expect() do Jest**. |

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="150px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao escrever os testes da aplica√ß√£o. N√£o confunda o M√©todo expect() do Framework Jest com o M√©todo expect() da Biblioteca SuperTest.. Embora a escrita seja a mesma, os M√©todos possuem fun√ß√µes diferentes.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h2>5. Banco de dados SQLite</h2>



Para n√£o alterar os dados do Banco de dados principal da aplica√ß√£o, vamos utilizar o Banco de dados **SQLite** para executar os nossos testes.

O **SQLite** √© um **Banco de dados Relacional**, de c√≥digo aberto, que se diferencia de outras ferramentas do mesmo tipo, pelo fato de n√£o armazenar os dados em um servidor. Ele consegue manter os dados dentro de si pr√≥prio, atrav√©s da gera√ß√£o de um arquivo no HD do tipo **.db** ou virtualmente criando um banco de dados tempor√°rio na mem√≥ria do servidor, que se manter√° funcional enquanto a aplica√ß√£o estiver ativa. 

Essa independ√™ncia, torna o **SQLite** uma escolha popular para aplica√ß√µes mobile, especialmente no sistema Android, por n√£o requerer configura√ß√µes complexas, o que o torna f√°cil de usar e mais leve.

Como o **SQLite** √© uma op√ß√£o flex√≠vel e leve para armazenamento de dados, utilizaremos ele para gerar uma c√≥pia da estrutura do Banco de dados MySQL na mem√≥ria do servidor, que ficar√° ativo apenas durante a execu√ß√£o dos testes da aplica√ß√£o, atrav√©s do Jest.

<br />

<div align="left"><img src="https://i.imgur.com/WmToXZ1.png" title="source: imgur.com" width="35px"/> <a href="https://www.sqlite.org/docs.html" target="_blank"><b>Documenta√ß√£o: SQLite</b></a></div>

<br />

<h2>6. Quais testes faremos?</h2>



Vamos criar testes nos M√≥dulos **Usuario e Auth** do Projeto Blog Pessoal, atrav√©s de Requisi√ß√µes HTTP, semelhantes as que j√° foram feitas no Insomnia, por√©m automatizadas atrav√©s do Jest e do SuperTest.
Para executarmos os testes, faremos algumas configura√ß√µes na pasta <b>test</b>, localizada na raiz do projeto, no arquivo <b>app.e2e-spec.ts</b> e faremos a instala√ß√£o da Biblioteca **SuperTest**.
Antes de prosseguir, assegure que o seu projeto Blog Pessoal n√£o esteja em execu√ß√£o no VSCode e principalmente que **o c√≥digo da sua aplica√ß√£o esteja com os 4 M√≥dulos 100% funcionais e sem erros!**

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
