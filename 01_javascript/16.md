<h1>Programa√ß√£o Orientada a Objetos - Parte 02</h1>
<h2>Heran√ßa e Polimorfismo</h2>



Anteriormente, iniciamos nossos estudos sobre os conceitos iniciais da Programa√ß√£o Orientada a Objetos, tais como **Classes, Objetos, M√©todos, Atributos e Encapsulamento**. Neste material veremos outros 2 conceitos fundamentais: **Heran√ßa e Polimorfismo**. Antes, vamos entender o que √© Relacionamento entre Classes:

<br />

<h2>1. Relacionamento entre Classes</h2>



**Os Relacionamentos entre classes no TypeScript** definem os Relacionamentos especiais entre os diferentes tipos de classes.

No exemplo abaixo, existe uma rela√ß√£o especial entre uma classe chamada Ve√≠culo e uma classe chamada Carro: Um Carro √© um tipo de Ve√≠culo, como mostra a figura abaixo:

```mermaid
classDiagram
Veiculo <-- Carro: √© um tipo de
```

No pr√≥ximo exemplo, tamb√©m existe um tipo diferente de relacionamento entre as classes Carro, Motor e Roda. Um Carro √© compostos por Motor e Roda, como mostra a figura abaixo:

```mermaid
classDiagram
Carro *-- Motor : √© composto por
Carro *-- Roda : √© composto por
```

Quando projetamos um aplicativo, precisamos explorar os tipos de relacionamentos entre as classes, porque os relacionamentos nos ajudam de v√°rias maneiras.

Por exemplo, suponha que em um aplicativo, temos classes com comportamentos comuns (m√©todos), ent√£o podemos economizar esfor√ßo colocando os comportamentos comuns (m√©todos) dentro de uma √∫nica Classe, chamada de superclasse e na sequ√™ncia poderemos criar outras Classes que herdar√£o estes M√©todos em comum.

Ou ainda, Suponha que algumas classes n√£o estejam relacionadas entre si, ent√£o podemos atribuir diferentes programadores para implementar cada uma delas, sem nos preocuparmos que uma delas ter√° que esperar pela outra. 

Os relacionamentos entre as classes nos ajudam a entender como os objetos em um programa trabalham em conjunto e se comunicam entre si.

<br />

<h3>1.1. Tipos de relacionamento entre classes em TypeScript</h3>



Existem tr√™s tipos de relacionamentos mais comuns entre classes em TypeScript que s√£o os seguintes:

- Heran√ßa ("Is-A") - √â um
- Depend√™ncia (‚ÄúUse-A‚Äù) - Usa um
- Associa√ß√£o (‚ÄúHas-A‚Äù) - Tem um

A associa√ß√£o √© ainda classificada em 2 categorias:

- Agrega√ß√£o 

- Composi√ß√£o

Veja o resumo no Organograma abaixo:

<div align="center"><img src="https://i.imgur.com/UvL4z36.png" title="source: imgur.com" /></div>

<br />

<h4>1.1.1. Rela√ß√£o de Heran√ßa</h4>



A heran√ßa estabelece um relacionamento entre uma classe mais gen√©rica e abstrata (conhecida como superclasse) e uma classe mais especializada (conhecida como subclasse).

Em outras palavras, define o relacionamento entre duas classes em que uma classe "estende" outra classe, ou simplesmente cria um Relacionamento do tipo **√â-Um** (Is-A).

```mermaid
classDiagram
Pessoa <|-- Professor : √â uma
Pessoa <|-- Aluno : √â uma
```

<br />

<h4>1.1.2. Rela√ß√£o de Depend√™ncia</h4>



Quando criamos um objeto de uma classe dentro de um m√©todo de outra classe, esse relacionamento √© chamado **de relacionamento de depend√™ncia em TypeScript**, ou simplesmente relacionamento **Usa-Um** (Use-A).

Em outras palavras, quando um m√©todo de uma classe usa um objeto de outra classe, ele √© chamado de depend√™ncia em TypeScript. √â o relacionamento mais √≥bvio e mais geral em java.

```mermaid
classDiagram
Produto <.. Carrinho : Depende de
```

No Diagrama acima, em um aplicativo de com√©rcio eletr√¥nico, a classe Carrinho depende da classe Produto porque a classe Carrinho usa a classe Produto como par√¢metro para uma opera√ß√£o de adi√ß√£o de itens. 

Esse tipo de Relacionamento deve ser evitado devido ao alto grau de acoplamento gerado pela depend√™ncia.

<br />

<h4>1.1.3. Relacionamento de Associa√ß√£o</h4>



A associa√ß√£o √© outro tipo de relacionamento fundamental entre classes, que √© informalmente conhecido como relacionamento ‚Äú**Tem-Um**‚Äù (Has-A).

Quando um objeto de uma classe √© criado como Atributo de uma outra classe, ele √© chamado **de relacionamento de associa√ß√£o** ou simplesmente um Relacionamento do tipo Tem-Um.

```mermaid
classDiagram
Aluno <-- Professor : Tem um ou mais
```

Neste tipo de relacionamento √© importante definir tamb√©m as cardinalidades, ou seja, o numero de Objetos que podem se relacionar com outros Objetos. Existem basicamente 3 tipos de cardinalidades:

- **One to One:** Um Objeto tem rela√ß√£o com apenas Nenhum ou Um Objeto;
- **One to Many / Many to One:** Um Objeto tem rela√ß√£o com Nenhum, Um ou Mais Objetos;
- **Many to Many:** Muitos Objetos tem rela√ß√£o com Muitos Objetos.

Existem dois tipos de relacionamento de Associa√ß√£o especiais, que s√£o os seguintes:

- Agrega√ß√£o
- Composi√ß√£o

**Agrega√ß√£o:** Uma agrega√ß√£o √© uma forma especial de associa√ß√£o que representa um relacionamento de propriedade entre dois objetos, ou seja, dois objetos agregados t√™m seus pr√≥prios ciclos de vida, mas um dos objetos √© o propriet√°rio do relacionamento Tem-Um. 

O objeto propriet√°rio √© chamado de objeto agregador e sua classe √© chamada de classe agregadora. A classe agregadora tem uma refer√™ncia a outra classe e √© a propriet√°ria dessa classe. Ter seu pr√≥prio relacionamento significa que destruir um objeto n√£o afetar√° outro objeto.

```mermaid
classDiagram
Departamento o-- Professor : cont√©m
```

No exemplo acima, um Objeto Departamento cont√©m diversos Objetos Professor e ele √© o propriet√°rio do Relacionamento. Os Objetos Professor continuam existindo mesmo que o Objeto Departamento seja destru√≠do.

As *palavras chaves* usadas para identificar uma agrega√ß√£o s√£o: *"consiste em", "cont√©m", "√© parte de"*.

**Composi√ß√£o :** Uma composi√ß√£o √© uma forma especial e mais restritiva de agrega√ß√£o. Ele tamb√©m representa o relacionamento Tem-Um em que um objeto n√£o pode existir por conta pr√≥pria. O ‚Äútodo‚Äù √© realmente dependente da ‚Äúparte‚Äù.

Em outras palavras, dois objetos compostos n√£o podem ter seu pr√≥prio ciclo de vida. Ou seja, um objeto composto n√£o pode existir por conta pr√≥pria. Se um objeto composto for destru√≠do, todas as suas partes tamb√©m ser√£o exclu√≠das. Veja o exemplo abaixo:

```mermaid
classDiagram
Universidade *-- Departamento : √© composta por
```

Por exemplo, uma Universidade √© composta por v√°rios Departamentos. Um Departamento √© parte de uma Universidade e n√£o pode existir sem a exist√™ncia da Universidade, assim como nenhum Departamento pode pertencer a duas Universidades diferentes. Se o Objeto Universidade for destru√≠do, todos os Objetos Departamentos ser√£o destru√≠dos automaticamente.

<h3>Como decidir que tipo de relacionamento precisamos?</h3>

Os relacionamentos mais importantes ou mais utilizados no dia a dia s√£o o relacionamento √â-Um (Heran√ßa) e o relacionamento Tem-Um (Associa√ß√£o). A melhor maneira de decidir que tipo de relacionamento devemos criar √© a seguinte:

1. Se o seu problema for definido com a frase: "*O Objeto A √© um tipo do Objeto B*", ent√£o voc√™ deve usar o relacionamento de Heran√ßa. **Exemplo:** "*Um cachorro √© um Pet*". N√£o podemos dizer ‚Äú*Um Cachorro tem um Pet*‚Äù, pois n√£o faz o menor sentido. Ent√£o, neste caso, vamos criar uma superclasse chamada Pet e uma subclasse derivada chamada Cachorro.

```mermaid
classDiagram
Pet <|-- Cachorro : √â um
```

2. Por outro lado, se o seu problema for definido com a frase: "*O Objeto A tem um Objeto B*", ent√£o voc√™ deve usar o relacionamento de Associa√ß√£o. **Exemplo:**  ‚Äú*Um Pet tem uma Ra√ßa*‚Äù. N√£o podemos dizer: ‚Äú*Um Pet √© uma Ra√ßa*‚Äù. Esta afirma√ß√£o n√£o faz o menor sentido. Ent√£o, neste caso, vamos criar uma associa√ß√£o entre a Classe chamada Pet e a Classe derivada chamada Cachorro.

```mermaid
classDiagram
Raca <-- Pet : Tem uma
```
<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="80px"/> | <p align="justify"> **IMPORTANTE:** Neste primeiro momento, iremos focar na Rela√ß√£o de Heran√ßa. </p> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h2>2. Heran√ßa</h2>



O que torna a Orienta√ß√£o a Objetos √∫nica √© o **conceito de heran√ßa**. **Heran√ßa** √© um mecanismo que permite que caracter√≠sticas comuns a diversas classes sejam fatoradas de uma classe base, ou **superclasse**, ou seja, permite uma Classe herdar todos os Atributos e M√©todos de outra Classe. 

<div align="center"><img src="https://i.imgur.com/2T7wxZN.png" title="source: imgur.com" /></div>

Analisando a imagem acima: 

- Considere **capacidade** como um atributo da **Classe Transporte**, que indica a quantidade de pessoas que o transporte em quest√£o pode transportar.
- Os atributos **numero de rodas** e **velocidade** (KM/h) como atributos da **Classe Terrestre**.
- Os atributos **cor, n√∫mero de portas, placa e marcha** como atributos da **Classe Autom√≥vel**.
- A imagem acima apresenta um exemplo de Heran√ßa, onde:
  - As **Classes Aqu√°tico, Terrestre e A√©reo** herdam a **Classe Transporte**.
  - A **Classe Barco** herda a **Classe Aqu√°tico**.
  - A **Classe Autom√≥vel** herda a **Classe Terrestre**.
  - A **Classe Avi√£o** herda a **Classe A√©reo**.

A heran√ßa √© uma forma de reutiliza√ß√£o de software em que novas classes s√£o criadas a partir das classes existentes, absorvendo todos os seus atributos e m√©todos, al√©m de adicionar novos recursos que as novas classes exigem. A partir de uma **classe base**, outras classes podem ser especificadas e cada classe derivada ou **subclasse** apresenta as caracter√≠sticas (estrutura e m√©todos) da **superclasse**, al√©m de acrescentar o que for definido como particularidade da subclasse. Cada **subclasse** tamb√©m se torna uma candidata a ser uma **superclasse** para alguma subclasse futura

Observando o exemplo acima:

- A **Classe Transporte** possui um **atributo chamado capacidade**.
- Como a **Classe Aqu√°tico** herda a **Classe Transporte**, pode-se dizer que ela tamb√©m possui o **atributo capacidade**.
- A **Classe Barco**, como herda a **Classe Aqu√°tico**, tamb√©m possui o **atributo capacidade**.

Abaixo, vemos o Diagrama de Classes do exemplo acima:

<img src="https://i.imgur.com/vGDOChv.png" title="source: imgur.com" width="3%"/>**Exemplo 01 - Diagrama de Classes** 

```mermaid
classDiagram
class Transporte {
- capacidade: number  
}
class Aereo {
  
}
class Terrestre {
- numero de rodas: number  
- velocidade: number
}
class Aquatico {
  
}
class Aviao {
  
}
class Automovel {
- cor: string
- numero de portas: number
- placa: string
- marcha: number
}
class Barco {
  
}
Transporte <-- Aquatico
Transporte <-- Terrestre
Transporte <-- Aereo
Aquatico <-- Barco
Terrestre <-- Automovel
Aereo <-- Aviao
```

<br />

<h3>2.1. Tipos de Heran√ßa</h3>

Existem basicamente 2 tipos de heran√ßa:

- **Heran√ßa Simples:** Cada classe pode ter apenas uma superclasse. Na linguagem TypeScript usa-se a palavra reservada **extends** para declarar que uma classe √© herdeira de outra.
- **Heran√ßa M√∫ltipla:** √â a capacidade de uma classe possuir mais de uma superclasse e herdar os atributos e m√©todos
  de todas as superclasses. TypeScript n√£o implementa Heran√ßa M√∫ltipla nativamente, como a Linguagem C++, por exemplo. Para simular a heran√ßa m√∫ltipla em TypeScript, usa-se **Interfaces**, que veremos mais adiante.

<br />

<h3>2.2. Heran√ßa em TypeScript</h3>

**Sintaxe:**

```ts
export class nome_da_classe extends nome_da_superclasse{
    //Corpo da Classe
}
```

<br />

<h4>2.2.1 A palavra reservada extends</h4>



A palavra reservada **extends** - indica que uma Classe est√° sendo criada como uma heran√ßa (extens√£o) de uma classe existente.

A **Classe existente** √© a superclasse, classe base ou classe progenitora.

A **Nova classe** √© a subclasse, classe derivada ou classe filha.

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#extends-clauses" target="_blank"><b>Documenta√ß√£o: Palavra reservada extends</b></a></div>


<br />

<h3>2.3 O M√©todo Construtor da Subclasse</h3>



O M√©todo Construtor de uma Subclasse utiliza o M√©todo **super() que tem a fun√ß√£o de chamar o M√©todo Construtor da Superclasse**. Ele sempre √© chamado e deve ser o primeiro item dentro do M√©todo Construtor da Subclasse. 

No M√©todo super() devem ser passados como par√¢metros todos os Atributos da Superclasse. Os Atributos espec√≠ficos da Subclasse devem ser mantidos no M√©todo Construtor da Subclasse.

<br />

<h3>2.4 A palavra reservada super</h3>



Al√©m do M√©todo super(), existe tamb√©m a palavra reservada **super**, que faz refer√™ncia aos Objetos da Superclasse, semelhante a palavra reservada **this**, que faz refer√™ncia aos Objetos da pr√≥pria Classe.

A palavra reservada **super** e usada para chamar M√©todos da Superclasse. O uso mais comum da palavra reservada super √© eliminar a confus√£o entre superclasses e subclasses que possuem m√©todos com o mesmo nome.

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>Exemplo 01 - Implementa√ß√£o em TypeScript 

**Classe Transporte**

```ts
export class Transporte {

	private _capacidade: number;

	constructor(capacidade: number) {
		this._capacidade = capacidade;
	}

	public get capacidade() {
		return this._capacidade;
	}

	public set capacidade(capacidade: number) {
		this._capacidade = capacidade;
	}
	
	public visualizar(): void {
		
		console.log("\n\n************************************************************");
		console.log("Dados do Meio de Transporte:");
		console.log("****************************************************************");
		console.log("Capacidade (n√∫mero de passageiros): " + this._capacidade);
	}
}
```

A Classe Transporte (Superclasse), foi criada com apenas um Atributo (capacidade), conforme o Diagrama de Classes acima. Tamb√©m foi criado o M√©todo Construtor, os M√©todos Get e Set do Atributo e o M√©todo visualizar para exibir os dados do Objeto na tela.

**Classe Terrestre**


```ts
import { Transporte } from "./Transporte";

export class Terrestre extends Transporte {

	private _numeroRodas: number;
	private _velocidade: number;

	constructor(capacidade: number, numeroRodas: number, velocidade: number) {
		super(capacidade);
		this._numeroRodas = numeroRodas;
		this._velocidade = velocidade;
	}

	public get numeroRodas() {
		return this._numeroRodas;
	}

	public set numeroRodas(numeroRodas: number) {
		this._numeroRodas = numeroRodas;
	}

	public get velocidade() {
		return this._velocidade;
	}

	public set velocidade(velocidade: number) {
		this._velocidade = velocidade;
	}

	public visualizar(): void {
		super.visualizar();
		console.log("N√∫mero de rodas: " + this.numeroRodas);
		console.log("Velocidade: " + this.velocidade.toFixed(2));
	}
}

```

A Classe Terrestre (Subclasse), foi criada como Heran√ßa da Classe Transporte (**extends Transporte**), com dois Atributos (**numeroRodas** e **velocidade**), conforme o Diagrama de Classes acima. Al√©m disso, tamb√©m foram criados o M√©todo Construtor, os M√©todos Get e Set dos Atributos e o M√©todo visualizar para exibir os dados do Objeto na tela. 

Observe que:

- Nos par√¢metros do M√©todo Construtor foi adicionado o Atributo **capacidade**, da Classe Transporte. 
- No corpo do M√©todo Construtor foi adicionado o M√©todo **super** para acessar os Atributos da Classe Transporte (**super(capacidade)**). 
- No M√©todo visualizar foi adicionado o M√©todo **super** para executar o M√©todo **visualizar()** (**super.visualizar()**), da Classe Transporte, para listar os dados dos atributos da Classe Transporte.

**Classe Automovel**

```ts
import { Terrestre } from "./Terrestre";

export class Automovel extends Terrestre{

	private _cor: string;
	private _numeroPortas: number;
	private _placa: string;
	private _marcha: number;
	
	constructor(capacidade: number, numeroRodas: number, velocidade: number, cor: string, numeroPortas: number, placa: string, marcha: number) {
		super(capacidade, numeroRodas, velocidade);
		this._cor = cor;
		this._numeroPortas = numeroPortas;
		this._placa = placa;
		this._marcha = marcha;
	}

	public get cor() {
		return this._cor;
	}

	public set cor(cor: string) {
		this._cor = cor;
	}

	public get numeroPortas() {
		return this._numeroPortas;
	}

	public  set numeroPortas(numeroPortas: number) {
		this._numeroPortas = numeroPortas;
	}

	public get placa() {
		return this._placa;
	}

	public set placa(placa: string) {
		this._placa = placa;
	}
	
	public get marcha() {
		return this._marcha;
	}

	public set marcha(marcha: number) {
		this._marcha = marcha;
	}

	public visualizar(): void {

		super.visualizar();
		console.log("cor: " + this._cor);
		console.log("N√∫mero de portas: " + this._numeroPortas);
		console.log("Placa: " + this._placa);
		console.log("Marcha: " + this._marcha);
		
	}
}
```

A Classe Automovel (Subclasse), foi criada como Heran√ßa da Classe Terrestre (**extends Terrestre**), com os Atributos (**cor, numeroPortas, placa e marcha**), conforme o Diagrama de Classes acima. Al√©m disso, tamb√©m foram criados o M√©todo Construtor, os M√©todos Get e Set dos Atributos e o M√©todo visualizar para exibir os dados do Objeto na tela. 

Observe que:

- No M√©todo Construtor foram adicionados os Atributos **capacidade**, da Classe Transporte, e **numeroRodas**, da Classe Terrestre, nos par√¢metros do M√©todo. 
- No corpo do M√©todo Construtor foi adicionado o M√©todo **super** para acessar os Atributos da **Classe Terrestre** e da **Classe Transporte**, que foram herdados na Classe Terrestre (**super(capacidade, numeroRodas, velocidade)**). 
- No M√©todo visualizar tamb√©m foi adicionado o M√©todo **super** para executar o M√©todo **visualizar()** (**super.visualizar()**), da Classe Terrestre, para listar os dados dos atributos das Classes Terrestre e Transporte.

**Classe TestaTransporte**

```ts
import { Automovel } from "./Automovel";

export function main() {

    const aut1: Automovel = new Automovel(5, 4, 250.00, "Verde", 4, "EBN-0301", 0);

    aut1.visualizar();

}

main();
```

Na Classe TestaTransporte, foi instanciado uma Objeto da Classe Automovel. Observe que devido as Heran√ßas, o Objeto da Classe Automovel possui 7 par√¢metros: 

- capacidade (herdado da Classe Transporte)
- numeroRodas e velocidade (Herdado da Classe Terrestre)
- cor, numeroPortas, placa e marcha (Atributos da Classe Automovel)

Abaixo, voc√™ confere o resultado do c√≥digo no Console:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
*********************************************************************
Dados do Meio de Transporte:
*********************************************************************
Capacidade (n√∫mero de passageiros): 5
N√∫mero de rodas: 4
Velocidade: 250.00
cor: Verde
N√∫mero de portas: 4
Placa: EBN-0301
Marcha: 0
```

<br />


> **Dicas sobre Heran√ßa:**
>
> 1. Sempre coloque os m√©todos e atributos comuns para todas as Subclasses na **Superclasse**
> 2. Use heran√ßa para modelar uma rela√ß√£o de ‚Äúestar contido em‚Äù, ou seja, **um objeto da Subclasse √© um objeto da Superclasse**
> 3. N√£o use heran√ßa a menos que todos ou a maioria dos m√©todos herdados da Superclasse fa√ßam sentido na Subclasse

<br />

<h2>3. Polimorfismo</h2>



O **Poliformismo** deriva da palavra polimorfo, que significa multiforme, ou que pode variar a forma.

Para a POO, polimorfismo √© a habilidade de objetos de classes diferentes responderem a mesma mensagem de
diferentes maneiras, ou seja, v√°rias formas de responder √† mesma mensagem. O Polimorfismo √© a capacidade de um objeto decidir que m√©todo aplicar a si mesmo, embora a mensagem possa ser a mesma, os objetos podem responder diferentemente.

**Veja as imagens abaixo:**

Um dono de uma f√°brica de brinquedos solicitou que seus engenheiros criassem um mesmo controle remoto para todos
os brinquedos de sua f√°brica. A √∫nica restri√ß√£o era que cada brinquedo atendesse aos comandos espec√≠ficos definidos pelo controle.

<div align="center"><img src="https://i.imgur.com/NM8RVg5.png" title="source: imgur.com" /></div>

Assim quando o brinquedo recebe o sinal MOVER, ele se move de acordo com a sua fun√ß√£o:

- Para o avi√£o, mover significa VOAR;
- Para o barco significa NAVEGAR, e
- Para o autom√≥vel CORRER.

<div align="center"><img src="https://i.imgur.com/KnwNIwl.png" title="source: imgur.com" /></div>

Observe que os brinquedos respondem ao mesmo sinal  de formas diferentes. O Polimorfismo permite que diferentes objetos (avi√£o, barco, autom√≥vel) respondam uma mesma mensagem (mover) de formas diferentes (voar, navegar e correr).

<br />

<h3>3.1. Como funciona na pr√°tica?</h3>



- Ao enviar uma mensagem que pede para uma **subclasse** aplicar um **m√©todo** usando certos par√¢metros, a subclasse verifica se ela tem ou n√£o um m√©todo com esse nome e exatamente com os mesmos par√¢metros. 
- Se tiver, usa-o.
- Caso contr√°rio: a **superclasse** torna-se respons√°vel pelo processamento da mensagem e procura por um m√©todo com esse nome e esses par√¢metros. 
- Se encontrar, chama esse m√©todo.

<br />

<h3>3.2. Tipos de Polimorfismo</h3>

<br />

<h4>3.2.1. Polimorfismo de Sobreposi√ß√£o (Sobrescrita de M√©todo)</h4>



O ato de sobrescrever um m√©todo ou propriedade significa dar uma nova forma ao mesmo, uma nova vers√£o. Em TypeScript, a  **Sobrescrita de M√©todos** seria **criar um novo M√©todo na Classe filha contendo a mesma assinatura e o mesmo tipo de retorno do M√©todo Sobrescrito**. (Override). 

A **Sobrescrita** est√° diretamente relacionada √† Orienta√ß√£o a Objetos, mais especificamente com a Heran√ßa. Com a **Sobrescrita**, conseguimos especializar os **m√©todos** herdados das superclasses, alterando o seu comportamento nas subclasses por um comportamento mais espec√≠fico.

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>Exemplo 02: Polimorfismo de Sobrescrita

O M√©todo **visualizar()** da Classe Transporte, est√° implementado da seguinte forma:

```ts
	public visualizar(): void {
		
		console.log("\n\n************************************************************");
		console.log("Dados do Meio de Transporte:");
		console.log("****************************************************************");
		console.log("Capacidade (n√∫mero de passageiros): " + this._capacidade);
	}
```

O M√©todo **visualizar()** da Classe Terrestre, foi reescrito da seguinte forma:

```ts
	public visualizar(): void {
		super.visualizar();
		console.log("N√∫mero de rodas: " + this.numeroRodas);
		console.log("Velocidade: " + this.velocidade.toFixed(2));
	}
```

O M√©todo **visualizar()** da Classe Automovel, foi reescrito da seguinte forma:

```ts
	public visualizar(): void {

		super.visualizar();
		console.log("cor: " + this._cor);
		console.log("N√∫mero de portas: " + this._numeroPortas);
		console.log("Placa: " + this._placa);
		console.log("Marcha: " + this._marcha);
		
	}
```

Observe que as assinaturas dos 3 M√©todos s√£o as mesmas, entretanto o **M√©todo visualizar() das 3 Classes** possuem implementa√ß√µes diferentes, porqu√™ exibem os Atributos das Classes Herdadas e os seu pr√≥prios Atributos.

No exemplo acima, para que o M√©todo **visualizar()** funcione diferente nas **Classes Terrestre e Automovel**, ele precisou ser sobrescrito, porque as **Classes Terrestre e Automovel n√£o possuem acesso direto √†s vari√°veis de inst√¢ncia privadas da Superclasse**, ou seja, esse m√©todo n√£o pode alterar ou acessar diretamente a vari√°vel de inst√¢ncia. Por isso eles executam o M√©todo **super.visualizar()**, para receber os Atributos das Classes Herdadas.

Um ponto de aten√ß√£o importante em rela√ß√£o a sobrescrita √© que um **m√©todo redefinido em uma subclasse** com o **mesmo nome** e **mesma lista de par√¢metros** que o **m√©todo em uma de suas classes antecessoras**, automaticamente oculta o m√©todo da classe ancestral (superclasse) a partir da subclasse, ou seja, ele passa a usar o M√©todo da subclasse.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="80px"/> | <p align="justify"> **IMPORTANTE:** A Linguagem TypeScript n√£o oferece suporte ao Polimorfismo por Sobrecarga, ou seja, 2 m√©todos em uma mesma Classe, com o mesmo nome, mas com par√¢metros diferentes. </p> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="4%"/> <a href="https://github.com/rafaelq80/exemplos_js/tree/main/typescript/heranca" target="_blank"><b>C√≥digo fonte dos Exemplos</b></a></div>

<br />

------

## üîë**Pontos chave:**

1. **Os Relacionamentos entre classes no TypeScript** definem os Relacionamentos especiais entre os diferentes tipos de classes. 
2. A Heran√ßa √© um tipo de Relacionamento entre Classes no TypeScript e uma das maiores vantagens da Programa√ß√£o Orientada a Objetos, permitindo que o c√≥digo seja reutilizado. Em TypeScript, √© poss√≠vel herdar **atributos** e **comportamentos** (**m√©todos**) de uma classe para outra. 

3. **Heran√ßa Simples:** Cada classe pode ter apenas uma superclasse. Na linguagem TypeScript usa-se a palavra reservada **extends** para declarar que uma classe √© herdeira de outra.
4. **Heran√ßa M√∫ltipla:** √â a capacidade de uma classe possuir mais de uma superclasse e herdar os atributos e m√©todos de todas as superclasses. TypeScript n√£o implementa Heran√ßa M√∫ltipla nativamente.
5. O **Polimorfismo** √© considerado um dos recursos mais importantes da Programa√ß√£o Orientada a Objetos, permitindo que uma a√ß√£o seja executada de diferentes maneiras, fornecendo implementa√ß√µes variadas para m√©todos e interfaces. A palavra **polimorfismo** significa adquirir muitas formas ou assumir fun√ß√µes diferentes. 
6. **Polimorfismo de Sobreposi√ß√£o:** √â a redefini√ß√£o de m√©todos em classes descendentes, ou seja, um m√©todo de uma classe filha com o mesmo nome de um m√©todo de uma classe m√£e ir√° sobrepor esse √∫ltimo. O m√©todo redefinido tem preced√™ncia em rela√ß√£o a chamadas de m√©todo nos objetos da subclasse.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
