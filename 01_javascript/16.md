<h1>Programa√ß√£o Orientada a Objetos - Parte 02</h1>

<br />

<h2>Heran√ßa e Polimorfismo</h2>



Anteriormente, iniciamos nossos estudos sobre os conceitos iniciais da Programa√ß√£o Orientada a Objetos, tais como **Classes, Objetos, M√©todos, Atributos e Encapsulamento**. Neste material veremos outros 2 conceitos fundamentais: **Heran√ßa e Polimorfismo**. Antes, vamos entender o que √© Relacionamento entre Classes:

<br />

<h2>1. Relacionamento entre Classes</h2>



**Os Relacionamentos entre classes no TypeScript** definem os Relacionamentos especiais entre os diferentes tipos de classes.

No exemplo abaixo, existe uma rela√ß√£o especial entre uma classe chamada Ve√≠culo e uma classe chamada Carro: Um Carro √© um tipo de Ve√≠culo, como mostra a figura abaixo:

```mermaid
classDiagram
Veiculo <-- Carro: √© um tipo de
```

No pr√≥ximo exemplo, tamb√©m existe um tipo diferente de relacionamento entre as classes Carro, Motor e Roda. Um Carro √© compostos por Motor e Roda, como mostra a figura abaixo:

```mermaid
classDiagram
Carro *-- Motor : √© composto por
Carro *-- Roda : √© composto por
```

Ao projetar um aplicativo, √© essencial explorar os tipos de relacionamentos entre as classes, pois esses relacionamentos oferecem diversos benef√≠cios no desenvolvimento.

Por exemplo, considere um cen√°rio em que v√°rias classes possuem comportamentos comuns (m√©todos). Nesse caso, podemos otimizar o esfor√ßo ao centralizar esses comportamentos em uma √∫nica classe, chamada **superclasse**. Posteriormente, outras classes podem herdar esses m√©todos em comum, promovendo reutiliza√ß√£o de c√≥digo e maior organiza√ß√£o.

Al√©m disso, imagine que algumas classes n√£o possuem rela√ß√£o direta entre si. Nesse caso, √© poss√≠vel delegar sua implementa√ß√£o a diferentes programadores, sem a necessidade de interdepend√™ncia ou bloqueios no processo de desenvolvimento.

Compreender os relacionamentos entre as classes √© fundamental para entender como os objetos em um programa interagem e se comunicam, garantindo maior coes√£o e efici√™ncia no design do sistema.

<br />

<h3>1.1. Tipos de relacionamento entre classes em TypeScript</h3>



Existem tr√™s tipos de relacionamentos mais comuns entre classes em TypeScript que s√£o os seguintes:

- Heran√ßa ("Is-A") - √â um
- Depend√™ncia (‚ÄúUse-A‚Äù) - Usa um
- Associa√ß√£o (‚ÄúHas-A‚Äù) - Tem um

A associa√ß√£o √© ainda classificada em 2 categorias:

- Agrega√ß√£o 

- Composi√ß√£o

Veja o resumo no Organograma abaixo:

<div align="center"><img src="https://i.imgur.com/UvL4z36.png" title="source: imgur.com" /></div>

<br />

<h4>1.1.1. Rela√ß√£o de Heran√ßa</h4>



A heran√ßa estabelece um relacionamento entre uma classe mais gen√©rica e abstrata, conhecida como **superclasse**, e uma classe mais espec√≠fica e especializada, chamada de **subclasse**.

Em outras palavras, a heran√ßa define a rela√ß√£o entre duas classes em que uma classe "estende" outra, criando um relacionamento do tipo **√â-Um** (*Is-A*).

```mermaid
classDiagram
Pessoa <|-- Professor : √â uma
Pessoa <|-- Aluno : √â uma
```

<br />

<h4>1.1.2. Rela√ß√£o de Depend√™ncia</h4>



Quando criamos um objeto de uma classe dentro de um m√©todo de outra classe, esse relacionamento √© conhecido como **relacionamento de depend√™ncia em TypeScript**, ou simplesmente um relacionamento **Usa-Um** (*Use-A*).

Em outras palavras, quando um m√©todo de uma classe utiliza um objeto de outra classe, isso √© chamado de depend√™ncia em TypeScript.

```mermaid
classDiagram
Produto <.. Carrinho : Depende de
```

No diagrama acima, em um aplicativo de com√©rcio eletr√¥nico, a classe Carrinho depende da classe Produto, j√° que a classe Carrinho utiliza objetos da classe Produto como par√¢metro para a opera√ß√£o de adi√ß√£o de itens.

No entanto, esse tipo de relacionamento deve ser evitado sempre que poss√≠vel, pois gera um alto grau de acoplamento entre as classes, tornando o sistema menos flex√≠vel e mais dif√≠cil de manter.

<br />

<h4>1.1.3. Relacionamento de Associa√ß√£o</h4>



A **associa√ß√£o** √© outro tipo de relacionamento fundamental entre classes, conhecido informalmente como o relacionamento ‚Äú**Tem-Um**‚Äù (*Has-A*).

Esse relacionamento ocorre quando um objeto de uma classe √© criado como atributo de outra classe. Nesse caso, √© chamado de **relacionamento de associa√ß√£o**, ou simplesmente um relacionamento do tipo **Tem-Um**.

```mermaid
classDiagram
Aluno <-- Professor : Tem um ou mais
```

No contexto de associa√ß√£o, √© importante definir tamb√©m as **cardinalidades**, ou seja, o n√∫mero de objetos que podem se relacionar com outros objetos. As principais cardinalidades s√£o:

- **One-to-One (Um-para-Um):** Um objeto est√° relacionado com, no m√°ximo, um outro objeto.
- **One-to-Many / Many-to-One (Um-para-Muitos / Muitos-para-Um):** Um objeto est√° relacionado com nenhum, um ou v√°rios outros objetos, ou vice-versa.
- **Many-to-Many (Muitos-para-Muitos):** Muitos objetos podem se relacionar com muitos outros objetos.

Al√©m disso, existem dois tipos especiais de associa√ß√£o:

<br />

### **Agrega√ß√£o**

A **agrega√ß√£o** √© uma forma especial de associa√ß√£o que representa um relacionamento de propriedade entre dois objetos. Nesse caso, os objetos envolvidos t√™m seus pr√≥prios ciclos de vida, mas um deles √© o "propriet√°rio" do relacionamento **Tem-Um**.

O objeto propriet√°rio √© chamado de **objeto agregador**, e sua classe √© denominada **classe agregadora**. A classe agregadora cont√©m uma refer√™ncia √† outra classe, mas destruir um objeto agregador n√£o afeta o ciclo de vida do objeto associado.

```mermaid
classDiagram
Departamento o-- Professor : cont√©m
```

No exemplo acima, um objeto da classe **Departamento** cont√©m v√°rios objetos da classe **Professor** e atua como o propriet√°rio do relacionamento. No entanto, os objetos da classe **Professor** continuam a existir mesmo que o objeto da classe **Departamento** seja destru√≠do.

As **palavras-chave** que ajudam a identificar uma **agrega√ß√£o** s√£o: *"consiste em"*, *"cont√©m"*, *"√© parte de"*.

<br />

### **Composi√ß√£o**

A **composi√ß√£o** √© uma forma especial e mais restritiva de agrega√ß√£o. Ela tamb√©m representa o relacionamento **Tem-Um**, mas com uma depend√™ncia mais forte, na qual um objeto n√£o pode existir de forma independente. Nesse caso, o ‚Äútodo‚Äù √© intrinsecamente dependente das suas ‚Äúpartes‚Äù.

Em outras palavras, objetos em um relacionamento de composi√ß√£o compartilham o mesmo ciclo de vida. Se o objeto principal (o ‚Äútodo‚Äù) for destru√≠do, todas as suas partes relacionadas tamb√©m ser√£o eliminadas.

Por exemplo, considere um objeto da classe **Casa** que cont√©m objetos da classe **C√¥modo**. Se a **Casa** for destru√≠da, todos os seus **C√¥modos** deixar√£o de existir, pois n√£o podem existir independentemente da **Casa**. Veja um segundo exemplo abaixo:

```mermaid
classDiagram
Universidade *-- Departamento : √© composta por
```

Um Objeto da Classe Universidade √© composta por v√°rios Objetos da Classe Departamentos. Um Objeto  da Classe Departamento √© parte de um Objeto da Classe Universidade e n√£o pode existir sem a exist√™ncia do Objeto da Classe Universidade, assim como nenhum Objeto da Classe Departamento pode pertencer a dois Objetos da Classe Universidade simultaneamente. Se o Objeto da Classe Universidade for destru√≠do, todos os Objetos da Classe Departamento tamb√©m ser√£o destru√≠dos automaticamente.

<br />

<h3>Como decidir que tipo de relacionamento precisamos?</h3>



Os relacionamentos mais importantes e amplamente utilizados no dia a dia s√£o o relacionamento **√â-Um** (Heran√ßa) e o relacionamento **Tem-Um** (Associa√ß√£o). A decis√£o sobre qual tipo de relacionamento utilizar pode ser guiada por uma an√°lise simples:

1. **Relacionamento √â-Um (Heran√ßa):**

Se a defini√ß√£o do problema puder ser expressa na forma: *"O Objeto A √© um tipo do Objeto B"*, ent√£o o relacionamento de heran√ßa deve ser utilizado.

**Exemplo:**  *"Um cachorro √© um pet."*     

Nesse caso, faz sentido usar heran√ßa, pois n√£o seria l√≥gico dizer *"Um cachorro tem um pet."*. Assim, podemos criar uma superclasse gen√©rica chamada **Pet** e uma subclasse derivada chamada **Cachorro**.

```mermaid
classDiagram
Pet <|-- Cachorro : √â um
```

2. **Relacionamento √â-Um (Heran√ßa):**

Por outro lado, se a defini√ß√£o do problema puder ser expressa na forma: *"O Objeto A tem um Objeto B"*, ent√£o o relacionamento de associa√ß√£o deve ser utilizado.

**Exemplo:** *"Um pet tem uma ra√ßa."*

Nesse caso, seria incorreto dizer "Um pet √© uma ra√ßa", pois essa afirma√ß√£o n√£o faz sentido. Assim, devemos criar uma associa√ß√£o entre a classe Pet e uma classe que represente a Ra√ßa.

```mermaid
classDiagram
Raca <-- Pet : Tem uma
```

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="80px"/> | <p align="justify"> **IMPORTANTE:** Neste primeiro momento, iremos focar na Rela√ß√£o de Heran√ßa. </p> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h2>2. Heran√ßa</h2>



O que torna a Orienta√ß√£o a Objetos √∫nica √© o **conceito de Heran√ßa**. A **Heran√ßa** √© um mecanismo que permite abstrair caracter√≠sticas comuns de v√°rias classes em uma classe base, tamb√©m chamada de **superclasse**.

Com a heran√ßa, uma classe pode herdar todos os atributos e m√©todos de outra classe, promovendo reutiliza√ß√£o de c√≥digo e organiza√ß√£o. Esse conceito √© fundamental para modelar relacionamentos do tipo **√â-Um** e reduzir a redund√¢ncia no desenvolvimento de sistemas.

<div align="center"><img src="https://i.imgur.com/2T7wxZN.png" title="source: imgur.com" /></div>

Analisando a imagem acima: 

- Considere **capacidade** como um atributo da **Classe Transporte**, que indica a quantidade de pessoas que o transporte em quest√£o pode transportar.
- Os atributos **numero de rodas** e **velocidade** (KM/h) como atributos da **Classe Terrestre**.
- Os atributos **cor, n√∫mero de portas, placa e marcha** como atributos da **Classe Autom√≥vel**.
- A imagem acima apresenta um exemplo de Heran√ßa, onde:
  - As **Classes Aqu√°tico, Terrestre e A√©reo** herdam a **Classe Transporte**.
  - A **Classe Barco** herda a **Classe Aqu√°tico**.
  - A **Classe Autom√≥vel** herda a **Classe Terrestre**.
  - A **Classe Avi√£o** herda a **Classe A√©reo**.

A heran√ßa √© uma forma de reutiliza√ß√£o de software em que novas classes s√£o criadas a partir das classes existentes, absorvendo todos os seus atributos e m√©todos, al√©m de adicionar novos recursos que as novas classes exigem. A partir de uma **classe base**, outras classes podem ser especificadas e cada classe derivada ou **subclasse** apresenta as caracter√≠sticas (estrutura e m√©todos) da **superclasse**, al√©m de acrescentar o que for definido como particularidade da subclasse. Cada **subclasse** tamb√©m se torna uma candidata a ser uma **superclasse** para alguma subclasse futura

Observando o exemplo acima:

- A **Classe Transporte** possui um **atributo chamado capacidade**.
- Como a **Classe Aqu√°tico** herda a **Classe Transporte**, pode-se dizer que ela tamb√©m possui o **atributo capacidade**.
- A **Classe Barco**, como herda a **Classe Aqu√°tico**, tamb√©m possui o **atributo capacidade**.

Abaixo, vemos o Diagrama de Classes do exemplo acima:

<img src="https://i.imgur.com/vGDOChv.png" title="source: imgur.com" width="3%"/>**Exemplo 01 - Diagrama de Classes** 

```mermaid
classDiagram
class Transporte {
- capacidade: number  
}
class Aereo {
  
}
class Terrestre {
- numero de rodas: number  
- velocidade: number
}
class Aquatico {
  
}
class Aviao {
  
}
class Automovel {
- cor: string
- numero de portas: number
- placa: string
- marcha: number
}
class Barco {
  
}
Transporte <-- Aquatico
Transporte <-- Terrestre
Transporte <-- Aereo
Aquatico <-- Barco
Terrestre <-- Automovel
Aereo <-- Aviao
```

<br />

<h3>2.1. Tipos de Heran√ßa</h3>



Existem basicamente dois tipos de heran√ßa:

- **Heran√ßa Simples:** Nesse modelo, cada classe pode ter apenas uma √∫nica superclasse. Em TypeScript, utilizamos a palavra-chave **extends** para declarar que uma classe herda de outra.
- **Heran√ßa M√∫ltipla:** Este tipo de heran√ßa permite que uma classe tenha mais de uma superclasse, herdando os atributos e m√©todos de todas elas. Embora TypeScript n√£o suporte heran√ßa m√∫ltipla de forma nativa, como ocorre em linguagens como C++, √© poss√≠vel simul√°-la utilizando interfaces, que ser√£o explicadas mais adiante.

<br />

<h3>2.2. Heran√ßa em TypeScript</h3>



**Sintaxe:**

```ts
export class nome_da_classe extends nome_da_superclasse{
    //Corpo da Classe
}
```

<br />

<h4>2.2.1 A palavra reservada extends</h4>



A palavra reservada **extends** indica que uma classe est√° sendo criada como uma heran√ßa (ou extens√£o) de uma classe existente.

- A **classe existente** √© chamada de **superclasse**, **classe base** ou **classe progenitora**.
- A **nova classe** que herda os atributos e m√©todos da classe existente √© chamada de **subclasse**, **classe derivada** ou **classe filha**.

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#extends-clauses" target="_blank"><b>Documenta√ß√£o: Palavra reservada extends</b></a></div>


<br />

<h3>2.3 O M√©todo Construtor da Subclasse</h3>



O m√©todo construtor de uma subclasse utiliza o m√©todo **super()**, que tem a fun√ß√£o de chamar o construtor da superclasse. O **super()** deve sempre ser o primeiro item dentro do construtor da subclasse.

Dentro do m√©todo **super()**, devem ser passados como par√¢metros os atributos da superclasse. J√° os atributos espec√≠ficos da subclasse devem ser definidos no pr√≥prio construtor da subclasse.

<br />

<h3>2.4 A palavra reservada super</h3>



Al√©m do m√©todo **super()**, existe tamb√©m a palavra reservada **super**, que faz refer√™ncia aos objetos da superclasse, de forma semelhante √† palavra reservada **this**, que faz refer√™ncia aos objetos da pr√≥pria classe.

A palavra reservada **super** √© utilizada para chamar m√©todos da superclasse. O uso mais comum de **super** ocorre quando h√° m√©todos com o mesmo nome tanto na superclasse quanto na subclasse, ajudando a evitar confus√£o ao acessar o m√©todo da superclasse.

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>Exemplo 01 - Implementa√ß√£o em TypeScript 

**Classe Transporte**

```ts
export class Transporte {

	private _capacidade: number;

	constructor(capacidade: number) {
		this._capacidade = capacidade;
	}

	public get capacidade() {
		return this._capacidade;
	}

	public set capacidade(capacidade: number) {
		this._capacidade = capacidade;
	}
	
	public visualizar(): void {
		
		console.log("\n\n************************************************************");
		console.log("Dados do Meio de Transporte:");
		console.log("****************************************************************");
		console.log("Capacidade (n√∫mero de passageiros): " + this._capacidade);
	}
}
```

A Classe Transporte (Superclasse), foi criada com apenas um Atributo (capacidade), conforme o Diagrama de Classes acima. Tamb√©m foi criado o M√©todo Construtor, os M√©todos Get e Set do Atributo e o M√©todo visualizar para exibir os dados do Objeto na tela.

**Classe Terrestre**


```ts
import { Transporte } from "./Transporte";

export class Terrestre extends Transporte {

	private _numeroRodas: number;
	private _velocidade: number;

	constructor(capacidade: number, numeroRodas: number, velocidade: number) {
		super(capacidade);
		this._numeroRodas = numeroRodas;
		this._velocidade = velocidade;
	}

	public get numeroRodas() {
		return this._numeroRodas;
	}

	public set numeroRodas(numeroRodas: number) {
		this._numeroRodas = numeroRodas;
	}

	public get velocidade() {
		return this._velocidade;
	}

	public set velocidade(velocidade: number) {
		this._velocidade = velocidade;
	}

	public visualizar(): void {
		super.visualizar();
		console.log("N√∫mero de rodas: " + this.numeroRodas);
		console.log("Velocidade: " + this.velocidade.toFixed(2));
	}
}

```

A Classe Terrestre (Subclasse), foi criada como Heran√ßa da Classe Transporte (**extends Transporte**), com dois Atributos (**numeroRodas** e **velocidade**), conforme o Diagrama de Classes acima. Al√©m disso, tamb√©m foram criados o M√©todo Construtor, os M√©todos Get e Set dos Atributos e o M√©todo visualizar para exibir os dados do Objeto na tela. 

Observe que:

- Nos par√¢metros do M√©todo Construtor foi adicionado o Atributo **capacidade**, da Classe Transporte. 
- No corpo do M√©todo Construtor foi adicionado o M√©todo **super** para acessar os Atributos da Classe Transporte (**super(capacidade)**). 
- No M√©todo visualizar foi adicionado o M√©todo **super** para executar o M√©todo **visualizar()** (**super.visualizar()**), da Classe Transporte, para listar os dados dos atributos da Classe Transporte.

**Classe Automovel**

```ts
import { Terrestre } from "./Terrestre";

export class Automovel extends Terrestre{

	private _cor: string;
	private _numeroPortas: number;
	private _placa: string;
	private _marcha: number;
	
	constructor(capacidade: number, numeroRodas: number, velocidade: number, cor: string, numeroPortas: number, placa: string, marcha: number) {
		super(capacidade, numeroRodas, velocidade);
		this._cor = cor;
		this._numeroPortas = numeroPortas;
		this._placa = placa;
		this._marcha = marcha;
	}

	public get cor() {
		return this._cor;
	}

	public set cor(cor: string) {
		this._cor = cor;
	}

	public get numeroPortas() {
		return this._numeroPortas;
	}

	public  set numeroPortas(numeroPortas: number) {
		this._numeroPortas = numeroPortas;
	}

	public get placa() {
		return this._placa;
	}

	public set placa(placa: string) {
		this._placa = placa;
	}
	
	public get marcha() {
		return this._marcha;
	}

	public set marcha(marcha: number) {
		this._marcha = marcha;
	}

	public visualizar(): void {

		super.visualizar();
		console.log("cor: " + this._cor);
		console.log("N√∫mero de portas: " + this._numeroPortas);
		console.log("Placa: " + this._placa);
		console.log("Marcha: " + this._marcha);
		
	}
}
```

A Classe Automovel (Subclasse), foi criada como Heran√ßa da Classe Terrestre (**extends Terrestre**), com os Atributos (**cor, numeroPortas, placa e marcha**), conforme o Diagrama de Classes acima. Al√©m disso, tamb√©m foram criados o M√©todo Construtor, os M√©todos Get e Set dos Atributos e o M√©todo visualizar para exibir os dados do Objeto na tela. 

Observe que:

- No M√©todo Construtor foram adicionados os Atributos **capacidade**, da Classe Transporte, e **numeroRodas**, da Classe Terrestre, nos par√¢metros do M√©todo. 
- No corpo do M√©todo Construtor foi adicionado o M√©todo **super** para acessar os Atributos da **Classe Terrestre** e da **Classe Transporte**, que foram herdados na Classe Terrestre (**super(capacidade, numeroRodas, velocidade)**). 
- No M√©todo visualizar tamb√©m foi adicionado o M√©todo **super** para executar o M√©todo **visualizar()** (**super.visualizar()**), da Classe Terrestre, para listar os dados dos atributos das Classes Terrestre e Transporte.

**Classe TestaTransporte**

```ts
import { Automovel } from "./Automovel";

export function main() {

    const aut1: Automovel = new Automovel(5, 4, 250.00, "Verde", 4, "EBN-0301", 0);

    aut1.visualizar();

}

main();
```

Na Classe TestaTransporte, foi instanciado uma Objeto da Classe Automovel. Observe que devido as Heran√ßas, o Objeto da Classe Automovel possui 7 par√¢metros: 

- capacidade (herdado da Classe Transporte)
- numeroRodas e velocidade (Herdado da Classe Terrestre)
- cor, numeroPortas, placa e marcha (Atributos da Classe Automovel)

Abaixo, voc√™ confere o resultado do c√≥digo no Console:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
*********************************************************************
Dados do Meio de Transporte:
*********************************************************************
Capacidade (n√∫mero de passageiros): 5
N√∫mero de rodas: 4
Velocidade: 250.00
cor: Verde
N√∫mero de portas: 4
Placa: EBN-0301
Marcha: 0
```

<br />


> **Dicas sobre Heran√ßa:**
>
> 1. Sempre coloque os m√©todos e atributos comuns para todas as Subclasses na **Superclasse**
> 2. Use heran√ßa para modelar uma rela√ß√£o de ‚Äúestar contido em‚Äù, ou seja, **um objeto da Subclasse √© um objeto da Superclasse**
> 3. N√£o use heran√ßa a menos que todos ou a maioria dos m√©todos herdados da Superclasse fa√ßam sentido na Subclasse

<br />

<h2>3. Polimorfismo</h2>



O **polimorfismo** deriva da palavra *polimorfo*, que significa multiforme, ou seja, algo que pode variar de forma.

Na Programa√ß√£o Orientada a Objetos (POO), o polimorfismo √© a capacidade de objetos de diferentes classes responderem √† mesma mensagem de maneiras distintas. Em outras palavras, √© a habilidade de um objeto decidir qual m√©todo aplicar a si mesmo, mesmo que a mensagem seja a mesma. Assim, diferentes objetos podem reagir de formas diferentes, mesmo quando recebem a mesma solicita√ß√£o.

**Exemplo:**

*Um dono de uma f√°brica de brinquedos solicitou que seus engenheiros criassem um mesmo controle remoto para todos os brinquedos de sua f√°brica. A √∫nica restri√ß√£o era que cada brinquedo atendesse aos comandos espec√≠ficos definidos pelo controle.*

<div align="center"><img src="https://i.imgur.com/NM8RVg5.png" title="source: imgur.com" /></div>

Assim quando o brinquedo recebe o sinal **MOVER**, ele se move de acordo com a sua fun√ß√£o:

- Para o avi√£o, mover significa **VOAR**;
- Para o barco significa **NAVEGAR**, e
- Para o autom√≥vel **CORRER**.

<div align="center"><img src="https://i.imgur.com/KnwNIwl.png" title="source: imgur.com" /></div>

Observe que os brinquedos respondem ao mesmo sinal  de formas diferentes. O Polimorfismo permite que diferentes objetos (avi√£o, barco, autom√≥vel) respondam uma mesma mensagem (mover) de formas diferentes (voar, navegar e correr).

<br />

<h3>3.1. Como funciona na pr√°tica?</h3>



- Quando uma mensagem √© enviada para uma **subclasse** solicitando a aplica√ß√£o de um **m√©todo** com certos par√¢metros, a subclasse verifica se possui um m√©todo com esse nome e par√¢metros exatos.
- Se a subclasse tiver esse m√©todo, ela o utiliza para processar a mensagem.
- Caso contr√°rio, a **superclasse** assume a responsabilidade pelo processamento da mensagem e busca um m√©todo com o mesmo nome e par√¢metros.
- Se a superclasse encontrar o m√©todo, ela o chama para processar a mensagem.

<br />

<h3>3.2. Tipos de Polimorfismo</h3>

<br />

<h4>3.2.1. Polimorfismo de Sobreposi√ß√£o (Sobrescrita de M√©todo)</h4>



O ato de **sobrescrever** um m√©todo ou propriedade significa dar uma nova vers√£o ou forma a ele. Em **TypeScript**, a **sobrescrita de m√©todos** ocorre quando criamos um novo m√©todo na classe filha com a mesma assinatura e o mesmo tipo de retorno do m√©todo da classe pai (tamb√©m conhecido como **Override**).

A **sobrescrita** est√° diretamente relacionada √† **Orienta√ß√£o a Objetos**, especialmente √† **heran√ßa**. Com a **sobrescrita**, √© poss√≠vel especializar os **m√©todos** herdados das superclasses, alterando seu comportamento nas subclasses para algo mais espec√≠fico.

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>Exemplo 02: Polimorfismo de Sobrescrita

O M√©todo **visualizar()** da Classe Transporte, est√° implementado da seguinte forma:

```ts
	public visualizar(): void {
		
		console.log("\n\n************************************************************");
		console.log("Dados do Meio de Transporte:");
		console.log("****************************************************************");
		console.log("Capacidade (n√∫mero de passageiros): " + this._capacidade);
	}
```

O M√©todo **visualizar()** da Classe Terrestre, foi reescrito da seguinte forma:

```ts
	public visualizar(): void {
		super.visualizar();
		console.log("N√∫mero de rodas: " + this.numeroRodas);
		console.log("Velocidade: " + this.velocidade.toFixed(2));
	}
```

O M√©todo **visualizar()** da Classe Automovel, foi reescrito da seguinte forma:

```ts
	public visualizar(): void {

		super.visualizar();
		console.log("cor: " + this._cor);
		console.log("N√∫mero de portas: " + this._numeroPortas);
		console.log("Placa: " + this._placa);
		console.log("Marcha: " + this._marcha);
		
	}
```

Observe que as assinaturas dos tr√™s m√©todos s√£o as mesmas, entretanto, o m√©todo visualizar() nas tr√™s classes possui implementa√ß√µes diferentes, pois ele exibe os atributos das classes herdadas e os seus pr√≥prios atributos.

No exemplo acima, para que o m√©todo visualizar() funcione de forma diferente nas classes Terrestre e Automovel, ele precisou ser sobrescrito. Isso ocorre porque as classes Terrestre e Automovel n√£o possuem acesso direto √†s vari√°veis de inst√¢ncia privadas da superclasse. Ou seja, o m√©todo n√£o pode alterar ou acessar diretamente essas vari√°veis de inst√¢ncia. Por isso, elas executam o m√©todo super.visualizar() para acessar os atributos das classes herdadas.

Um ponto de aten√ß√£o importante sobre a sobrescrita √© que um m√©todo redefinido em uma subclasse com o mesmo nome e mesma lista de par√¢metros que o m√©todo da classe ancestral (superclasse) automaticamente oculta o m√©todo da classe ancestral na subclasse. Ou seja, o m√©todo da subclasse passa a ser usado em vez do m√©todo da superclasse

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="80px"/> | <p align="justify"> **IMPORTANTE:** A Linguagem TypeScript n√£o oferece suporte ao Polimorfismo por Sobrecarga, ou seja, 2 m√©todos em uma mesma Classe, com o mesmo nome, mas com par√¢metros diferentes. </p> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="4%"/> <a href="https://github.com/rafaelq80/exemplos_js/tree/main/typescript/heranca" target="_blank"><b>C√≥digo fonte dos Exemplos</b></a></div>

<br />

------

## üîë**Pontos chave:**

1. **Os Relacionamentos entre classes no TypeScript** definem os Relacionamentos especiais entre os diferentes tipos de classes. 
2. A Heran√ßa √© um tipo de Relacionamento entre Classes no TypeScript e uma das maiores vantagens da Programa√ß√£o Orientada a Objetos, permitindo que o c√≥digo seja reutilizado. Em TypeScript, √© poss√≠vel herdar **atributos** e **comportamentos** (**m√©todos**) de uma classe para outra. 

3. **Heran√ßa Simples:** Cada classe pode ter apenas uma superclasse. Na linguagem TypeScript usa-se a palavra reservada **extends** para declarar que uma classe √© herdeira de outra.
4. **Heran√ßa M√∫ltipla:** √â a capacidade de uma classe possuir mais de uma superclasse e herdar os atributos e m√©todos de todas as superclasses. TypeScript n√£o implementa Heran√ßa M√∫ltipla nativamente.
5. O **Polimorfismo** √© considerado um dos recursos mais importantes da Programa√ß√£o Orientada a Objetos, permitindo que uma a√ß√£o seja executada de diferentes maneiras, fornecendo implementa√ß√µes variadas para m√©todos e interfaces. A palavra **polimorfismo** significa adquirir muitas formas ou assumir fun√ß√µes diferentes. 
6. **Polimorfismo de Sobreposi√ß√£o:** √â a redefini√ß√£o de m√©todos em classes descendentes, ou seja, um m√©todo de uma classe filha com o mesmo nome de um m√©todo de uma classe m√£e ir√° sobrepor esse √∫ltimo. O m√©todo redefinido tem preced√™ncia em rela√ß√£o a chamadas de m√©todo nos objetos da subclasse.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
