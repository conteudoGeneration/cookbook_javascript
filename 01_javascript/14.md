<h1>Programa√ß√£o Orientada a Objetos - Parte 01</h1>
<h2>Classes, Objetos e Encapsulamento</h2>



Em geral, quanto maior o software, mais complexo √© o seu desenvolvimento, devido √†s muitas partes que comp√µem o todo e o relacionamento entre estas partes. 

Uma raz√£o frequente para as dificuldades de implementa√ß√£o, testes e manuten√ß√£o √© que, em geral, quando se segue uma l√≥gica de projeto de software voltado apenas nas funcionalidades, o sistema √© desenvolvido e estruturado de acordo com o que ele faz, sem uma preocupa√ß√£o em representar o processo de uma maneira similar ao que acontece no mundo real, ou seja, no dia a dia.

O problema dessa abordagem √© que, de tempos em tempos, as empresas mudam seus processos e procedimentos. Isso significa que, o software tamb√©m ter√° que mudar e se ele foi todo estruturado de acordo com o que ele precisava fazer antes, pode ser que agora ele precise ser totalmente reestruturado ou ser refeito, a menos que fa√ßamos um POG "Programa√ß√£o Orientada a Gambiarras" para manter as coisas funcionando.

Entretanto, alguns desenvolvedores pensaram h√° algumas d√©cadas atr√°s: "***Se as fun√ß√µes de uma empresa e de um software mudam com muita frequ√™ncia, eu n√£o posso us√°-las como base para a organiza√ß√£o da minha aplica√ß√£o***". Essa foi a primeira grande conclus√£o dos fatos acima. A partir deste pensamento, surgiu a pergunta que levou √† segunda grande conclus√£o: "***Mas o que √© que, em uma empresa e em seus processos, raramente muda?***" Por sorte algu√©m conseguiu perceber o que raramente muda em uma empresa: ***As Coisas!***

***Como assim, as coisas???*** 

**Simples: tudo aquilo que √© f√≠sico**. Existe uma grande const√¢ncia no uso de formul√°rios, na produ√ß√£o de um determinado produto, nos funcion√°rios envolvidos em um procedimento, entre outros. As entidades s√£o muito constantes, os objetos envolvidos na realiza√ß√£o dos processos s√£o, quase sempre, os mesmos. A partir destas observa√ß√µes, surgiu a segunda grande conclus√£o: "***Vamos basear a estrutura do software nos objetos envolvidos em seus processos e n√£o nos processos em si***".

**Programa√ß√£o Orientada a Objetos** (POO) **√© um Paradigma de Programa√ß√£o que ajuda a definir a estrutura de programas de computadores, baseado nos conceitos do mundo real, sejam eles Reais ou Abstratos.** A ideia √© simular as coisas que existem e acontecem no mundo real no mundo virtual.

- O mundo real √© composto de objetos que interagem entre si.
- Um modelo orientado a objetos √© composto por objetos que interagem entre si.

> **Abstrato, segundo o Dicion√°rio**
>
> **Abstrato:** Algo que n√£o √© concreto; que resulta da abstra√ß√£o, que opera unicamente com ideias, com associa√ß√µes de ideias, n√£o diretamente com a realidade sens√≠vel, que possui um alto grau de generaliza√ß√£o.

Da teoria dos sistemas, definimos um sistema como **um conjunto de entidades que interagem entre si a fim de produzir um resultado comum**. A partir desta defini√ß√£o conclu√≠mos que √© natural o uso de "objetos programa" a fim de compor um sistema computacional.

<br />

<h2>1. Objetos</h2>

No mundo real, objetos podem ser animados ou inanimados, mas **qualquer um deles possui caracter√≠sticas que podem ser classificadas como atributos ou comportamentos**. Na imagem abaixo, vemos alguns exemplos de objetos:

<div align="center"><img src="https://i.imgur.com/MJIvLag.png" title="source: imgur.com" /></div>

Observe que nos exemplos acima cada Objeto foi definido de forma Gen√©rica: Animal, Pessoa, Produto e Conta. 

Analisando o Objeto Conta, por exemplo, n√≥s sabemos que a Conta √© de um Banco, mas n√£o sabemos os detalhes da Conta como:

1) Qual √© o n√∫mero da Conta?
2) Qual √© o numero da Ag√™ncia Banc√°ria?
3) Quem √© o titular da Conta?
4) Qual √© o tipo da Conta?
5) Qual √© o Saldo da Conta?

O Objeto Conta foi definido de uma forma Abstrata, Gen√©rica, com poucos ou nenhum detalhe. Nesta etapa da modelagem do Sistema Orientado √† Objetos, o foco √© apenas identificar os Objetos Gen√©ricos, ou seja, uma generaliza√ß√£o da Abstra√ß√£o. Aqui n√£o s√£o levados em conta as especificidades e sim a cria√ß√£o de um modelo que represente toda e qualquer Conta Banc√°ria.

Modelar um Sistema baseado em Objetos traz algumas vantagens:

- **Simplifica√ß√£o da concep√ß√£o do sistema:** a transi√ß√£o da realidade para o modelo √© facilitada.
  
- **Simplifica√ß√£o da compreens√£o do modelo:** como o modelo √© mais pr√≥ximo da realidade, a compreens√£o do modelo por quem compreende o problema real √© quase autom√°tica.
  
- **Simplifica√ß√£o do Gerenciamento do sistema:** assim como na realidade, os objetos s√£o est√°veis na solu√ß√£o de um problema, ou seja, os objetos mudam muito pouco; quando √© necess√°rio resolver problemas ligeiramente diferentes, modificamos a forma com que os objetos interagem e n√£o os objetos em si.

<br />

<h3>1.1. O que s√£o Objetos em Programa√ß√£o?</h3>



Em programa√ß√£o (e, de certa forma tamb√©m na vida real), um Objeto √© uma Entidade caracterizada por um conjunto de opera√ß√µes e um estado, caracterizados por **fun√ß√µes (chamados de M√©todos) e campos (chamados de Atributos)**, podendo ainda ser **compostos por outros Objetos (os Atributos podem ser Objetos de outras Classes)**.

Note que um objeto √© uma estrutura similar √† uma "estrutura de dados", por√©m, al√©m de "dados", um objeto pode armazenar tamb√©m "fun√ß√µes". Em um objeto os dados s√£o chamados de **Atributos** e as fun√ß√µes s√£o chamadas de **M√©todos**.

Todo o Objeto possui 3 caracter√≠sticas fundamentais: **Identidade** (nome), **Estado** (propriedades ou atributos) e **Comportamento** (a√ß√µes ou m√©todos), como veremos adiante.

<br />

<h2>2. Classes</h2>



Classes s√£o como pequenos programas, que podem ser considerados novos tipos de dados. Uma classe pode ser considerada como um "molde" de um Objeto, sendo uma descri√ß√£o de como um objeto pode ser criado. Uma forma interessante de explicar √© que uma classe est√° para um objeto assim como a planta de uma casa est√° para a casa. 

<div align="center"><img src="https://i.imgur.com/0zF5E7u.png" title="source: imgur.com" /></div>

Repare que a classe em si √© um conceito abstrato, como um molde, que se torna concreto e palp√°vel atrav√©s da cria√ß√£o de um objeto. Chamamos essa cria√ß√£o de **Instancia√ß√£o da Classe**, como se estivesse usando a Classe como uma forma para criar v√°rios Objetos.

<div align="center"><img src="https://i.imgur.com/Q40v71w.png" title="source: imgur.com" /></div>

Na imagem acima vemos que uma Planta pode ser utilizada para construir N casas. Da mesma forma, uma Classe pode instanciar (criar) N Objetos.

Como todo programa, uma classe √© composta por algumas vari√°veis, que chamamos de **Atributos** e algumas fun√ß√µes que chamaremos de **M√©todos**, conforme vimos no t√≥pico anterior. 

Os **Atributos s√£o respons√°veis por identificar as caracter√≠sticas do Objeto**. Veja no exemplo abaixo:

<div align="center"><img src="https://i.imgur.com/QBaJPAy.png" title="source: imgur.com" /></div>

Observe que definindo os Atributos do Objeto n√≥s conseguimos identificar os detalhes da Conta e automaticamente conseguimos responder as perguntas anteriores. Cada classe deve representar um conceito (Conta, Pessoa, Animal, Produto) e este conceito √© descrito atrav√©s dos seus Atributos (Conta: titular, tipo, banco, agencia e entre outros.).

Os **M√©todos s√£o respons√°veis por definir as a√ß√µes que ir√£o modificar e/ou interagir com os Atributos**.

<div align="center"><img src="https://i.imgur.com/SSijmB3.png" title="source: imgur.com" /></div>

Observe no Diagrama acima, que ele identifica algumas a√ß√µes que os Objetos Conta possuem (Sacar, Depositar, Criar conta, Consultar conta, entre outras).

Observe tamb√©m que os **Atributos s√£o identificados por substantivos** e os **M√©todos s√£o identificados por verbos**.

Na Computa√ß√£o, um Sistema Orientado a Objetos √© visto como um conjunto de Objetos agrupados em Classes de Objetos similares que interagem atrav√©s da troca de mensagens (Chamada dos M√©todos). Cada **classe** √© um **modelo** **est√°tico** que permite especificar um conjunto de caracter√≠sticas do conceito que representa. Cada **objeto** √© uma **entidade** **din√¢mica** criada a partir de uma classe, que possui os dados sobre os quais s√£o realizadas as opera√ß√µes dispon√≠veis em sua Classe. **Todos os objetos s√£o inst√¢ncias de uma classe, ou seja, √© a materializa√ß√£o de um conceito formalizado**.

**Exemplo:** 

<div align="center"><img src="https://i.imgur.com/esIWB81.png" title="source: imgur.com" /></div>

**Conta** **√© uma classe que define um modelo de Objeto.**

**A Conta da Maria Joaquina e a Conta do Jo√£o da Silva s√£o inst√¢ncias da Classe Conta, ou seja, Objetos gerados a partir do modelo definido pela Classe.**

<br />

<h3>2.1. Representa√ß√£o Gr√°fica</h3>

Para representar uma Classe graficamente na Orienta√ß√£o Objetos, utilizamos o **Diagrama de Classes**, que faz parte da **UML - Unified Model Language**, que √© uma Linguagem de Modelagem Unificada para Sistemas Orientados a Objetos. Veja o Diagrama de Classes da nossa Classe Conta:

```mermaid
classDiagram
class Conta {
 - numero: number
 - agencia: number
 - tipo: number
 - titular: string
 - saldo: number
 + getNumero(): number
 + getAgencia(): number
 + getTipo(): number
 + getTitular(): string
 + getSaldo(): number
 + setNumero(numero: number): void
 + setAgencia(agencia: number): void
 + setTipo(tipo: number): void
 + setTitular(titular: string): void
 + setSaldo(saldo: number): void
 + saque(valor: number): boolean
 + visualizar(): void
}
```

O Diagrama de Classes √© organizado da seguinte forma:

<div align="center"><img src="https://i.imgur.com/edOFUeU.png" title="source: imgur.com" /></div>

- **Nome:** Nome da Classe.
- **Atributos:** S√£o os dados (vari√°veis) da Classe. Os Atributos devem vir acompanhados do seu tipo de dado.
- **M√©todos:** S√£o as a√ß√µes da Classe. Os M√©todos devem vir acompanhados do seu tipo de dado de sa√≠da e podem vir acompanhados do tipo de dado de entrada.

<br />

<h2>3. Modificadores de Visibilidade</h2>



Modificadores de Visibilidade ou Modificadores de acesso alteram a visibilidade dos Atributos e dos m√©todos de uma Classe, ou seja, qual (is) Classes podem chamar um determinado M√©todo de outra Classe e/ou acessar os seus Atributos.

Os Modificadores de acesso s√£o aplicados apenas nos M√©todos e os Atributos de uma Classe, diferente de outras Linguagens, como Java e C#,  que aplicam os Modificadores de acesso nas Classes tamb√©m. O TypeScript oferece 3 modificadores de acesso:

| **Modificador** | **Descri√ß√£o**                                                | UML  |
| --------------- | ------------------------------------------------------------ | :--: |
| **public**      | Um M√©todo ou Atributo public poder√° ser acessado por qualquer Classe. |  +   |
| **protected**   | Um M√©todo ou Atributo protected √© protegido. Pode ser acessado dentro da pr√≥pria Classe onde eles foram declarados e por todas as Classes que estendem (Herdam) a Classe onde eles foram declarados. |  #   |
| **private**     | Um M√©todo ou Atributo private possui o acesso restrito. Pode ser acessado somente dentro da pr√≥pria Classe onde eles foram declarados. |  -   |

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="200px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao criar os M√©todos e Atributos do projeto. Os modificadores de acesso (public, protected e private) nunca poder√£o ser combinados.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

Observe que na coluna UML da tabela acima, temos o s√≠mbolo que identifica a visibilidade do M√©todo. O mais comum na Modelagem de uma Classe √© **manter os Atributos Private (-) e os M√©todos Public (+)**, para garantir o Encapsulamento dos Atributos, como veremos na sequ√™ncia.

Na imagem abaixo podemos visualizar a hierarquia dos modificadores de visibilidade:

<div align="center"><img src="https://i.imgur.com/4go1ThA.png" title="source: imgur.com" /></div>

A imagem acima mostra o n√≠vel de visibilidade dos Atributos e M√©todos, do n√≠vel de acesso mais restrito (Private) ao n√≠vel de acesso total e irrestrito (Public). Na tabela abaixo temos um resumo:

| Modificador   | Classe | Sub Classe | Mundo |
| ------------- | :----: | :--------: | :---: |
| **public**    |   ‚úî    |     ‚úî      |   ‚úî   |
| **protected** |   ‚úî    |     ‚úî      |   ‚ùå   |
| **private**   |   ‚úî    |     ‚ùå      |   ‚ùå   |

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="80px"/> | <div align="left"> **ATEN√á√ÉO:** *Os Modificadores de acesso de um Atributo definem quais Classes poder√£o acessar o Atributo, da mesma forma que os Modificadores de acesso de um M√©todo definem quais Classes ter√£o acesso ao M√©todo.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html" target="_blank"><b>Documenta√ß√£o: Modificadores de visibilidade</b></a></div>

<br />

## <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/> Exemplo 01: Classe Conta com os respectivos Atributos e Modificadores de Acesso

```ts
export class Conta {

    private _numero: number;
    private _agencia: number;
    private _tipo: number;
    private _titular: string;
    private _saldo: number;
  
}
```

Seguindo as boas pr√°ticas do TypeScript, observe que todos os Atributos da Classe iniciam com um **underline** ( _ ), indicando que se tratam de Atributos Privados (private) .

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html" target="_blank"><b>Documenta√ß√£o: Declara√ß√£o de Classes</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/variables.html" target="_blank"><b>Documenta√ß√£o: Declara√ß√£o de Atributos</b></a></div>

<br />

<h2>4. M√©todos</h2>



Um **M√©todo** √© uma Fun√ß√£o associada √† Classe, ou seja, uma a√ß√£o sobre um Objeto definido pela Classe. Um  m√©todo TypeScript √© uma propriedade de um objeto que cont√©m uma  defini√ß√£o de Fun√ß√£o. M√©todos s√£o fun√ß√µes armazenadas como propriedades  do Objeto. O principal benef√≠cio do uso de M√©todos √© que eles s√£o  reutiliz√°veis em futuros programas, evitando a repeti√ß√£o desnecess√°ria  de c√≥digo.

Da mesma forma que as Fun√ß√µes, **todos os M√©todos tamb√©m devem estar limitados √† realiza√ß√£o de uma √∫nica tarefa bem definida** e o **nome do M√©todo tamb√©m deve ser assertivo e expressar exatamente a tarefa ele executar√°**.

**Exemplos de M√©todos:**

- **Objeto Carro:** acelerar(), frear(), virar(), parar()
- **Objeto Conta Banc√°ria:** sacar(), depositar(), transferir()
- **Objeto E-commerce:** pagar(), adicionarAoCarrinho()

<br />

<h3>4.1. Declarando M√©todos</h3>



**Sintaxe:**

```ts
[modificadores_de_acesso] nome_do_metodo(argumento: tipo): tipo_de_retorno {
    //Corpo do M√©todo
}
```

Observe que diferente das Fun√ß√µes, ao declarar um M√©todo n√£o se utiliza a palavra reservada **function**.

<br />

<h4>4.1.1. Modificadores de Acesso</h4>

Como visto anteriormente, Modificadores de acesso alteram a visibilidade dos M√©todos de uma Classe, ou seja, qual (is) Classes podem chamar um determinado M√©todo de outra Classe e/ou acessar os seus Atributos.

<br />

<h4>4.1.2. Nome do M√©todo</h4>



√â o nome ou identificador do M√©todo. Para definir o Nome do M√©todo, deve-se seguir as mesmas boas pr√°ticas utilizadas na defini√ß√£o do nome de uma Fun√ß√£o.

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#methods" target="_blank"><b>Documenta√ß√£o: Declara√ß√£o de M√©todos</b></a></div>

<br />

<h4>4.1.3. Argumentos</h4>



S√£o os par√¢metros do M√©todo. S√£o representados por uma **lista de vari√°veis separadas por v√≠rgulas**, onde cada par√¢metro obedece as regras e a sintaxe de defini√ß√£o de vari√°veis:

**Sintaxe:**

```ts
[modificadores_de_acesso] nome_do_metodo(identificador: tipo) {
    //Corpo do M√©todo
}
```

- **Identificador:** Nome da vari√°vel.
- **Tipo:** Tipo da vari√°vel.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ATEN√á√ÉO:** Ao declarar os argumentos do M√©todo n√£o √© necess√°rio adicionar as palavras *var ou let* para indicar que os argumentos s√£o vari√°veis, declare apenas o identificador do argumento, seguido do seu tipo.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean" target="_blank"><b>Documenta√ß√£o - Tipos de dados</b></a></div>

<br />

<h4>4.1.4. Tipo de Retorno</h4>



√â o indicador do Tipo de retorno do M√©todo, ou seja, o tipo do valor que se espera que o M√©todo retorne ao finalizar o processamento dos dados. Assim como as vari√°veis, os M√©todos com tipo de retorno geralmente s√£o declarados com  tipos de dados primitivos, mas eles tamb√©m podem retornar tipos n√£o primitivos como Objetos, array, entre outros. Na tabela abaixo, vemos o tipos mais comuns de retorno:

| **Tipo**    | **Tamanho**          |
| ----------- | -------------------- |
| **boolean** | *true* ou *false*    |
| **number**  | 64  bits             |
| **string**  | cadeia de caracteres |
| **any**     | qualquer tipo        |
| **null**    | Nulo                 |

Os M√©todos que possuem um tipo de dado, obrigatoriamente precisam retornar um valor equivalente ao seu tipo, ou seja, se o M√©todo for declarado para retornar um valor do tipo **number**, ela precisa retornar um numero ao final do seu processamento. Para retornar este valor, o TypeScript utiliza a palavra reservada **return** seguido do valor de retorno.

Caso o M√©todo **n√£o necessite ter um tipo de dado de retorno, ou seja, um valor que dever√° ser retornado ao final da execu√ß√£o do M√©todo**, na assinatura do M√©todo, defina o tipo de retorno como **void**.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ATEN√á√ÉO:** *Ao declarar um M√©todo, caso o tipo de retorno n√£o seja informado, o TypeScript definir√° o tipo de retorno por infer√™ncia, baseado nos argumentos e no retorno definido no Corpo do M√©todo.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h2>5. M√©todos Especiais</h2>

Ao construirmos nossas Classes como modelo para constru√ß√£o de Objetos, precisamos implementar alguns M√©todos especiais:

<h3>5.1. M√©todo Construtor</h3>

Para criar (instanciar) um novo Objeto de uma Classe, precisamos implementar um M√©todo para gerar este novo Objeto. O M√©todo respons√°vel por esta tarefa em uma Classe √© o **M√©todo Construtor**. 

**Um M√©todo Construtor √© um M√©todo especial, definido para cada classe**. Entre as suas principais caracter√≠sticas, podemos destacar:

- Determina as a√ß√µes associadas √† **inicializa√ß√£o** de **cada objeto criado**.
- Toda vez que o programa instancia um novo Objeto da Classe, ele √© o M√©todo que ser√° **invocado**. 
- A **assinatura de um construtor** diferencia-se das assinaturas dos outros m√©todos por n√£o ter nenhum tipo de retorno (nem mesmo **void**).
- O **Nome do M√©todo Construtor** no TypeScript sempre ser√° **constructor**. 
- O construtor pode receber argumentos, como qualquer M√©todo. Geralmente ele recebe vari√°veis com o mesmo nome dos Atributos da Classe.
- Toda **Classe deve ter pelo menos um M√©todo construtor** definido. 

<br />

## <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/> Exemplo 02: M√©todo Construtor da Classe Conta

```ts
export class Conta {

    private _numero: number;
    private _agencia: number;
    private _tipo: number;
    private _titular: string;
    private _saldo: number;
  
    constructor(numero: number, agencia: number, tipo: number, titular: string, saldo: number) {
        this._numero = numero;
        this._agencia = agencia;
        this._tipo = tipo;
        this._titular = titular;
        this._saldo = saldo;
    }

}
```

Observe que em cada atributo foi adicionada a palavra reservada **this**. O motivo √© simples: a palavra reservada **this** √© utilizada para **identificar o atributo da Classe**. Observe que os par√¢metros do M√©todo Construtor tem o mesmo nome, sem o **underline ( _ )**, e o mesmo tipo de dado dos atributos.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html" target="_blank"><b>Documenta√ß√£o: M√©todo Construtor</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html" target="_blank"><b>Documenta√ß√£o: Palavra reservada this</b></a></div>


<br />

<h3>5.2. M√©todos Get e Set</h3>



Os m√©todos GET e SET s√£o **t√©cnicas padronizadas para gerenciamento sobre o acesso dos atributos**. Nesses m√©todos determinamos quando ser√° alterado um atributo e o acesso ao mesmo, tornando o controle e as modifica√ß√µes mais pr√°ticas e limpas, sem a necessidade de alterar a assinatura do m√©todo usado para acessar o atributo. Estes M√©todos s√£o essenciais porqu√™ os Atributos da Classe s√£o privados e portanto s√≥ podem ser manipulados por estes m√©todos da classe.

<br />

<h4>5.2.1. M√©todos SET</h4>



Os m√©todos SET servem para modificar os dados dos atributos da Classe. Os m√©todos SET tamb√©m s√£o chamados de **setters**. Note que o nome do M√©todo ser√° uma combina√ß√£o da palavra **set** seguida do nome do atributo. Implicitamente, os M√©todos Set s√£o do tipo **void**, porque n√£o retornam nenhum valor, apenas modificam o valor do atributo.

**M√©todo Set do Atributo Numero da Classe Conta:**

```ts
	public set numero(numero: number) {
        this._numero = numero;
    }
```

Observe que no atributo **_numero** foi adicionada a palavra reservada **this**, para identificar o atributo da classe. Voc√™ deve criar um M√©todo Set para cada Atributo da Classe.

<br />

<h4>5.2.2. M√©todos GET</h4>



Agora j√° sabemos como mudar os valores dos atributos, vamos entender como ler os dados dos atributos. Os m√©todos GET servem para ler os dados dos atributos. Os m√©todos GET tamb√©m s√£o chamados de **getters**. Note que o nome do M√©todo ser√° uma combina√ß√£o da palavra **get** seguida do nome do atributo. Implicitamente, os M√©todos Get s√£o do mesmo tipo do atributo que voc√™ est√° lendo os dados.

**M√©todo Get do Atributo Numero da Classe Conta:**

```ts
	public get numero() {
        return this._numero;
    }
```

Observe que foi utilizada a palavra reservada **return**, retornando o valor do atributo **_numero**. No atributo **_numero** foi adicionada a palavra reservada **this**, para identificar o atributo da classe. Voc√™ deve criar um M√©todo Get para cada Atributo da Classe.

<h4>5.2.3. Qual √© a vantagem de usar getters e setters?</h4>



1. Se voc√™ n√£o quiser que os dados de um atributo sejam modificados por outras classes, remova o m√©todo setter do atributo.
2. Se voc√™ n√£o quiser que os dados de um atributo sejam lidos por outras classes, remova o m√©todo getter do atributo.
3. O setter permite validar os dados antes de armazen√°-los, evitando que dados incorretos sejam colocados nos atributos.
4. O getter permite esconder o formato (tipo de dado) com que um atributo est√° armazenado.

<br />

## <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/> Exemplo 03: M√©todos Get e Set da Classe Conta

```ts
export class Conta {

    private _numero: number;
    private _agencia: number;
    private _tipo: number;
    private _titular: string;
    private _saldo: number;
  
    constructor(numero: number, agencia: number, tipo: number, titular: string, saldo: number) {
        this._numero = numero;
        this._agencia = agencia;
        this._tipo = tipo;
        this._titular = titular;
        this._saldo = saldo;
    }

    public get numero() {
        return this._numero;
    }

    public set numero(numero: number) {
        this._numero = numero;
    }

    public get agencia() {
        return this._agencia;
    }

    public set agencia(agencia: number) {
        this._agencia = agencia;
    }

    public get tipo() {
        return this._tipo;
    }

    public set tipo(tipo: number) {
        this._tipo = tipo;
    }

    public get titular() {
        return this._titular;
    }

    public set titular(titular: string) {
        this._titular = titular;
    }

    public get saldo() {
        return this._saldo;
    }

    public set saldo(saldo: number) {
        this._saldo = saldo;
    }

}
```

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.w3schools.com/java/java_encapsulation.asp" target="_blank"><b>Documenta√ß√£o: M√©todos GET e SET</b></a></div>

<br />

<h2>6. Encapsulamento</h2>



**Encapsular**, nada mais √© do que proteger os atributos de uma classe de acesso externo, permitindo somente sua manipula√ß√£o de forma indireta. 

Encapsular os dados de uma aplica√ß√£o significa evitar que estes sofram acessos indevidos. Para isso, √© criada uma estrutura que cont√©m m√©todos que podem ser utilizados por qualquer outra classe, sem causar inconsist√™ncias no desenvolvimento de um c√≥digo.

Na pr√°tica, isso √© feito por meio de dois m√©todos: os getters e os setters, que forma vistos no t√≥pico anterior. Os M√©todos getters tem por objetivo retornar o valor que lhe foi pedido, mas de forma a n√£o prejudicar a integridade do dado em si, enquanto os M√©todos setters recebem como argumento uma informa√ß√£o, que pode ser qualquer tipo de dado suportados pela linguagem. Dessa forma, n√£o haver√° o risco de ocorrerem acessos indevidos. Veja o exemplo abaixo:

Na Classe Conta, al√©m dos M√©todos Construtor, Getters e Setters, n√≥s vamos criar um M√©todo para sacar um valor da conta. Se os atributos puderem ser acessados diretamente em qualquer trecho do c√≥digo, haver√° o risco de o saldo ser alterado sem passar pelo m√©todo sacar(). Para evitar isso, podemos usar os m√©todos get e set para evitar o acesso direto. Logo, **para proteger os atributos da Classe, principalmente o saldo, utilizamos os m√©todos get saldo e set saldo**. 

**Quais as vantagens de encapsular?**

Com base no fato de que o encapsulamento evita o acesso indevido a alguns tipos de dados, diversas vantagens podem ser notadas, entre elas podemos destacar:

- **Manuten√ß√£o de c√≥digo:** Com o encapsulamento, **isso passa a ser mais f√°cil, uma vez que, com a devida prote√ß√£o de acesso aos dados**, a pessoa desenvolvedora achar√° mais r√°pido algum ponto onde o c√≥digo precisa ser melhorado. Sem o encapsulamento, seria bem dif√≠cil encontrar os pontos de inconsist√™ncia do c√≥digo.
- **Reuso de c√≥digo:** Com o encapsulamento, **o programa ter√° mais chances de ter o c√≥digo reaproveitado** em outros projetos, poupando bastante tempo da equipe de desenvolvimento.
- **Desenvolvimento acelerado e simplificado:** O encapsulamento transforma a implementa√ß√£o de alguns c√≥digos em uma esp√©cie de caixa preta. Na pr√°tica, isso significa que **as classes externas n√£o precisam acessar alguns dados de forma direta.** Assim, o desenvolvimento dos sistemas passa a ficar simplificado e acelerado.

<br />

<h2>7. Instanciando um Objeto</h2>

Para instanciar Objetos da Classe Conta, n√≥s utilizaremos uma outra Classe chamada Menu. Nesta Classe n√≥s iremos implementar um velho conhecido de voc√™s: O M√©todo main()!

## <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/> Exemplo 04: Instanciar Objetos da Classe Conta

```java
package conta;

import conta.model.Conta;

public class Menu {

	public static void main(String[] args) {
		
	  	Conta c1 = new Conta(123456, 123, 1, "Maria dos Santos", 2500.0f);
    	c1.visualiza();
    
    	Conta c2 = new Conta(123456, 123, 1, "Jo√£o da Silva", 2000.0f);
    	c2.visualiza();
    
    	c1.setSaldo(100000.0f);
    	c1.setTitular("Maria Joaquina");
    	c1.visualiza();

	}

}
```

Observe que foram criados 2 Objetos (c1 e c2) do tipo Conta. Para instanciar os Objetos, o M√©todo Construtor foi chamados atrav√©s da palavra reservada **new**. 

Para acessar os M√©todos da Classe Conta, utiliza-se o padr√£o **objeto.m√©todo()**. 

**Exemplo:** 

```java
c1.visualizar();
```

Observe que os 2 M√©todos set foram utilizados para alterar os dados no Objeto c1.

**Exemplo:** 

```java
c1.setSaldo(100000.0f);
c1.setTitular("Maria Joaquina");
```

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html" target="_blank"><b>Documenta√ß√£o: Instanciando Objetos</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.w3schools.com/java/ref_keyword_new.asp" target="_blank"><b>Documenta√ß√£o: Palavra reservada new</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/usingobject.html" target="_blank"><b>Documenta√ß√£o: Usando Objetos</b></a></div>

<br /><br />

------

## üîë**Pontos chave:**

1. **Programa√ß√£o Orientada a Objetos** (POO) **√© um paradigma de programa√ß√£o que ajuda a definir a estrutura de programas de computadores, baseado nos conceitos do mundo real, sejam eles reais ou abstratos.** A ideia √© simular as coisas que existem e acontecem no mundo real no mundo virtual.
2. Um **Objeto** √© uma abstra√ß√£o utilizada no desenvolvimento de software para representar um objeto da vida real, que possui estados e comportamentos. Os objetos de software costumam ser utilizados para modelar objetos do mundo real encontrados no cotidiano. 
3. Uma **Classe** √© uma planta ou prot√≥tipo a partir do qual os objetos s√£o criados. Basicamente, as classes modelam as caracter√≠sticas e as a√ß√µes de um objeto (estado e comportamento), com **atributos** e **m√©todos**.
4. Objetos s√£o **instanciados** a partir das classes. Eles t√™m valores atribu√≠dos a seus atributos e executam a√ß√µes (ou as a√ß√µes s√£o executadas neles) por meio de m√©todos.
5. Para criar (instanciar) um novo Objeto de uma Classe, precisamos implementar um M√©todo para gerar este novo Objeto. O M√©todo respons√°vel por esta tarefa em uma Classe √© o **M√©todo Construtor**. 
6. Os m√©todos **SET** servem para modificar os atributos. Eles s√£o chamados de setters. Se o nome do atributo √© nome, o nome do setter ser√° setIdade( int idade).
7. Os m√©todos **GET** servem para ler os dados dos atributos. Eles tamb√©m s√£o chamados de getters. Se o nome do atributo √© nome, o nome do getter ser√° getNome().
8. **Encapsular**, nada mais √© do que proteger membros de uma classe de acesso externo, permitindo somente sua manipula√ß√£o de forma indireta. 
9. Encapsular os dados de uma aplica√ß√£o significa evitar que estes sofram acessos indevidos. Para isso, √© criada uma estrutura que cont√©m m√©todos que podem ser utilizados por qualquer outra classe (GET e SET), sem causar inconsist√™ncias no desenvolvimento de um c√≥digo.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>