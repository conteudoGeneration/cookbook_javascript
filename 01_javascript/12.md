<h1>Collections (Cole√ß√µes)</h1>



A linguagem TypeScript/JavaScript suporta arrays para armazenar v√°rios objetos, entretanto, quando uma matriz comum √© inicializada, ela √© definida com um tamanho pr√©-definido durante o processo de instancia√ß√£o, como vimos  anteriormente. Esta limita√ß√£o causa alguns problemas para n√≥s pessoas desenvolvedoras, pois quando estamos trabalhando com grandes volumes de dados, fica muito dif√≠cil mensurar o n√∫mero de Objetos que iremos armazenar em uma Matriz. Para suportar estruturas de dados mais flex√≠veis, ou seja, sem tamanho pr√©-definido, o TypeScript/JavaScript nos fornece algumas Classes, que permitem implementar Cole√ß√µes de dados Din√¢micas. 

Uma Cole√ß√£o √© uma Estrutura de Dados que cont√©m e processa um conjunto de dados. Os dados armazenados na cole√ß√£o s√£o encapsulados e o acesso aos dados geralmente √© efetuado por meio de m√©todos predefinidos. 

**Exemplo:** A pessoa desenvolvedora pode adicionar elementos a uma cole√ß√£o por meio de um m√©todo. 

As cole√ß√µes usam Matrizes internas para o armazenamento, mas ocultam da pessoa desenvolvedora a complexidade de gerenciar o tamanho da Matriz de forma din√¢mica, entre outros detalhes da implementa√ß√£o.

As Cole√ß√µes oferecem diversas formas de armazenar os dados com base em fatores como:

- Efici√™ncia no acesso, na busca ou na inser√ß√£o;
- Forma de organiza√ß√£o dos dados;
- Forma de acesso, busca e inser√ß√£o dos dados

<br />

<h2>1. Collections</h2>



Nativamente, o TypeScript/JavaScript possui apenas 2 **Collections**:

- Set
- Map

Al√©m de falarmos destas duas Cole√ß√µes, vamos nos aprofundar tamb√©m na Classe **Array**, que oferece uma nova forma de criar arrays, semelhante as Collections, trazendo M√©todos de intera√ß√£o com esta Estrutura de Dados.

A Classe **Array** funciona da mesma forma que um Array tradicional: **Todos os elementos s√£o ordenados  sequencialmente**. Para acessar um determinado elemento da lista, utilizamos o n√∫mero do √≠ndice, que indica a posi√ß√£o onde o elemento est√° armazenado. Um dos grande benef√≠cios do arrays √© que o usu√°rio tem controle total sobre qual elemento e onde este elemento est√° inserido na lista. O M√©todo Construtor da Classe Array permite criar um array com tamanho fixo ou din√¢mico, al√©m de definir o tipo de dado que ser√° armazenado no array, que pode ser primitivo ou objeto. 

Fazendo uma analogia com Blocos de montar, um **Array** seria como uma sequ√™ncia de blocos numerados (√≠ndices), como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/sFd31TP.png" title="source: imgur.com" /></div>

<br />

A Collection **Set** √© uma estrutura de dados que modela a defini√ß√£o matem√°tica de um conjunto de dados. Um set √© uma cole√ß√£o de elementos √∫nicos de um tipo de dado espec√≠fico, ou seja, n√£o aceita elementos repetidos. O Set √© tamb√©m uma cole√ß√£o ordenada de elementos, o que significa que os elementos ser√£o recuperados na mesma ordem em que foram inseridos.

Fazendo uma analogia com Blocos de montar, um **Set** seria como uma cole√ß√£o de blocos, ou seja, um conjunto, sem elementos repetidos, ordenados na sequ√™ncia em que foram inseridos, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/aljQPOv.png" title="source: imgur.com" /></div>

<br />

A Collection **Map** √© uma cole√ß√£o de elementos do tipo pares chave-valor, onde a chave possui um tipo espec√≠fico. O Map sempre mant√©m a ordem original em que os elementos foram adicionados a ele, o  que significa que os dados podem ser recuperados na mesma ordem em que  foram inseridos.

Em outras palavras, o Map tem caracter√≠sticas tanto do objeto quanto do array:

- Como um objeto, ele suporta a estrutura de pares chave-valor.
- Como um array, ele se lembra da ordem de inser√ß√£o dos elementos.

Fazendo uma analogia com Blocos de montar, um **Map** seria como uma cole√ß√£o de blocos ordenados sequencialmente, onde cada elemento possui uma Chave e um Valor, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/phPlevk.png" title="source: imgur.com" /></div>

<br />

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Indexed_collections" target="_blank"><b>Documenta√ß√£o: Collections Indexadas</b></a></div>

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Keyed_collections" target="_blank"><b>Documenta√ß√£o: Collections Chave-Valor</b></a></div>

<br />

<h2>2. A Classe Array</h2>



Em nosso curso, vamos estudar mais a fundo a Classe Array, por se tratar de uma escolha natural quando for necess√°rio usar uma estrutura sequencial redimension√°vel indexada,  o que a torna ideal para o acesso aleat√≥rio aos dados armazenados.

**Sintaxe - Array sem inicializa√ß√£o de dados:**

```ts
const nome_do_array: Array<T> = new Array<T>()
```

O construtor sem argumentos padr√£o cria um novo array vazio.

O item **`<T>`** representa um **Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado no array. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma **Classe criada pela pessoa desenvolvedora**.

**Sintaxe - Array com inicializa√ß√£o de dados:**

```ts
const nome_do_array: Array<T> = new Array<T>(elemento01, elemento02, ..., elementoN);
```

Dentro dos parenteses, podemos inserir quantos elementos forem necess√°rios.

O item **`<T>`** representa um **Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado no array. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma **Classe criada pela pessoa desenvolvedora**.

<br />

<h3>3.1. Principais M√©todos da Classe Array</h3>



Na tabela abaixo, listamos os principais M√©todos da Classe Array:

| M√©todo                                    | Descri√ß√£o                                                    |
| ----------------------------------------- | ------------------------------------------------------------ |
| **length()**                              | Retorna o tamanho do array                                   |
| **push(elemento)**                        | Adiciona novos elementos e retorna o novo comprimento do array |
| **unshift(elementos)**                    | Adiciona um ou mais elementos ao in√≠cio do array             |
| **splice(indice, quantidade, elementos)** | Adiciona ou Remove elementos de um array.<br />O primeiro par√¢metro informa o √≠ndice do elemento inicial.<br />O segundo par√¢metro informa quantos elementos ser√£o removidos ou adicionados a partir do √≠ndice informado no primeiro par√¢metro.<br />O terceiro par√¢metro √© a lista de elementos que ser√£o inseridos, separados por virgula. No caso de uma exclus√£o este par√¢metro ser√° vazio. |
| **shift()**                               | Remove e retorna o primeiro elemento do array                |
| **pop()**                                 | Remove o √∫ltimo elemento do array e retorna esse elemento    |
| **sort()**                                | Classifica todos os elementos do array em ordem crescente    |
| **reverse()**                             | Classifica todos os elementos do array em ordem decrescente  |
| **includes(elemento)**                    | Verifica se o array cont√©m um determinado elemento           |
| **indexOf(elemento)**                     | Retorna o √≠ndice da primeira correspond√™ncia de um valor no array (-1 se n√£o for encontrado) |
| **lastIndexOf(elemento)**                 | Retorna o √∫ltimo √≠ndice de um elemento do array              |

*Assim como no array tradicional, o √≠ndice sempre inicia em 0.*

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 01 - Array:



No exemplo abaixo, vamos construir um array com a Classe Array, chamada **notas**, contendo uma lista de notas. Na sequ√™ncia faremos alguns testes com os M√©todos da Classe Array.

```ts
// Cria um array, do tipo number, chamado notas e inicializa
const notas: Array<number> = new Array<number>(7.0, 5.0, 4.0, 10.0);

/* Mostra na tela todas as notas adicionadas.
   Observe que para exibir as notas utilizamos 
   o La√ßo for..of */

console.log("\nNotas cadastradas: ");

for(let nota of notas){

    console.log(nota.toFixed(1));

}

/*Adiciona uma nova Nota - duplicada */
notas.push(4.0);

/**
 * Exibe na tela todas as notas, 
 * inclusive a nota duplicada.
 */
console.log("\nNotas cadastradas: ");

for(let nota of notas){

    console.log(nota.toFixed(1));

}

/*Adiciona v√°rias notas no in√≠cio do array */
notas.unshift(2.5, 9.0);

/**
 * Exibe na tela todas as notas.
 */
console.log("\nNotas cadastradas: ");

for(let nota of notas){

    console.log(nota.toFixed(1));

}

/**
 * Mostra a posi√ß√£o (indice) de uma determinada nota. 
 * Caso existam 2 notas iguais ser√° exibida a posi√ß√£o 
 * da primeira nota encontrada.
 */
console.log("\nA posi√ß√£o da nota 5 √©: " + notas.indexOf(5));

// Mostra se uma determinada nota existe no array
console.log("\nA nota 5 existe no array? " + notas.includes(5));

// Mostra a nota inserida em uma determinada posi√ß√£o (indice)
console.log("\nNa posi√ß√£o 1 da array, a nota √©: " + notas[1]);

// Altera a nota 5.0 para 6.0 e mostra que a altera√ß√£o foi efetuada
notas[notas.indexOf(5)] = 6.0;

console.log("\nA nota 5 foi alterada para 6: ");

for(let nota of notas){

    console.log(nota.toFixed(1));

}

/**
 *  Apaga a nota 4.0 e mostra que a exclus√£o foi efetuada.
 *  Observe que apenas a primeira nota 4.0 foi apagada.
 */
notas.splice(notas.indexOf(4.0), 1);

console.log("\nA 1¬∫ nota 4 foi apagada? ");

for(let nota of notas){

    console.log(nota.toFixed(1));

}

// Exibe o tamanho do array (numero de elementos)
console.log("\nO tamanho do array √©: " + notas.length);

// Limpa o array e mostra que ele est√° vazio
notas.length = 0;

console.log("\nO array est√° vazio!");

console.log("\nO tamanho do array √©: " + notas.length);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Notas cadastradas: 
7.0
5.0
4.0
10.0

Notas cadastradas: 
7.00
5.00
4.00
10.00
4.00

Notas cadastradas:
2.50
9.00
7.00
5.00
4.00
10.00
4.00

A posi√ß√£o da nota 5 √©: 3

A nota 5 existe no array? true

Na posi√ß√£o 1 da array, a nota √©: 9

A nota 5 foi alterada para 6:
2.50
9.00
7.00
6.00
4.00
10.00
4.00

A 1¬∫ nota 4 foi apagada?
2.50
9.00
7.00
6.00
10.00
4.00

O tamanho do array √©: 6

O array est√° vazio!

O tamanho do array √©: 0
```

<br />

<h3>Como o Array ir√° armazenar os dados?</h3>

Na imagem abaixo, temos uma representa√ß√£o gr√°fica do Array **notas**:

 <div align="left"><img src="https://i.imgur.com/9rC5Knx.png" /></div>

Observe que o Array **notas**, √© do tipo **number** e cada novo elemento (n√∫mero) ser√° adicionado em uma linha do Array. Assim como os vetores, cada linha √© identificada por um n√∫mero inteiro (√≠ndice).

O Array sempre respeita a ordem em que o Objeto foi inserido, ou seja, a cada novo Objeto inserido, uma nova linha ser√° criada ap√≥s o √∫ltimo Objeto adicionado.

<br />

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank"><b>Documenta√ß√£o: Classe Array</b></a></div>

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Array" target="_blank"><b>Documenta√ß√£o: M√©todo Array()</b></a></div>

<br />

<h2>3. A Collection Set</h2>



A Collection **Set** √© uma cole√ß√£o de elementos ordenados pela sequ√™ncia de inser√ß√£o, que n√£o permite o armazenamento de valores duplicados, ou seja, apenas valores √∫nicos. 

Como qualquer outro objeto em TypeScript/JavaScript, existem regras sobre como os conjuntos funcionam e como s√£o usados. Conjuntos s√£o objetos de dados que cont√™m uma cole√ß√£o de valores exclusivos. Os conjuntos podem conter dados de qualquer tipo, mas n√£o podem conter itens duplicados. No caso de adicionar itens duplicados e iguais, apenas a primeira inst√¢ncia ser√° salva no conjunto. 

A Collection Set n√£o possui um M√©todo para obter um Objeto a partir do seu √≠ndice, como vimos no Array, porque na Collection Set os elementos n√£o s√£o indexados. 

Os benef√≠cios de usar uma Collection Set se resumem aos benef√≠cios de otimiza√ß√£o e desempenho nas opera√ß√µes de busca. A Collection Set √© implementada internamente como tabela hash ou como uma √°rvores de pesquisa dependendo da implementa√ß√£o, que nos fornecem um tempo de pesquisa constante. Portanto, se voc√™ estiver trabalhando com uma grande cole√ß√£o de valores e estiver preocupado apenas com os valores √∫nicos, usar um Set √© sua melhor escolha.

> **Tabelas Hash (Hash Tables)** s√£o estruturas de dados que v√£o permitir que  voc√™ crie uma lista de valores pareados. Voc√™ pode, ent√£o, recuperar  determinado valor usando a respectiva chave para aquele valor, que voc√™  coloca na tabela de antem√£o. Uma *hash table* transforma uma chave em um n√∫mero inteiro, que serve como √≠ndice, usando uma fun√ß√£o *hash*. Esse √≠ndice decidir√° onde armazenar na mem√≥ria o par chave/valor.
>
> Uma **√Årvore de Pesquisa** √© uma estrutura de dados em forma de √°rvore bin√°ria baseada em n√≥s, onde todos os n√≥s da  sub-√°rvore esquerda possuem  um valor num√©rico inferior ao n√≥ raiz e  todos os n√≥s da sub-√°rvore direita possuem um valor superior ao n√≥ raiz.

<br />

**Sintaxe da Collection Set sem a inicializa√ß√£o de dados:**

```ts
const nome_do_set: Set<T> = new Set<T>()
```

O construtor sem argumentos padr√£o cria um novo array vazio.

O item **`<T>`** representa um **Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado no Set. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma **Classe criada pela pessoa desenvolvedora**.

**Sintaxe da Collection Set com inicializa√ß√£o de dados:**

```ts
const nome_do_set: Set<T> = new Set<T>(elemento01, elemento02, ..., elementoN);
```

Dentro dos par√™nteses, podemos inserir quantos elementos forem necess√°rios, lembrando que os elementos  repetidos ser√£o inseridos apenas uma vez.

O item **`<T>`** representa um **Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado no Set. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma **Classe criada pela pessoa desenvolvedora**.

<br />

<h3>4.1. M√©todos da Collection Set</h3>

Na tabela abaixo, listamos os principais M√©todos para trabalharmos com a Collection HashSet:

| **M√©todo / Propriedade** | **Descri√ß√£o**                                                |
| ------------------------ | ------------------------------------------------------------ |
| **add(Elemento)**        | Adiciona um elemento no Set.                                 |
| **delete(Elemento)**     | Apaga  um elemento armazenado no Set.                        |
| **clear()**              | Limpa  o Set, removendo todos os elementos.                  |
| **size**                 | Retorna  o tamanho do Set (numero de elementos armazenados). |
| **has(Elemento)**        | Retorna  `true` se  o elemento existir no Set.               |

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 02 - Collection Set:

No exemplo abaixo, vamos construir uma Collection Set, chamada **setFrutas**, contendo uma lista de frutas. As frutas ser√£o do tipo string e faremos alguns testes com os M√©todos da Collection Set.

```ts

// Cria a Collection Set, do tipo string, chamada frutas e inicializa
const setFrutas: Set<string> = new Set<string>(["Abacate", "Banana", "Jaboticaba", "Kiwi", "Ma√ß√£", "Morango", "P√™ra", "Jaboticaba"]);

/* Mostra na tela todas as frutas adicionadas.
   Observe que para exibir as frutas utilizamos 
   o La√ßo for..of */

console.log("\nFrutas cadastradas: ");

for(let fruta of setFrutas)
{
    console.log(fruta);
}

/*Adiciona novas Frutas*/
setFrutas.add("Kiwi");
setFrutas.add("Pitaya");
setFrutas.add("Amora");
setFrutas.add("Caju");

/**
 * Mostra os dados armazenados na Collection Set Observe 
 * que a fruta repetida n√£o foi inserida novamente
 */
console.log("\nFrutas cadastradas: ");

for(let fruta of setFrutas)
{
    console.log(fruta);
}

// Verifica se um elemento est√° armazenado na Collection Set
console.log("\nExiste a fruta Kiwi? " + setFrutas.has("Kiwi"));

// Remove um elemento da Collection
setFrutas.delete("Kiwi");

console.log("\nKiwi foi removida!\n");

for(let fruta of setFrutas)
{
    console.log(fruta);
}

// Verifica ap√≥s a remo√ß√£o se o elemento ainda existe na Collection Set
console.log("\nExiste a fruta Kiwi na Collection? " + setFrutas.has("Kiwi"));

// Limpa a Collection Set
setFrutas.clear();

console.log("\nTodos os itens foram removidos da Collection Set!");

console.log("\nTamanho do set: " + setFrutas.size);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Frutas cadastradas:
Abacate
Banana
Jaboticaba
Kiwi
Ma√ß√£
Morango
P√™ra

Frutas cadastradas:
Abacate
Banana
Jaboticaba
Kiwi
Ma√ß√£
Morango
P√™ra
Pitaya
Amora
Caju

Existe a fruta Kiwi? True

Kiwi foi removida!

Abacate
Banana
Jaboticaba
Ma√ß√£
Morango
P√™ra
Pitaya
Amora
Caju

Existe a fruta Kiwi na Collection? False

Todos os itens foram removidos da Collection Set!
```

<br />

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="5%"/> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank"><b>Documenta√ß√£o: Collection HashSet</b></a></div>

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="https://github.com/rafaelq80/exemplos_js/tree/main/typescript/collections" target="_blank"><b>C√≥digo Fonte dos Exemplos</b></a></div>

<br />

------

## üîë**Pontos chave:**

- **Collection (cole√ß√£o)** √© uma Estrutura de Dados que cont√©m e processa um conjunto de dados. Os dados armazenados na cole√ß√£o s√£o encapsulados e o acesso aos dados geralmente √© efetuado por meio de m√©todos predefinidos.
- **Array** √© uma estrutura de dados que armazena uma cole√ß√£o de elementos de tal forma que cada um dos elementos possa ser identificado por, pelo menos, um √≠ndice ou uma chave.
- A **Classe Array** oferece uma forma diferente de se criar o array tradicional, al√©m de oferecer uma s√©rie de m√©todos para manipular os elementos do array.
- **Set** √© um tipo de estrutura de dados que armazena valores exclusivos do mesmo tipo (sem duplicatas)
- **Map** √© um tipo de estrutura de dados utilizado para a pesquisa r√°pida de dados. Ele armazena dados na forma de pares de chave-valor.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>