<h1>Collections (Cole√ß√µes)</h1>



Em JavaScript/TypeScript, **Objetos** s√£o utilizados para os mais variados fins, entre eles armazenar m√∫ltiplos valores, incluindo uma Estrutura de Dados complexa. 

**Estruturas de Dados** s√£o uma forma de organizar e armazenar dados em computadores, de forma que possamos realizar opera√ß√µes com mais efici√™ncia.

**Uma Cole√ß√£o √© uma Estrutura de Dados, armazenada em um Objeto, que cont√©m e processa um conjunto de dados. Os dados armazenados na cole√ß√£o s√£o encapsulados e o acesso aos dados geralmente √© efetuado por meio de m√©todos predefinidos.** 

**Exemplo:** A pessoa desenvolvedora pode adicionar elementos a uma cole√ß√£o por meio de um m√©todo. 

Na pr√°tica, as Cole√ß√µes oferecem formas diferentes de armazenar os dados, com base em fatores como:

- Efici√™ncia no acesso, na busca ou na inser√ß√£o;
- Forma de organiza√ß√£o dos dados;
- Forma de acesso, busca e inser√ß√£o dos dados

<br />

<h2>1. Collections</h2>



**No JavaScript/TypeScript, uma cole√ß√£o √© um Objeto utilizado para armazenar um grupo de dados**. No caso do JavaScript, uma cole√ß√£o de dados, que pode conter v√°rios tipos de dados. No caso do TypeScript, uma cole√ß√£o que pode conter dados de apenas um √∫nico tipo de dado (Primitivo ou Objeto).

No JavaScript/TypeScript, existem 2 tipos principais de Cole√ß√µes:

- **Cole√ß√µes Indexadas (Indexed Collections)**
- **Cole√ß√µes com Chave (Keyed Collections)**

<br />

<h3>1.1. Cole√ß√µes Indexadas (Indexed Collections)</h3>



Uma cole√ß√£o indexada cont√©m dados que s√£o ordenados por √≠ndice e tamb√©m podem ser acessados usando este √≠ndice. Um √≠ndice significa a posi√ß√£o dos dados. 

<br />

<h3>1.2. Cole√ß√µes com Chave (Keyed Collections)</h3>



Uma cole√ß√£o com chave cont√©m dados ordenados por chaves, ao inv√©s de um √≠ndice. Al√©m disso, os dados s√£o organizados em pares do tipo chave-valor.

<br />

<h2>2. Collections da Linguagem JavaScript/TypeScript</h2>



Nativamente, o JavaScript/TypeScript possui apenas 3 **Collections**:

- **Array**
- **Set**
- **Map**

A **Collection Array** √© um **objeto global** que representa um **array tradicional**, ou seja, **uma cole√ß√£o de dados indexada**, onde os elementos s√£o armazenados em posi√ß√µes espec√≠ficas (√≠ndices) e ordenados sequencialmente. Para acessar ou manipular um elemento em um array, utilizamos o √≠ndice correspondente, que representa sua posi√ß√£o dentro da estrutura.

Um dos grandes benef√≠cios da **Collection Array** √© o controle total que ela oferece ao desenvolvedor. Por meio de diversos m√©todos nativos, √© poss√≠vel:

- Adicionar, remover ou atualizar elementos;
- Iterar sobre os dados de maneira eficiente;
- Buscar elementos com base em crit√©rios espec√≠ficos.

O m√©todo construtor do objeto **`Array()`** permite criar arrays de duas formas principais:

1. **Com um tamanho inicial predefinido:** Define a capacidade inicial do array, que se expande dinamicamente conforme novos elementos s√£o adicionados.
2. **Com elementos j√° atribu√≠dos:** Inicia o array diretamente com valores.

No **TypeScript**, o diferencial est√° na possibilidade de definir o **tipo de dado** armazenado no array. Esse tipo pode ser:

- **Tipos primitivos:** como `string`, `number`, ou `boolean`;
- **Objetos complexos:** como classes ou interfaces personalizadas.

Fazendo uma analogia com Blocos de montar, um **Array** seria como uma sequ√™ncia de blocos numerados (√≠ndices), como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/sFd31TP.png" title="source: imgur.com" /></div>

<br />

A **Collection Set** √© uma **estrutura de dados √∫nica** que modela a defini√ß√£o matem√°tica de um **conjunto de elementos**. Em ess√™ncia, um **Set** √© uma cole√ß√£o de valores **n√£o duplicados**, ou seja, ele n√£o aceita elementos repetidos. Cada elemento armazenado no Set √© tratado como √∫nico dentro da cole√ß√£o.

No caso do **TypeScript**, o Set pode ser utilizado para armazenar valores de um tipo de dado espec√≠fico, garantindo maior consist√™ncia no c√≥digo. Al√©m disso, o **Set** √© uma **cole√ß√£o ordenada**, o que significa que os elementos s√£o recuperados na mesma ordem em que foram adicionados. Embora o Set n√£o utilize **chave-valor** como os objetos ou Maps, ele segue o princ√≠pio de tratar cada elemento como **chave e valor iguais**.

Fazendo uma analogia com Blocos de montar, um **Set** seria como uma cole√ß√£o de blocos, ou seja, um conjunto, sem elementos repetidos, ordenados na sequ√™ncia em que foram inseridos, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/aljQPOv.png" title="source: imgur.com" /></div>

<br />

A **Collection Map** √© uma **estrutura de dados chave-valor** que armazena elementos por meio de um par **chave-valor**. Cada **chave** pode ter um tipo de dado espec√≠fico no **TypeScript**, o que proporciona vantagens em termos de seguran√ßa de tipos. O **Map** sempre mant√©m a **ordem original** na qual os elementos foram adicionados, garantindo que os dados sejam recuperados na mesma sequ√™ncia em que foram inseridos.

Fazendo uma analogia com Blocos de montar, um **Map** seria como uma cole√ß√£o de blocos ordenados sequencialmente, onde cada elemento possui uma Chave e um Valor, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/phPlevk.png" title="source: imgur.com" /></div>

<br />

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Indexed_collections" target="_blank"><b>Documenta√ß√£o: Collections Indexadas</b></a></div>

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Keyed_collections" target="_blank"><b>Documenta√ß√£o: Collections Chave-Valor</b></a></div>

<br />

<h2>3. A Cole√ß√£o Array</h2>



Em nosso curso, vamos estudar mais a fundo a Cole√ß√£o Array, por se tratar de uma escolha natural quando √© necess√°rio usar uma estrutura sequencial redimension√°vel indexada, o que a torna ideal para o acesso aleat√≥rio aos dados armazenados.

**Sintaxe - Array sem inicializa√ß√£o de dados:**

```ts
const nome_do_array: Array<T> = new Array<T>()
```

O construtor sem argumentos padr√£o cria um novo array vazio.

O item **`<T>`** representa um **Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado no array. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma **Classe criada pela pessoa desenvolvedora**.

**Sintaxe - Array com inicializa√ß√£o de dados:**

```ts
const nome_do_array: Array<T> = new Array<T>(elemento01, elemento02, ..., elementoN);
```

Dentro dos parenteses, podemos inserir quantos elementos forem necess√°rios.

O item **`<T>`** representa um **Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado no array. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma **Classe criada pela pessoa desenvolvedora**.

<br />

<h3>3.1. Principais M√©todos do Objeto Array</h3>



Na tabela abaixo, listamos os principais M√©todos do Objeto Array:

| M√©todo                                    | Descri√ß√£o                                                    |
| ----------------------------------------- | ------------------------------------------------------------ |
| **length()**                              | Retorna o tamanho do array                                   |
| **push(elemento)**                        | Adiciona um ou mais elementos  no final do array e retorna o novo comprimento do array. |
| **unshift(elementos)**                    | Adiciona um ou mais elementos ao in√≠cio do array             |
| **splice(indice, quantidade, elementos)** | Adiciona ou Remove elementos de um array.<br />O primeiro par√¢metro informa o √≠ndice do elemento inicial.<br />O segundo par√¢metro informa quantos elementos ser√£o removidos ou adicionados a partir do √≠ndice informado no primeiro par√¢metro.<br />O terceiro par√¢metro √© a lista de elementos que ser√£o inseridos, separados por virgula. No caso de uma exclus√£o este par√¢metro ser√° vazio. |
| **shift()**                               | Remove e retorna o primeiro elemento do array                |
| **pop()**                                 | Remove o √∫ltimo elemento do array e retorna esse elemento    |
| **sort()**                                | Classifica todos os elementos do array em ordem crescente, por ordem lexicogr√°fica |
| **reverse()**                             | Inverte a ordem de classifica√ß√£o de todos os elementos do array. <br />Se o array estiver classificado em ordem crescente, por exemplo, o m√©todo classificar√° os elementos em ordem decrescente. |
| **includes(elemento)**                    | Verifica se um determinado elemento existe dentro do array. <br />Caso o elemento procurado exista em mais de uma posi√ß√£o do array, o m√©todo trar√° a primeira correspond√™ncia do elemento. |
| **indexOf(elemento)**                     | Retorna o √≠ndice da primeira correspond√™ncia de um valor no array (-1 se n√£o for encontrado) |
| **lastIndexOf(elemento)**                 | Retorna o √∫ltimo √≠ndice de um elemento do array              |

*O √≠ndice sempre inicia em 0.*

<br />

> **Ordem Lexicogr√°fica** √© a ordem em que as palavras aparecem em um dicion√°rio. H√° quem diga ordem alfab√©tica, mas isso n√£o est√° correto.

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 01 - Array:



No exemplo abaixo, vamos construir um array com o Objeto Array, chamado **notas**, contendo uma lista de notas. Na sequ√™ncia faremos alguns testes com os M√©todos do Objeto Array.

```ts
// Cria um array, do tipo number, chamado notas e inicializa
const notas: Array<number> = new Array<number>(7.0, 5.0, 4.0, 10.0);

/* Mostra na tela todas as notas adicionadas.
   Observe que para exibir as notas utilizamos 
   o La√ßo for..of */

console.log("\nNotas cadastradas: ");

for(let nota of notas){

    console.log(nota.toFixed(1));

}

/*Adiciona uma nova Nota - duplicada */
notas.push(4.0);

/**
 * Exibe na tela todas as notas, 
 * inclusive a nota duplicada.
 */
console.log("\nNotas cadastradas: ");

for(let nota of notas){

    console.log(nota.toFixed(1));

}

/*Adiciona v√°rias notas no in√≠cio do array */
notas.unshift(2.5, 9.0);

/**
 * Exibe na tela todas as notas.
 */
console.log("\nNotas cadastradas: ");

for(let nota of notas){

    console.log(nota.toFixed(1));

}

/**
 * Mostra a posi√ß√£o (indice) de uma determinada nota. 
 * Caso existam 2 notas iguais ser√° exibida a posi√ß√£o 
 * da primeira nota encontrada.
 */
console.log("\nA posi√ß√£o da nota 5 √©: " + notas.indexOf(5));

// Mostra se uma determinada nota existe no array
console.log("\nA nota 5 existe no array? " + notas.includes(5));

// Mostra a nota inserida em uma determinada posi√ß√£o (indice)
console.log("\nNa posi√ß√£o 1 da array, a nota √©: " + notas[1]);

// Altera a nota 5.0 para 6.0 e mostra que a altera√ß√£o foi efetuada
notas[notas.indexOf(5)] = 6.0;

console.log("\nA nota 5 foi alterada para 6: ");

for(let nota of notas){

    console.log(nota.toFixed(1));

}

/**
 *  Apaga a nota 4.0 e mostra que a exclus√£o foi efetuada.
 *  Observe que apenas a primeira nota 4.0 foi apagada.
 */
notas.splice(notas.indexOf(4.0), 1);

console.log("\nA 1¬∫ nota 4 foi apagada? ");

for(let nota of notas){

    console.log(nota.toFixed(1));

}

// Exibe o tamanho do array (numero de elementos)
console.log("\nO tamanho do array √©: " + notas.length);

// Limpa o array e mostra que ele est√° vazio
notas.length = 0;

console.log("\nO array est√° vazio!");

console.log("\nO tamanho do array √©: " + notas.length);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Notas cadastradas: 
7.0
5.0
4.0
10.0

Notas cadastradas: 
7.00
5.00
4.00
10.00
4.00

Notas cadastradas:
2.50
9.00
7.00
5.00
4.00
10.00
4.00

A posi√ß√£o da nota 5 √©: 3

A nota 5 existe no array? true

Na posi√ß√£o 1 da array, a nota √©: 9

A nota 5 foi alterada para 6:
2.50
9.00
7.00
6.00
4.00
10.00
4.00

A 1¬∫ nota 4 foi apagada?
2.50
9.00
7.00
6.00
10.00
4.00

O tamanho do array √©: 6

O array est√° vazio!

O tamanho do array √©: 0
```

<br />

<h3>Como o Array ir√° armazenar os dados?</h3>

Na imagem abaixo, temos uma representa√ß√£o gr√°fica do Array **notas**:

 <div align="left"><img src="https://i.imgur.com/9rC5Knx.png" /></div>

Observe que o Array **notas**, √© do tipo **number** e cada novo elemento (n√∫mero) ser√° adicionado em uma linha do Array. Assim como os vetores, cada linha √© identificada por um n√∫mero inteiro (√≠ndice).

O Array sempre respeita a ordem em que o Objeto foi inserido, ou seja, a cada novo Objeto inserido, uma nova linha ser√° criada ap√≥s o √∫ltimo Objeto adicionado.

<br />

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank"><b>Documenta√ß√£o: Objeto Array</b></a></div>

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Array" target="_blank"><b>Documenta√ß√£o: M√©todo Array()</b></a></div>

<br />

<h2>4. A Collection Set</h2>



A **Collection Set** √© uma **cole√ß√£o de elementos ordenados pela sequ√™ncia de inser√ß√£o, que n√£o permite valores duplicados, ou seja, armazena apenas valores √∫nicos**.

Como qualquer outro objeto em TypeScript/JavaScript, o **Set** possui regras espec√≠ficas sobre como funciona e √© utilizado. Ele √© um objeto de dados que cont√©m uma cole√ß√£o de valores exclusivos, ou seja, n√£o permite a duplica√ß√£o de itens. Caso um item duplicado seja adicionado, apenas a primeira inst√¢ncia ser√° mantida no conjunto.

Ao contr√°rio do **Array**, o **Set** n√£o possui um m√©todo para acessar um elemento diretamente pelo seu √≠ndice, pois seus elementos n√£o s√£o indexados.

Os principais benef√≠cios de usar uma **Collection Set** envolvem otimiza√ß√£o e desempenho nas opera√ß√µes de busca. Internamente, o **Set** √© implementado como uma tabela hash ou √°rvore de pesquisa, o que proporciona um tempo de busca constante. Portanto, se voc√™ estiver lidando com uma grande cole√ß√£o de valores e sua principal preocupa√ß√£o for garantir a unicidade dos itens, utilizar um **Set** √© a escolha ideal.

> **Tabelas Hash (Hash Tables)** s√£o estruturas de dados que permitem armazenar pares de chave-valor. Nelas, voc√™ pode recuperar um valor espec√≠fico usando a chave associada a ele, previamente inserida na tabela. Uma *hash table* transforma a chave em um n√∫mero inteiro, utilizando uma fun√ß√£o *hash*. Esse n√∫mero, chamado de √≠ndice, determina o local de armazenamento do par chave-valor na mem√≥ria.
>
> Uma **√Årvore de Pesquisa** √© uma estrutura de dados em forma de √°rvore bin√°ria, onde cada n√≥ possui um valor, e todos os n√≥s na sub-√°rvore esquerda t√™m valores inferiores ao n√≥ raiz, enquanto todos os n√≥s na sub-√°rvore direita t√™m valores superiores ao n√≥ raiz. Essa organiza√ß√£o permite uma busca eficiente de dados.

<br />

**Sintaxe da Collection Set sem a inicializa√ß√£o de dados:**

```ts
const nome_do_set: Set<T> = new Set<T>()
```

O construtor sem argumentos padr√£o cria um novo array vazio.

O item **`<T>`** representa um **Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado no Set. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma **Classe criada pela pessoa desenvolvedora**.

**Sintaxe da Collection Set com inicializa√ß√£o de dados:**

```ts
const nome_do_set: Set<T> = new Set<T>([elemento01, elemento02, ..., elementoN]);
```

Dentro dos par√™nteses, podemos inserir quantos elementos forem necess√°rios, lembrando que os elementos repetidos ser√£o inseridos apenas uma vez.

O item **`<T>`** representa um **Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado no Set. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma **Classe criada pela pessoa desenvolvedora**.

<br />

<h3>4.1. M√©todos da Collection Set</h3>



Na tabela abaixo, listamos os principais M√©todos para trabalharmos com a Collection Set:

| **M√©todo / Propriedade** | **Descri√ß√£o**                                               |
| ------------------------ | ----------------------------------------------------------- |
| **add(Elemento)**        | Adiciona um elemento no Set.                                |
| **delete(Elemento)**     | Apaga um elemento armazenado no Set.                        |
| **clear()**              | Limpa o Set, removendo todos os elementos.                  |
| **size**                 | Retorna o tamanho do Set (numero de elementos armazenados). |
| **has(Elemento)**        | Retorna  `true` se o elemento existir no Set.               |

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 02 - Collection Set:



No exemplo abaixo, vamos construir uma Collection Set, chamada **setFrutas**, contendo uma lista de frutas. As frutas ser√£o do tipo string e faremos alguns testes com os M√©todos da Collection Set.

```ts
// Cria a Collection Set, do tipo string, chamada frutas e inicializa
const setFrutas: Set<string> = new Set<string>(["Abacate", "Banana", "Jaboticaba", "Kiwi", "Ma√ß√£", "Morango", "P√™ra", "Jaboticaba"]);

/* Mostra na tela todas as frutas adicionadas.
   Observe que para exibir as frutas utilizamos 
   o La√ßo for..of */

console.log("\nFrutas cadastradas: ");

for(let fruta of setFrutas)
{
    console.log(fruta);
}

/*Adiciona novas Frutas*/
setFrutas.add("Kiwi");
setFrutas.add("Pitaya");
setFrutas.add("Amora");
setFrutas.add("Caju");

/**
 * Mostra os dados armazenados na Collection Set Observe 
 * que a fruta repetida n√£o foi inserida novamente
 */
console.log("\nFrutas cadastradas: ");

for(let fruta of setFrutas)
{
    console.log(fruta);
}

// Verifica se um elemento est√° armazenado na Collection Set
console.log("\nExiste a fruta Kiwi? " + setFrutas.has("Kiwi"));

// Remove um elemento da Collection
setFrutas.delete("Kiwi");

console.log("\nKiwi foi removida!\n");

for(let fruta of setFrutas)
{
    console.log(fruta);
}

// Verifica ap√≥s a remo√ß√£o se o elemento ainda existe na Collection Set
console.log("\nExiste a fruta Kiwi na Collection? " + setFrutas.has("Kiwi"));

// Limpa a Collection Set
setFrutas.clear();

console.log("\nTodos os itens foram removidos da Collection Set!");

console.log("\nTamanho do set: " + setFrutas.size);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Frutas cadastradas:
Abacate
Banana
Jaboticaba
Kiwi
Ma√ß√£
Morango
P√™ra

Frutas cadastradas:
Abacate
Banana
Jaboticaba
Kiwi
Ma√ß√£
Morango
P√™ra
Pitaya
Amora
Caju

Existe a fruta Kiwi? True

Kiwi foi removida!

Abacate
Banana
Jaboticaba
Ma√ß√£
Morango
P√™ra
Pitaya
Amora
Caju

Existe a fruta Kiwi na Collection? False

Todos os itens foram removidos da Collection Set!
```

<br />

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="5%"/> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank"><b>Documenta√ß√£o: Collection Set</b></a></div>

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="https://github.com/rafaelq80/exemplos_js/tree/main/typescript/collections" target="_blank"><b>C√≥digo Fonte dos Exemplos</b></a></div>

<br />

------

## üîë**Pontos chave:**

- **Collection (cole√ß√£o)** √© uma Estrutura de Dados que cont√©m e processa um conjunto de dados. Os dados armazenados na cole√ß√£o s√£o encapsulados e o acesso aos dados geralmente √© efetuado por meio de m√©todos predefinidos.
- **No JavaScript/TypeScript, uma cole√ß√£o √© um grupo de dados, armazenados em um Objeto**. 
- **Array** √© uma estrutura de dados que armazena uma cole√ß√£o de elementos de tal forma que cada um dos elementos possa ser identificado por, pelo menos, um √≠ndice ou uma chave.
- O **Objeto Array** oferece uma s√©rie de m√©todos para manipular os elementos do array.
- **Set** √© um tipo de estrutura de dados que armazena valores exclusivos do mesmo tipo (sem duplicatas)
- **Map** √© um tipo de estrutura de dados utilizado para a pesquisa r√°pida de dados. Ele armazena dados na forma de pares de chave-valor.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
