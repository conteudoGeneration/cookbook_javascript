<h1>Interfaces</h1>



Como vimos no conte√∫do sobre  Heran√ßa, o TypeScript permite a cria√ß√£o de uma Classe herdando as caracter√≠sticas de outra Classe, chamada Superclasse, com objetivo de simplificar o processo de desenvolvimento atrav√©s da reutiliza√ß√£o de c√≥digo.

Entretanto, a linguagem TypeScript n√£o permite que uma classe seja derivada de duas ou mais classes, como no exemplo demonstrado na figura abaixo, ou seja, TypeScript n√£o permite a utiliza√ß√£o do conceito de **Heran√ßa M√∫ltipla**.

```mermaid
classDiagram
class Automovel {
+ anda() 
}
class Barco {
+ navega() 
}
class Anfibio {
 
}

Automovel <|-- Anfibio
Barco <|-- Anfibio
```

> ‚Ä¢**Heran√ßa Simples** √© o princ√≠pio, implementado em todas as linguagens de programa√ß√£o orientadas a objetos, que possibilita o compartilhamento de atributos e opera√ß√µes de apenas uma classe em uma subclasse. 
>
> ‚Ä¢**Heran√ßa M√∫ltipla** √© o princ√≠pio, implementado em algumas linguagens de programa√ß√£o orientadas a objetos, como a liguagem C++ por exemplo, que possibilita o compartilhamento de atributos e opera√ß√µes de duas ou mais classes em uma subclasse, ou seja, uma classe pode ter mais de um superclasse.

Para contornar este fato, a Linguagem TypeScript oferece uma solu√ß√£o elegante para este fim: o conceito de **Interfaces**, onde um Objeto "implementa" as caracter√≠sticas de outro Objeto.

```mermaid
classDiagram
class Automovel {
+ anda() 
}
class VeiculoAquatico {
<< Interface >>
+ navega() 
}
class Anfibio {
 
}

Automovel <|-- Anfibio
VeiculoAquatico <-- Anfibio : Implementa
```

**Interface** √© uma estrutura que representa uma **Classe abstrata "pura"** em TypeScript, que **n√£o t√™m atributos de dados**, exceto quando utilizada para definir um tipo de dado, **n√£o tem construtor**, **todos os m√©todos s√£o abstratos** e **n√£o √© declarada como Classe, e sim como Interface**.

Uma Classe pode implementar v√°rias Interfaces, entretanto n√£o √© recomend√°vel implementar mais do que 3 Interfaces, porqu√™ pode criar uma complexidade desnecess√°ria ao projeto.

A Interface estabelece **um conjunto de M√©todos apenas assinados, ou seja, sem o corpo, que obrigatoriamente devem ser implementados nas Subclasses que a utiliza**. Abaixo vemos a sintaxe de como criar uma Interface:

```ts
export Interface nome_da_interface{
    // M√©todos da Interface
}
```

Abaixo vemos a sintaxe de como implementar uma Interface em uma Classe. Observe que as classes utilizam a palavra reservada **implements** na sua assinatura para implementar uma Interface.

```ts
export class nome_da_classe implements nome_da_interface{
    // Corpo da Classe
}
```

Vamos retomar o nosso exemplo, utilizado no conte√∫do sobre Classes Abstratas:

<div align="center"><img src="https://i.imgur.com/kC6TY2u.png" title="source: imgur.com" /></div>

Observe que **Corredor, Nadador e Ciclista** estendem (herdam) a Classe Atleta. 

Vamos acrescentar a **Classe Triatleta**.

<div align="center"><img src="https://i.imgur.com/qXuhfKj.png" title="source: imgur.com" /></div>

Na imagem acima, vemos que a Classe **Triatleta** estenderia (herdaria) as 3 Classes: **Corredor, Nadador e Ciclista**.

Teoricamente isto funcionaria, mas na pr√°tica n√£o, pois TypeScript **N√ÉO ACEITA HERAN√áA M√öLTIPLA**. Para resolvermos o problema, ter√≠amos que implementar o conceito de **Interfaces**, onde **Atleta, Nadador, Corredor e Ciclista**, seriam as nossas **Interfaces**, enquanto **Pessoa e Triatleta** seriam as √∫nicas classes, como vemos na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/a0gsk7E.png" title="source: imgur.com" /></div>

<br />

Abaixo, vemos o Diagrama de Classes do exemplo acima:

<img src="https://i.imgur.com/vGDOChv.png" title="source: imgur.com" width="3%"/>**Exemplo 01 - Diagrama de Classes** 

```mermaid
classDiagram
class Pessoa {
- nome: String
+ get nome()
+ set nome(string nome)
+ cansou(): void*
+ visualizar(): void
}
class Triatleta {
+ aquecer(): void
+ correr(): void
+ pedalar(): void
+ nadar(): void
+ cansou(): void
}
class Atleta {
<< Interface >>
+ aquecer(): void
}
class Ciclista {
<< Interface >>
+ pedalar(): void
}
class Corredor {
<< Interface >>
+ correr(): void
}
class Nadador {
<< Interface >>
+ nadar(): void
}
Pessoa <|-- Triatleta: << extends >>
Atleta <|-- Ciclista: << extends >>
Atleta <|-- Corredor: << extends >>
Atleta <|-- Nadador: << extends >>
Ciclista <-- Triatleta: << implements >>
Corredor <-- Triatleta: << implements >>
Nadador <-- Triatleta: << implements >>
```

<br />

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Exemplo 01 - Implementa√ß√£o em TypeScript:** 

**Classe Pessoa**

```ts
export abstract class Pessoa {

    private _nome: string;

    constructor (nome: string){
        this._nome = nome;
    }

    public get nome(){
        return this._nome;
    }

    public set nome(nome: string){
        this._nome = nome;
    }

    public abstract cansou(): void;

    public visualizar(): void{
        console.log("***************************************");
        console.log("           Dados da Pessoa             ");
        console.log("***************************************");
        console.log("Nome da pessoa: ", this._nome);
    }
}
```

A Classe Pessoa (Superclasse), foi criada com apenas um Atributo (nome), conforme o Diagrama de Classes acima. Tamb√©m foi criado o M√©todo Construtor, os M√©todos Get e Set do Atributo, o M√©todo visualizar() e o M√©todo abstrato cansou().

**Interface Atleta**


```ts
export Interface Atleta {

    aquecer(): void;
    
}
```

A Interface Atleta foi criada com apenas um M√©todo (aquecer()), conforme o Diagrama de Classes acima. 

**Interface Ciclista**


```ts
import { Atleta } from "./Atleta";

export Interface Ciclista extends Atleta{

    pedalar(): void;
    
}
```

A Interface Ciclista foi criada como uma Heran√ßa da Classe Atleta, com apenas um M√©todo (pedalar()), conforme o Diagrama de Classes acima. 

**Interface Corredor**


```ts
import { Atleta } from "./Atleta";

export Interface Corredor extends Atleta{

    correr(): void;
    
}
```

A Interface Corredor foi criada como uma Heran√ßa da Classe Atleta, com apenas um M√©todo (correr()), conforme o Diagrama de Classes acima. 

**Interface Nadador**


```ts
import { Atleta } from "./Atleta";

export Interface Nadador extends Atleta{

    nadar(): void;
    
}
```

A Interface Nadador foi criada como uma Heran√ßa da Classe Atleta, com apenas um M√©todo (nadar()), conforme o Diagrama de Classes acima. 

**Classe Triatleta**


```ts
import { Ciclista } from "./Ciclista";
import { Corredor } from "./Corredor";
import { Nadador } from "./Nadador";
import { Pessoa } from "./Pessoa";

export class Triatleta extends Pessoa implements Ciclista, Corredor, Nadador{
    
    constructor(nome: string){
        super(nome);
    }
       
    aquecer(): void {
        console.log("Aquecendo...");
    }
    
    correr(): void {
        console.log("Correndo...");
    }
    
    pedalar(): void {
        console.log("Pedalando...");
    }
     
    nadar(): void {
        console.log("Nadando...");
    }
    
    public cansou(): void {
        console.log("Cansou!");
    }
    
}
```

A Classe Triatleta foi criada como Heran√ßa da Classe Pessoa e Implementa as Interfaces: Nadador, Corredor e Ciclista, conforme o Diagrama de Classes acima. Al√©m disso, tamb√©m foi criado o M√©todo Construtor. 

Observe que todos os M√©todos das 3 Interfaces foram implementados. Quando uma Classe Implementa uma Interface, ela "assina um contrato" com a Interface, que a obriga a implementar ou minimamente inserir as assinaturas de todos os M√©todos da Interface no Corpo da Classe.

**Classe TestaTriatleta**

```ts
import { Triatleta } from "./Triatleta";

export function main() {

    const triatleta: Triatleta = new Triatleta("Nat√°lia");
    triatleta.visualizar();
    triatleta.aquecer();
    triatleta.pedalar();
    triatleta.correr();
    triatleta.nadar();
    triatleta.cansou();
    
}

main();

```

Na Classe TestaTriatleta, foi instanciado um Objeto da Classe Triatleta. Observe que gra√ßas a Heran√ßa e as Interfaces implementadas, o Objeto da Classe Triatleta consegue executar os M√©todos das 4 Interfaces e da Classe Pessoa. Abaixo, voc√™ confere o resultado do c√≥digo no Console:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
***************************************           
Dados da Pessoa
***************************************
Nome da pessoa:  Nat√°lia

Aquecendo...
Pedalando...
Correndo...
Nadando...
Cansou!
```

<br />

<h2>2. Interfaces x Classes Abstratas</h2>

| Classes Abstratas                                           | Interfaces                                                   |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| Agrupa objetos com implementa√ß√µes compartilhadas            | Agrupa objetos com implementa√ß√µes diferentes                 |
| Define novas classes atrav√©s de heran√ßa (simples) de c√≥digo | Define novas interfaces atrav√©s de heran√ßa (m√∫ltipla) de **assinaturas** |
| Uma Classe pode ter apenas uma Superclasse (heran√ßa).       | Uma Classe pode implementar v√°rias Interfaces.               |

<br />

<h2>3. Regras para utilizar Interface</h2>



Aqui est√£o alguns pontos-chave para definir uma Interface com M√©todos Abstratos em TypeScript, que devem ser mantidos em mente. As regras s√£o as seguintes:

1. Uma Interface n√£o pode ser instanciada diretamente como uma Classe.

2. Uma classe que implementa uma Interface deve fornecer suas pr√≥prias implementa√ß√µes de todos os m√©todos definidos na Interface.

3. N√£o podemos reduzir a visibilidade de um m√©todo da Interface durante a substitui√ß√£o, ou seja, quando implementamos um m√©todo da Interface, ele obrigatoriamente ser√° public (p√∫blico).

4. Um M√©todo da Interface tamb√©m pode ser implementado em uma Classe com o corpo vazio. 

5. Todos os m√©todos definidos em uma Interface s√£o abstratos e p√∫blicos por defini√ß√£o. 

6. Se voc√™ adicionar qualquer novo m√©todo na Interface, todas as classes concretas que implementam essa Interface devem fornecer implementa√ß√µes para o m√©todo rec√©m-adicionado, porque todos os m√©todos na Interface s√£o abstratos por defini√ß√£o.

<br />

<h2>4. Interfaces e defini√ß√£o de tipos de dados</h2>



Al√©m de definir M√©todos que ser√£o implementados por uma Classe, como vimos anteriormente, uma Interface, na Linguagem TypeScript, tamb√©m pode ser utilizada para definir tipos de dados complexos, como fun√ß√µes e objetos, de forma que possam ser utilizados para restringir um tipo de dado. 

Assim como nos objetos definidos por uma Classe, uma Interface pode ser utilizada para definir um tipo de objeto no TypeScript, que em sua forma mais b√°sica, se parece muito com um objeto literal (Objeto gerado por uma Classe).

Uma Interface TypeScript que define um tipo de dado √© a ess√™ncia de um tipo literal de Objeto. Ela √© um conjunto de M√©todos e Propriedades que descrevem um Objeto, por√©m n√£o inicializa e muito menos os implementam como as Classes. 

**Sintaxe:**

```ts
export interface nome_da_interface{
    atributo1: tipo;
    atributo2: tipo;
    ...
    atributoN: tipo;
}
```

Note que, diferente de um objeto literal criado por uma Classe, o objeto definido a partir de uma Interface separa os campos usando ponto e v√≠rgula, e n√£o v√≠rgulas. Essa sintaxe √© semelhante ao formato **JSON - JavaScript Object Notation**, que veremos mais adiante no Bloco 02.

<br />

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Exemplo 02 - Criar uma Interface para defini√ß√£o de Objeto:**

```ts
export interface Pessoa{
    nome: string;
    sobrenome: string;
}
```

No exemplo acima, foi criada a **Interface Pessoa**, composta por 2 atributos: `nome` e `sobrenome`. 

Observe que qualquer objeto que for criado a partir do tipo `Pessoa`, definido pela Interface Pessoa, deve conter valores atribu√≠dos nos dois atributos.

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Exemplo 03 - Criando Objetos da Interface Pessoa:**

```ts
export interface Pessoa{
    nome: string;
    sobrenome: string;
}

const pessoa1: Pessoa = {
    nome: 'Maria',
    sobrenome: 'Sim√µes'
}

const pessoa2: Pessoa = {
    nome: 'Juliana',
    sobrenome: 'Silva'
}

console.log(pessoa1);
console.log(pessoa2);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
{ nome: 'Maria', sobrenome: 'Sim√µes' }
{ nome: 'Juliana', sobrenome: 'Silva' }
```

<br />

No exemplo acima, foram criados 2 Objetos baseados na **Interface Pessoa**. Note que, diferente de um objeto criado por uma Classe, no objeto criado a partir de uma Interface, o nome do atributo seguido por 2 pontos foi acrescentado antes do valor que ser√° atribu√≠do ao atributo.

As Interfaces tamb√©m podem herdar outras Interfaces para compor tipos mais complexos, assim como as Classes:

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Exemplo 04 - Criando uma Interface Composta:**

```ts
import { Pessoa } from "./Pessoa";

export interface PessoaJuridica extends Pessoa {
    conta: number;
    cnpj: number;
}

const pessoaJuridica: PessoaJuridica = {
    nome: 'Maria',
    sobrenome: 'Sim√µes',
    conta: 12345,
    cnpj: 123456000123
}

console.log(pessoaJuridica);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
{
  nome: 'Maria',
  sobrenome: 'Sim√µes',
  conta: 13635686,
  cnpj: 99551026000195
}
```

No exemplo acima, foi criado 1 Objeto baseados na **Interface PessoaJuridica**, que herda a Interface **Pessoa**. Note que foram adicionados os atributos de ambas as Interfaces, n√£o foi criado um M√©todo Construtor, assim como nas Classes.

As Interfaces tamb√©m podem ter atributos com valores opcionais:

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Exemplo 05 - Interface com atributos opcionais:**

```typescript
import { Pessoa } from "./Pessoa";

export interface PessoaFisica extends Pessoa {
    conta: number;
    cpf: number;
    telefone?: number;
}

const pessoaFisica01: PessoaFisica = {
    nome: 'Maria',
    sobrenome: 'Sim√µes',
    conta: 16753432,
    cpf: 34981106084
}

const pessoaFisica02: PessoaFisica = {
    nome: 'Juliana',
    sobrenome: 'Silva',
    conta: 11847743,
    cpf: 82177048052,
    telefone: 21345678
}

console.log(pessoaFisica01);
console.log(pessoaFisica02);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
{
  nome: 'Maria',      
  sobrenome: 'Sim√µes',
  conta: 16753432,    
  cpf: 34981106084    
}
{
  nome: 'Juliana',
  sobrenome: 'Silva',
  conta: 11847743,
  cpf: 82177048052,
  telefone: 21345678
}
```

Note que no primeiro Objeto n√£o foi passado um valor para o atributo opcional **telefone** e mesmo assim o Objeto foi criado.

Este recurso de criar um tipo de dado a partir de uma Interface √© muito utilizado nas Bibliotecas e Frameworks JavaScript/TypeScript, voltados para o Desenvolvimento de aplica√ß√µes Frontend, como o Angular e o React por exemplo, para criar um modelo de verifica√ß√£o do modelo de dados do Backend da aplica√ß√£o, como veremos no decorrer do Bloco 03.

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces" target="_blank"><b>Documenta√ß√£o - TypeScript: Interfaces</b></a></div>

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="" target="_blank"><b>C√≥digo fonte dos exemplos</b></a></div>

<br />

------

## üîë**Pontos chave:**

1.  **Interface** √© uma estrutura que representa uma **Classe abstrata "pura"** em TypeScript, que **n√£o t√™m atributos de dados** (s√≥ pode ter constantes est√°ticas - tipo final), **n√£o tem construtor**, **todos os m√©todos s√£o abstratos** e **n√£o √© declarada como Classe, e sim como Interface**.
2.  Uma Classe pode implementar v√°rias Interfaces, entretanto n√£o √© recomend√°vel implementar mais do que 3 Interfaces, porqu√™ pode criar uma complexidade desnecess√°ria ao projeto.
3.  A Interface estabelece **um conjunto de M√©todos apenas assinados, ou seja, sem o corpo, que obrigatoriamente devem ser implementados nas Subclasses que a utiliza**.
4.  Uma Interface, na Linguagem TypeScript, tamb√©m pode ser utilizada para definir tipos de dados complexos, como fun√ß√µes e objetos, de forma que possam ser utilizados para restringir um tipo de dado.

<br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>

