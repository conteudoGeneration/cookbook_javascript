<h1>Arrow Functions</h1>



Antes de falarmos sobre Arrow Functions, precisamos definir dois conceitos fundamentais: 

1. Express√µes de fun√ß√£o (Functions Expressions);
2. Programa√ß√£o Funcional.

<br />

<h2>1. Express√µes de fun√ß√£o</h2>



Em TypeScript, uma fun√ß√£o n√£o √© uma ‚Äúestrutura m√°gica da linguagem‚Äù, e sim um tipo especial de valor. Em TypeScript voc√™ pode fazer tudo o que voc√™ poderia fazer com um objeto regular, voc√™ tamb√©m consegue fazer com uma fun√ß√£o. Voc√™ pode passar uma fun√ß√£o para outras fun√ß√µes, atribu√≠dos como vari√°veis e ou par√¢metros de uma fun√ß√£o.

Quando estudamos o tema Fun√ß√µes no TypeScript, aprendemos declarar fun√ß√µes usando a sintaxe de *Declara√ß√£o de Fun√ß√£o:*

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Exemplo 01 - Declara√ß√£o de Fun√ß√£o:**

```ts
export function somar(numero1: number, numero2: number): number {
    return numero1 + numero2;
}
```

Al√©m da sintaxe de *Declara√ß√£o de Fun√ß√£o*, existe um outra sintaxe para criar uma fun√ß√£o chamada *Express√£o de Fun√ß√£o (Functions Expressions)*, que nos permite criar uma nova fun√ß√£o no meio de qualquer express√£o. Veja o exemplo abaixo:

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Exemplo 02 - Express√£o de Fun√ß√µes:**

```ts
let somar = function(numero1: number, numero2: number): number {
    return numero1 + numero2;
}
```

Utilizando a sintaxe **Express√£o de Fun√ß√µes** podemos criar uma vari√°vel que receber√° como valor a nova fun√ß√£o, criada. Note que n√£o h√° nome ap√≥s o  palavra reservada **function**, no caso √© permitido omitir por se tratar de uma Express√£o de fun√ß√£o.

Um ponto importante, que merece ser destacado e refor√ßado em rela√ß√£o as fun√ß√µes no TypeScript √© que n√£o importa como a fun√ß√£o √© criada, uma fun√ß√£o √© um valor e em ambos os exemplos acima, este valor ser√° armazenado em uma vari√°vel chamada **somar**. No Exemplo 01, **somar** √© o nome da fun√ß√£o e no exemplo 02, **somar** √© uma vari√°vel que recebe a fun√ß√£o.

Veja os 2 M√©todos em a√ß√£o nos exemplos abaixo:

<br />

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> **Exemplo 03 - Soma de 2 n√∫meros com Declara√ß√£o de Fun√ß√£o:**

```ts
import readline from 'readline-sync';

let numero1: number = readline.questionFloat("Digite o primeiro numero: ");
let numero2: number = readline.questionFloat("Digite o segundo numero: ");

console.log("Resultado da soma: ", somar(numero1, numero2));

export function somar(numero1: number, numero2: number): number {
    return numero1 + numero2;
}

```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Digite o primeiro numero: 10
Digite o segundo numero: 5
Resultado da soma:  15
```

<br />

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> **Exemplo 04 - Soma de 2 n√∫meros com Express√£o de Fun√ß√µes:**

```ts
import readline from 'readline-sync';

let numero1: number = readline.questionFloat("Digite o primeiro numero: ");
let numero2: number = readline.questionFloat("Digite o segundo numero: ");

let somar = function(numero1: number, numero2: number): number {
    return numero1 + numero2;
};

console.log("Resultado da soma: ", somar(numero1, numero2));
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Digite o primeiro numero: 10
Digite o segundo numero: 5
Resultado da soma:  15
```

Embora o resultado seja o mesmo, existem outras diferen√ßas entre uma Fun√ß√£o Declarada e um Express√£o de Fun√ß√£o. 

Note que na Declara√ß√£o de Fun√ß√£o a fun√ß√£o foi chamada antes mesmo dela ser declarada, enquanto na Express√£o de Fun√ß√£o, a fun√ß√£o s√≥ foi chamada depois de ser criada a vari√°vel **somar**, que recebeu a fun√ß√£o. Isso acontece porque diferente da **Declara√ß√£o de Fun√ß√£o, onde a fun√ß√£o √© criada quando o TypeScript est√° se preparando para iniciar o script**, logo elas s√£o vis√≠veis em todos os lugares do bloco, as **Express√µes de Fun√ß√£o s√£o criadas apenas quando a execu√ß√£o chegar no ponto exato onde ela √© criada**, por isso que voc√™ n√£o consegue utilizar a fun√ß√£o antes dela ser criada.

<br />

<h2>2. Programa√ß√£o Funcional</h2>



A **Programa√ß√£o Funcional** √© um paradigma da programa√ß√£o, que te permite criar c√≥digos confi√°veis e f√°ceis de testar. 

> Em computa√ß√£o, **Paradigma** nada mais √© que a forma de fazer algo, ou seja, √© a orienta√ß√£o que os c√≥digos v√£o ter.

O Paradigma da Programa√ß√£o Funcional √© baseado num modelo Computacional bem antigo, chamado de **C√°lculo Lambda. Para entender o que √© programa√ß√£o funcional, entretanto, √© importante entender outros paradigmas de programa√ß√£o famosos: **Programa√ß√£o Imperativa** e **Programa√ß√£o Orientada a Objetos** (POO).

<br />

<h3>1.1. Programa√ß√£o Imperativa</h3>



√â o paradigma de programa√ß√£o mais famoso. Nas linguagens imperativas ‚Äì como C e PHP ‚Äì, os c√≥digos s√£o escritos como uma lista de instru√ß√µes  que o computador l√™ e executa. √â como se fossem comandos para a m√°quina, por isso programa√ß√£o imperativa. 

<br />

<h3>1.2. Programa√ß√£o Orientada a Objetos</h3>



J√° na Programa√ß√£o Orientada a Objetos, em vez de descrever um c√≥digo, o programador cria um objeto e adiciona comportamentos a ele. Alguns exemplos de linguagens de programa√ß√£o orientadas a objetos s√£o C#, Python e Ruby. Outras, como JavaScript e PHP, s√£o linguagens com suporte √† orienta√ß√£o de objetos.

<br />

<h3>1.3. E a Programa√ß√£o Funcional?</h3>



Diferentemente das programa√ß√µes Imperativa e Orientada a Objetos, a Funcional parte do princ√≠pio de que  tudo s√£o fun√ß√µes. N√£o existe uma lista de instru√ß√µes ou objetos para o  computador realizar, mas uma sequ√™ncia de **fun√ß√µes matem√°ticas** que, juntas, v√£o resolver um problema.

Isso significa que, no paradigma funcional, voc√™ tem uma fun√ß√£o,  coloca um dado de entrada, aplica v√°rias opera√ß√µes e obt√©m uma sa√≠da. √â  poss√≠vel alterar as opera√ß√µes e, consequentemente, a sa√≠da, mas a  entrada sempre permanecer√° a mesma.

Al√©m disso, no Paradigma da Programa√ß√£o Funcional n√£o existem vari√°veis, e sim constantes. Isso se traduz em c√≥digos mais  objetivos com constantes que, de forma geral, n√£o mudam. Alguns exemplos de linguagens 100% funcionais s√£o Clojure, Haskell e Elixir.

<div align="center"><img src="https://i.imgur.com/EtLQsSx.jpg" title="source: imgur.com" width="90%"/></div>

<br />

<h2>2. Arrow Functions</h2>



Uma **Arrow Function** ou **Express√£o Lambda** √© um pequeno bloco de c√≥digo que recebe par√¢metros e retorna um valor. As Arrow Functions tamb√©m podem ser vistas como uma fun√ß√£o an√¥nima. Uma fun√ß√£o que n√£o tem nome e n√£o pertence a nenhuma Classe ou Objeto. As Arrow Functions s√£o semelhantes aos m√©todos, mas n√£o precisam de um nome e podem ser implementadas diretamente no corpo de um m√©todo. Atrav√©s das Arrow Functions o TypeScript adicionou novos recursos, que implementam os conceitos da Programa√ß√£o Funcional, tornando a Linguagem mais flex√≠vel, servindo como um complemento para a constru√ß√£o de c√≥digos mais limpos e enxutos.

As Arrow Functions funcionam de forma muito semelhante √†s Express√µes de Fun√ß√£o, embora utilizem um novo token conhecido como **seta** (=>), muito semelhante as Express√µes Lambda presentes no Java e no C#. 

<br />

**Sintaxe:**

```c#
(lista de par√¢metros) => express√£o
```

<br />

Uma Arrow Function consiste em tr√™s componentes:

- **Lista de Par√¢metros:** Aqui vem os argumentos que podem ser vazio ou n√£o vazio tamb√©m.
- **Arrow Functions:** A seta (=>) √© usada para separar a lista de par√¢metros e o corpo da fun√ß√£o. Ela tamb√©m √© conhecida como **Operador Lambda**.
- **Corpo da fun√ß√£o:** Cont√©m a instru√ß√£o, que pode ser uma express√£o ou uma declara√ß√£o.

Os par√¢metros de entrada est√£o no lado esquerdo do Operador Lambda e o corpo da fun√ß√£o no lado direito do Operador Lambda. 

<br />

<h3>2.1. Caracter√≠sticas</h3>

Aqui est√£o algumas caracter√≠sticas importantes da Arrow Functions.

- **Declara√ß√£o de tipo:** a declara√ß√£o de tipo √© opcional. Depende de voc√™, se voc√™ n√£o declarar o tipo de par√¢metro, o compilador definir√° o tipo de dado por infer√™ncia, baseado no valor do par√¢metro. Por exemplo, voc√™ pode escrever como:

```c#
(5,4) => corpo da fun√ß√£o
```

- **Par√™nteses ao redor do par√¢metro:** Os par√™nteses ao redor do par√¢metro tamb√©m √© opcional. Voc√™ pode colocar par√™nteses se quiser, caso contr√°rio, deixe como est√°. Se houver v√°rios par√¢metros em uma Arrow Functions, os par√™nteses ser√£o necess√°rios, conforme mostrado no exemplo acima. Para apenas um par√¢metro, voc√™ pode escrever como:

```c#
5 => corpo da fun√ß√£o
```

- **Chaves:** As chaves ao redor do corpo da fun√ß√£o tamb√©m s√£o opcionais se houver apenas uma instru√ß√£o. Para v√°rias declara√ß√µes, chaves em torno do corpo da fun√ß√£o s√£o necess√°rias. Por exemplo:

```c#
(int a, int b) =>
{
    var sum = a + b;
    return sum;
};
```

- **Instru√ß√£o de retorno:** A instru√ß√£o de retorno tamb√©m √© opcional em Arrow Functions. O TypeScript retorna automaticamente o valor se o corpo tiver uma √∫nica express√£o. 

<br />

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Exemplo 05 - Arrow Functions e Arrays:** 

Nesta primeira vers√£o do c√≥digo, n√£o foram utilizadas as Arrow Functions:

```ts
let numeros: Array<number> = [1, 2, 3, 4, 5, 6, 7, 8, 9];

console.log("Exibir os itens\n");

// Exibir os itens da Lista sem Arrow Functions
for(let numero of numeros){

    console.log(numero);

}

console.log("\nExibir os itens somados com eles mesmos\n");

// Exibir os itens da Lista dobrados sem Arrow Functions
for(let numero of numeros){

    console.log(numero + numero);

}

console.log("\nExibir os itens pares da lista\n");

// Exibir apenas os elementos pares da Lista sem Arrow Functions
for(let numero of numeros){
    if (numero % 2 == 0)
        console.log(numero);
}
```

<br />

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Exemplo 06 - Arrow Functions e Arrays:** 

Na segunda vers√£o do c√≥digo, foram utilizadas as Arrow Functions:

```ts
let numeros: Array<number> = [1, 2, 3, 4, 5, 6, 7, 8, 9];

console.log("Exibir os itens\n");

// Exibir os itens da Lista sem Arrow Functions
numeros.forEach(numero => console.log(numero));

console.log("\nExibir os itens somados com eles mesmos\n");

// Exibir os itens da Lista dobrados sem Arrow Functions
numeros.forEach(numero => console.log(numero + numero));

console.log("\nExibir os itens pares da lista\n");

// Exibir apenas os elementos pares da Lista sem Arrow Functions
numeros.forEach(numero =>{
    if (numero % 2 == 0)
        console.log(numero);
});
```

Observe que ao comparar a primeira vers√£o sem Lambdas, com a segunda vers√£o com Lambdas, o c√≥digo da segunda vers√£o fica muito menos verboso, mais direto e limpo. Abaixo, vemos o resultado da execu√ß√£o de ambos os c√≥digos.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Exibir os itens

1
2
3
4
5
6
7
8
9

Exibir os itens somados com eles mesmos

2
4
6
8
10
12
14
16
18

Exibir os itens pares da lista

2
4
6
8
```

<br />

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank"><b>Documenta√ß√£o: Arrow Functions</b></a></div>

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="" target="_blank"><b>C√≥digo Fonte dos Exemplos</b></a></div>

<br />

------

## üîë**Pontos chave:**

1. Em TypeScript, todas as fun√ß√µes s√£o valores, que podem ser atribu√≠dos, copiados ou declarados em qualquer lugar do c√≥digo.
2. Se uma fun√ß√£o for declarada como uma declara√ß√£o separada no fluxo de c√≥digo principal, isso √© chamado de **Declara√ß√£o de Fun√ß√£o**.
3. Se a fun√ß√£o √© criada como parte de uma express√£o, ela √© chamada de **Express√£o de Fun√ß√£o**.
4. As Declara√ß√µes de Fun√ß√£o s√£o processadas antes que o bloco de c√≥digo seja executado, logo elas s√£o vis√≠veis em todos os lugares do bloco.
5. As Express√µes de Fun√ß√£o s√£o criadas quando o fluxo de execu√ß√£o chega no exato ponto onde elas s√£o declaradas, logo n√£o √© poss√≠vel utiliz√°-las antes de cria-las.
6. A **Programa√ß√£o Funcional** √© um paradigma da programa√ß√£o, que te permite criar c√≥digos confi√°veis e f√°ceis de testar. 
7. Uma **Arrow Function** √© um pequeno bloco de c√≥digo que recebe par√¢metros e retorna um valor. 
8. Uma **Arrow Function** tamb√©m pode ser vista como uma fun√ß√£o an√¥nima, ou seja, uma fun√ß√£o que n√£o tem nome e n√£o pertence a nenhuma Classe ou Objeto. 
9. As **Arrow Functions** s√£o semelhantes aos m√©todos, mas n√£o precisam de um nome e podem ser implementadas diretamente no corpo de um m√©todo. 

<br />

<br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>