<h1>Fun√ß√µes e M√©todos</h1>



A Linguagem TypeScript, diferente da maioria das  Linguagens de Programa√ß√£o, oferece a possibilidade de se criar **Fun√ß√µes (Functions)** e **M√©todos**. Dentro do contexto Linguagem TypeScript, existem algumas diferen√ßas:

Uma **Fun√ß√£o** √© um bloco de c√≥digo escrito para executar um conjunto espec√≠fico de tarefas. Para definir uma fun√ß√£o utilizamos a palavra-chave **function**. O corpo da fun√ß√£o √© escrito dentro do escopo, delimitado por um par chaves, semelhante aos La√ßos Condicionais de Repeti√ß√£o.

Para promover a capacidade de reutiliza√ß√£o de software, **todas as Fun√ß√µes devem estar limitadas √† realiza√ß√£o de uma √∫nica tarefa bem definida**. O **nome da fun√ß√£o tamb√©m deve ser assertivo e expressar essa tarefa efetivamente**. As Fun√ß√µes tornam mais f√°cil as tarefas de escrever, depurar, manter e modificar c√≥digo, pelo simples fato de **uma Fun√ß√£o realizar apenas uma tarefa, tornando mais f√°cil os processos de teste e depura√ß√£o do c√≥digo**.

**Exemplos de Fun√ß√µes:**

- **function somar()**, **function subtrair()**, **function calcularArea()**.

Um **M√©todo** √© uma Fun√ß√£o associada √† Classe, ou seja, uma a√ß√£o sobre um Objeto definido pela Classe. Um m√©todo TypeScript √© uma propriedade de um objeto que cont√©m uma defini√ß√£o de Fun√ß√£o. M√©todos s√£o fun√ß√µes armazenadas como propriedades do Objeto. O principal benef√≠cio do uso de M√©todos √© que eles s√£o reutiliz√°veis em futuros programas, evitando a repeti√ß√£o desnecess√°ria de c√≥digo.

Da mesma forma que as Fun√ß√µes, **todos os M√©todos tamb√©m devem estar limitados √† realiza√ß√£o de uma √∫nica tarefa bem definida** e o **nome do M√©todo tamb√©m deve ser assertivo e expressar exatamente a tarefa ele executar√°**. 

**Exemplos de M√©todos:**

- **Objeto Carro:** acelerar(), frear(), virar(), parar()
- **Objeto Conta Banc√°ria:** sacar(), depositar(), transferir()
- **Objeto E-commerce:** pagar(), adicionarAoCarrinho()

**Fun√ß√£o x M√©todo**

| Fun√ß√£o                                                       | M√©todo                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Uma Fun√ß√£o TypeScript √© um bloco de c√≥digo projetado para executar uma tarefa espec√≠fica. | Um M√©todo TypeScript √© uma propriedade de um Objeto que possui o valor de uma Fun√ß√£o, projetado para executar uma tarefa espec√≠fica sobre o Objeto. |
| Uma Fun√ß√£o pode passar os dados que ser√£o processados e pode retornar os dados resultantes do processamento. | O M√©todo processa os dados contidos em um Objeto, definidos por uma Classe. |
| Os dados passados para uma Fun√ß√£o s√£o expl√≠citos.            | Um M√©todo passa implicitamente o objeto no qual foi chamado. |
| Uma Fun√ß√£o √© independente de qualquer estrutura do c√≥digo.   | Um M√©todo √© uma fun√ß√£o associada a uma propriedade de um  Objeto, ou seja, ele √© dependente do Objeto. |
| Uma Fun√ß√£o pode ser chamada diretamente pelo seu nome.       | Um M√©todo consiste em um c√≥digo que pode ser chamado pelo nome de seu Objeto, seguido por um ponto final e o nome do M√©todo.<br />**Exemplo:** `objeto01.metodo01();` |

Neste conte√∫do focaremos na declara√ß√£o e na utiliza√ß√£o de Fun√ß√µes. No conte√∫do sobre Programa√ß√£o Orientada a Objetos focaremos na declara√ß√£o e na utiliza√ß√£o de M√©todos.

<br />

<h2>1. Declarando Fun√ß√µes</h2>



**Sintaxe:**

```ts
function nome(argumento: tipo, argumento:tipo,...): tipo_de_retorno {
   // Corpo da fun√ß√£o
}
```

<br />

<h3>1.1. Nome</h3>

√â o nome da Fun√ß√£o. Para definir o Nome da Fun√ß√£o, deve-se seguir algumas boas pr√°ticas:

- Por padr√£o o nome da Fun√ß√£o, assim como nas vari√°veis, segue o padr√£o **Camel Case**, onde  sempre come√ßam com letras min√∫sculas.  **Exemplos:** `copiar()`, `colar()`, `recortar()`
- Caso o nome da Fun√ß√£o seja composto, a partir da segunda palavra utiliza-se a primeira letra mai√∫scula em cada palavra. **Exemplos:** `calcularSalario()`, `aplicarDesconto()`, `calcularAreaQuadrado()`
- √â recomendado que o nome da Fun√ß√£o possua um verbo, porque indicam uma a√ß√£o. **Exemplos:** `mover()`, `deletar()`, `inserirLinha()`
- O nome da Fun√ß√£o deve ser assertivo e indicar exatamente o que ele faz. **Exemplos:** `copiarTexto()`, `colarTexto()`, `recortarTexto()`
- Independente de possuir ou n√£o argumentos, uma Fun√ß√£o sempre ter√° os `( )` par√™nteses ap√≥s o seu nome.
- Os identificadores n√£o podem utilizar as palavras reservadas, como: **`class`**, **`for`**, **`while`**, **`public`**, entre outras.

<br />

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words" target="_blank"><b>Documenta√ß√£o: Palavras Reservadas</b></a></div>

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#functions" target="_blank"><b>Documenta√ß√£o: Declara√ß√£o de Fun√ß√µes</b></a></div>

<br />

<h3>1.2. Argumentos</h3>



S√£o os par√¢metros da Fun√ß√£o. S√£o representados por uma **lista de vari√°veis separadas por v√≠rgulas**, onde cada par√¢metro obedece as regras e a sintaxe de defini√ß√£o de vari√°veis:

**Sintaxe - Argumento com um tipo de dado**

```ts
function nome_da_funcao(identificador: tipo){
    // Corpo da Fun√ß√£o
}
```

- **Identificador:** Nome da vari√°vel.
- **Tipo:** Tipo da vari√°vel.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ATEN√á√ÉO:** Ao declarar os argumentos da Fun√ß√£o n√£o √© necess√°rio adicionar as palavras *var ou let* para indicar que os argumentos s√£o vari√°veis, declare apenas o identificador do argumento, seguido do seu tipo.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

Uma Fun√ß√£o TypeScript pode ter argumentos que aceitem 2 ou mais tipos de dados diferentes. Para indicar essa possibilidade, utilizamos o **PIPE ( | )** para separar os tipos na defini√ß√£o do tipo de dado do argumento, na assinatura da Fun√ß√£o.

> O **PIPE ( | )** no TypeScript √© utilizado para criar um tipo de dado especial chamado **Tipo de Uni√£o (Union Type)**. Um tipo de uni√£o √© um tipo formado por dois ou mais outros tipos de dados diferentes, representando valores que podem ser de qualquer um desses tipos. 

**Sintaxe - Argumento com dois tipos de dado**

```ts
function nome_da_funcao(identificador: tipo1 | tipo2){
    // Corpo da Fun√ß√£o
}
```

- **Identificador:** Nome da vari√°vel.
- **Tipo1:** Primeiro tipo da vari√°vel.
- **Tipo2:** Segundo tipo da vari√°vel.

Neste caso, o argumento aceitaria um valor tanto do primeiro tipo, quanto do segundo tipo. 

Uma Fun√ß√£o TypeScript tamb√©m pode ter argumentos opcionais, ou seja, que a inser√ß√£o de um valor n√£o √© obrigat√≥rio. Para indicar essa possibilidade, utilizamos uma **Interroga√ß√£o ( ? )** ao lado da declara√ß√£o do argumento, na assinatura da Fun√ß√£o.

**Sintaxe - Argumento Opcional:**

```ts
function nome_da_funcao(argumento1: tipo, argumento2:tipo, argumento3?:tipo): Tipo01 | Tipo2 {
   // Corpo da fun√ß√£o
}
```

Observe que na Fun√ß√£o acima os argumentos 1 e 2 s√£o obrigat√≥rios, enquanto o argumento 3 √© Opcional.

> A **Interroga√ß√£o ( ? )** no TypeScript √© um Operador chamado **Encadeamento Opcional (Optional chaining)**. Este operador permite a leitura do valor de um argumento, sem que a valida√ß√£o de cada refer√™ncia seja expressivamente realizada. Na pr√°tica ao inv√©s de causar um erro se a vari√°vel n√£o receber um valor na chamada da Fun√ß√£o, a vari√°vel retornar√° o valor `undefined`.  

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean" target="_blank"><b>Documenta√ß√£o - Tipos de dados</b></a></div>

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types" target="_blank"><b>Documenta√ß√£o: Union Type</b></a></div>

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" target="_blank"><b>Documenta√ß√£o: Optional Chaining</b></a></div>

<br />

<h3>1.3. Tipo de Retorno</h3>



√â o indicador do Tipo de retorno da Fun√ß√£o, ou seja, o tipo do valor que se espera que a Fun√ß√£o retorne ao finalizar o processamento dos dados. Assim como as vari√°veis, as Fun√ß√µes com tipo de retorno geralmente s√£o declaradas com  tipos de dados primitivos, mas elas tamb√©m podem retornar tipos n√£o primitivos como Objetos, array, entre outros. Na tabela abaixo, vemos o tipos mais comuns de retorno:

| **Tipo**    | **Tamanho**          |
| ----------- | -------------------- |
| **boolean** | *true* ou *false*    |
| **number**  | 64  bits             |
| **string**  | cadeia de caracteres |
| **any**     | qualquer tipo        |
| **null**    | Nulo                 |

As Fun√ß√µes que possuem um tipo de dado, obrigatoriamente precisam retornar um valor equivalente ao seu tipo, ou seja, se a Fun√ß√£o for declarada para retornar um valor do tipo **number**, ela precisa retornar um numero ao final do seu processamento. Para retornar este valor, o TypeScript utiliza a palavra reservada **return** seguido do valor de retorno.

Uma Fun√ß√£o tamb√©m pode retornar dois ou mais tipos de dado diferentes. Para indicar essa possibilidade, utilizamos o **PIPE ( | )** para separar os tipos na defini√ß√£o do tipo de retorno da Fun√ß√£o, na assinatura da Fun√ß√£o.

**Sintaxe - Dois tipos de retorno:**

```ts
function nome_da_funcao(argumento1: tipo, argumento2:tipo,...): tipo1 | tipo2 {
   // Corpo da fun√ß√£o
}
```

Observe que a Fun√ß√£o acima pode retornar um valor do tipo1 ou um valor do tipo2.

Caso a Fun√ß√£o **n√£o necessite ter um tipo de dado de retorno, ou seja, um valor que dever√° ser retornado ao final da execu√ß√£o da Fun√ß√£o**, na assinatura da Fun√ß√£o, defina o tipo de retorno como **void**.

**Sintaxe - Sem valor de retorno:**

```ts
function nome(): void {
   // Corpo da fun√ß√£o
}
```

Observe que na Fun√ß√£o acima al√©m de n√£o possuir argumentos, ela n√£o retornar√° nenhum valor, por isso foi declarada com o tipo **void**.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ATEN√á√ÉO:** *Ao declarar uma Fun√ß√£o, caso o tipo de retorno n√£o seja informado, o TypeScript definir√° o tipo de retorno por infer√™ncia, baseado nos argumentos e no retorno definido no Corpo da Fun√ß√£o.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 01: Fun√ß√µes com retorno e argumentos



```ts
	function soma(numero1: number, numero2: number): number {
		return numero1 + numero1;
	}
```

No exemplo acima, a Fun√ß√£o **soma** retorna um valor num√©rico, ou seja, o comando **return** retornar√° um numero, no exemplo acima, a soma entre os 2 n√∫meros. 

Veja a implementa√ß√£o abaixo:

```ts
let resultado: number;

resultado = soma(2, 2);

console.log("O Resultado da soma √©: " + resultado);

function soma(numero1: number, numero2: number): number {
    return numero1 + numero2;
}
```

<br />

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
O Resultado da soma √©: 4
```

Observe que para receber este valor, foi necess√°rio criar uma vari√°vel do mesmo tipo de retorno da Fun√ß√£o (no exemplo acima, uma vari√°vel do tipo **number**), associado a um comando de sa√≠da de dados, para exibir o conte√∫do da vari√°vel.

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 02: Fun√ß√µes com tipo de retorno e argumentos com 2 tipos de dado



```ts
function tipoProduto(tamanho: number | string): void{
    if (typeof(tamanho) === "number" )
        console.log("\nO Tamanho √© um n√∫mero");
    else
        console.log("\nO Tamanho √© uma string");
}
```

No exemplo acima, a Fun√ß√£o **tipoProduto** exibe uma mensagem se o argumento for um valor num√©rico e exibe uma outra mensagem se o argumento for uma string.

Veja a implementa√ß√£o abaixo:

```ts
tipoProduto(40);

tipoProduto('M');

function tipoProduto(tamanho: number | string){
    if (typeof(tamanho) === "number" )
        console.log("\nO Tamanho √© um n√∫mero");
    else
        console.log("\nO Tamanho √© uma string");
}
```

<br />

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
O Tamanho √© um n√∫mero

O Tamanho √© uma string
```

Um dos recursos que diferencia o TypeScript do JavaScript √© o suporte ao **Estreitamento de Tipos** (**Narrowing**), que permite acessar propriedades e m√©todos que s√≥ est√£o dispon√≠veis em determinados tipos e tamb√©m ajuda o  TypeScript a detectar erros e bugs em tempo de compila√ß√£o.

> **O que √© Narrowing?**
>
> O **Narrowing** √© o processo de refino do tipo de uma  vari√°vel com base em uma condi√ß√£o. Isso pode ser √∫til quando voc√™ tem  uma vari√°vel que pode ter v√°rios tipos poss√≠veis, mas voc√™ deseja executar opera√ß√µes nela que s√£o v√°lidas apenas para um tipo espec√≠fico.
>
> O TypeScript usa a an√°lise de fluxo de controle para estreitar tipos  com base em instru√ß√µes condicionais, loops, verifica√ß√µes de veracidade. O estreitamento de tipos normalmente √© feito usando instru√ß√µes  condicionais, como no exemplo acima, que checa o tipo da vari√°vel para definir o que ser√° feito com ela.
>
> <br />
>
> <div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html" target="_blank"><b>Documenta√ß√£o: Narrowing</b></a></div>
>
> <br />

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 03: Fun√ß√µes com 2 tipos de retorno e argumentos



```ts
function divisao(numero1: number, numero2: number): number|null {
    let divisao = numero1 / numero2;
    return (divisao != Infinity ? divisao : null)
}
```

No exemplo acima, a Fun√ß√£o **divisao** retorna um valor num√©rico caso a divis√£o seja realizada com sucesso, ou seja, o comando **return** retornar√° um numero, no exemplo acima, a divis√£o entre os 2 n√∫meros. Caso contr√°rio, a Fun√ß√£o retornar√° nulo (null).

Veja a implementa√ß√£o abaixo:

```ts
let resposta: any;

resposta = divisao(4, 0);

if (resposta != null)
    console.log("O Resultado da divis√£o √©: " + resposta);
else
    console.log("N√£o existe divis√£o por zero");

function divisao(numero1: number, numero2: number): number|null {
    let divisao = numero1 / numero2;

    return (divisao != Infinity ? divisao : null)
}
```

<br />

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
N√£o existe divis√£o por zero
```

Observe que para definir o valor de retorno da Fun√ß√£o, utilizamos um la√ßo condicional para checar se o resultado da divis√£o √© igual a `Infinity`, ou seja, se a divis√£o n√£o √© poss√≠vel de ser realizada (divis√£o por zero, por exemplo).

Para receber o retorno da Fun√ß√£o **divisao**, foi necess√°rio criar uma vari√°vel do tipo **any**, que recebe qualquer tipo de valor. Antes de exibir o resultado, checamos se o valor de retorno √© diferente de `null`. Caso seja, ao inv√©s de exibir o resultado, ser√° exibida uma mensagem informando que n√£o foi poss√≠vel processar a divis√£o. 

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 04: Fun√ß√µes com argumentos opcionais



```typescript
const resultado2 = somar(10, 20);
console.log(resultado2);

const resultado3 = somar(10, 20, 30);
console.log(resultado3);

function somar(numero1: number, numero2: number, numero3?: number): number{
    
    if(numero3 != undefined)
        return numero1 + numero2 + numero3;

    return numero1 + numero2;
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
Soma com 2 par√¢metros:  30
Soma com 3 par√¢metros:  60
```

Observe que quando n√£o √© atribu√≠do um valor para o terceiro par√¢metro na chamada da Fun√ß√£o, ele retornar√° `undefined`. Sem o Operador de Encadeamento Opcional, o TypeScript n√£o aceitaria a chamada da Fun√ß√£o sem atribuir um valor v√°lido para o terceiro par√¢metro.

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 05: Fun√ß√£o sem retorno - void



```ts
function mensagem(): void {
    console.log("M√©todo sem retorno (void)!");
}
```

Fun√ß√µes **void** n√£o retornam valor, apenas exibem uma mensagem na tela ou realizam algum tipo de processamento sem retornar nenhum valor. No exemplo acima, a Fun√ß√£o **mensagem** est√° exibindo uma mensagem na tela.

Veja a implementa√ß√£o abaixo:

```ts
mensagem();

function mensagem(): void {
    console.log("M√©todo sem retorno (void)!");
}
```

<br />

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
M√©todo sem retorno (void)!
```

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#functions" target="_blank"><b>Documenta√ß√£o - TypeScript: Fun√ß√µes</b></a></div>

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 06: Calculadora com Fun√ß√µes:

Vamos adaptar o exemplo da Calculadora, que constru√≠mos no JavaScript, utilizando Fun√ß√µes para realizar as Opera√ß√µes Matem√°ticas:

```ts
import readline from 'readline-sync';

let resultadoDivisao: any;

let numero1: number = readline.questionFloat("Digite o primeiro numero: ");
let numero2: number = readline.questionFloat("Digite o segundo numero: ");

console.log("O Resultado da soma √©: " + somar(numero1, numero2));

console.log("O Resultado da subtra√ß√£o √©: " + subtrair(numero1, numero2));

console.log("O Resultado da multiplica√ß√£o √©: " + multiplicar(numero1, numero2));

resultadoDivisao = dividir(numero1, numero2);

if ( resultadoDivisao != null)
    console.log("O Resultado da divis√£o √©: " + resultadoDivisao);
else
    console.log("N√£o existe divis√£o por zero");

function somar(numero1: number, numero2: number): number {
    return numero1 + numero2;
}

function subtrair(numero1: number, numero2: number): number {
    return numero1 - numero2;
}

function multiplicar(numero1: number, numero2: number): number {
    return numero1 * numero2;
}

function dividir(numero1: number, numero2: number): number|null {
    let divisao = numero1 / numero2;

    return (divisao != Infinity ? divisao : null)
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
Digite o primeiro numero: 10
Digite o segundo numero: 5
O Resultado da soma √©: 15
O Resultado da subtra√ß√£o √©: 5     
O Resultado da multiplica√ß√£o √©: 50
O Resultado da divis√£o √©: 2       
Calculadora constru√≠da por... 
```

Observe que as Fun√ß√µes **somar(), subtrair(), multiplicar() e dividir()**, recebem 2 par√¢metros (vari√°veis) do tipo  **number** e retornam o resultado da respectiva opera√ß√£o matem√°tica atrav√©s do comando **return**, que retornar√° um n√∫mero. A Fun√ß√£o **turma()**, n√£o retorna nenhum valor, por se tratar de uma Fun√ß√£o **void**. 

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 07: Calculadora com M√©todos - Refatorando:



Observe que o C√≥digo da Calculadora, utilizando Fun√ß√µes para realizar as Opera√ß√µes Matem√°ticas, foi constru√≠do integralmente dentro de uma √∫nica Classe. No desenvolvimento de pequenas aplica√ß√µes, pode ser  vi√°vel manter todo o c√≥digo na mesma Classe e Pasta. Entretanto, para  aplica√ß√µes maiores, colocar todo o c√≥digo em uma √∫nica Classe ou todas as Classes em uma mesma pasta, sem uma organiza√ß√£o, pode aumentar significativamente a possibilidade de  conflitos entre as Classes (Classes com o mesmo nome no mesmo escopo), al√©m de dificultar a localiza√ß√£o de um determinado trecho de c√≥digo, fun√ß√£o ou criar  problemas de visibilidade (no caso dos M√©todos), que veremos mais adiante.

A solu√ß√£o para esses problemas est√° na **Refatora√ß√£o do c√≥digo**, onde separaremos os c√≥digos por funcionalidades semelhantes em Classes diferentes, que por sua vez ser√£o organizadas em **pastas** de acordo com as semelhan√ßas de funcionalidades. Geralmente, todas as Classes que possuem fun√ß√µes similares s√£o colocadas em uma **Pasta** identificada pela funcionalidade. Na imagem abaixo, vemos o projeto Calculadora estruturado em pastas:

<div align="center"><img src="https://i.imgur.com/bRaoh6I.png" title="source: imgur.com" /></div>

Observe que criamos uma pasta chamada **calculadora**, que ser√° a pasta raiz do projeto. Dentro da pasta raiz, criamos a pasta **operacoes**. Dentro da pasta **operacoes** criamos uma Classe chamada **Calculos**, onde implementaremos as Fun√ß√µes de C√°lculo (**somar(), subtrair(), multiplicar() e dividir()**) e a Fun√ß√£o **mensagem()**. Na pasta raiz, criamos a Classe **Calculadora**, onde implementaremos a L√≥gica de Entrada de dados, Chamada das Fun√ß√µes e a Sa√≠da de dados, com o resultado do processamento das Fun√ß√µes.

**Classe Calculos**

```ts

export function somar(numero1: number, numero2: number): number {
    return numero1 + numero2;
}

export function subtrair(numero1: number, numero2: number): number {
    return numero1 - numero2;
}

export function multiplicar(numero1: number, numero2: number): number {
    return numero1 * numero2;
}

export function dividir(numero1: number, numero2: number): number | null {
    let divisao = numero1 / numero2;

    return (divisao != Infinity ? divisao : null)
}

export function turma(): void {
    console.log("Calculadora constru√≠da por...");
}
```

Observe que adicionamos nas assinaturas de todas as Fun√ß√µes a palavra reservada **export**. Quando inserimos a palavra reservada export na assinatura de uma Fun√ß√£o, estamos indicando que esta Fun√ß√£o pode ser Importada e utilizada por outras Classes. Sem a palavra reservada export, a Fun√ß√£o estaria dispon√≠vel apenas na Classe onde foi criada.

**Classe Calculadora**

```ts
import readline from 'readline-sync';
import { dividir, multiplicar, somar, subtrair, turma } from './operacoes/Calculos';

let resultadoDivisao: number | null;

let numero1: number = readline.questionFloat("Digite o primeiro numero: ");
let numero2: number = readline.questionFloat("Digite o segundo numero: ");

console.log("O Resultado da soma √©: " + somar(numero1, numero2));

console.log("O Resultado da subtra√ß√£o √©: " + subtrair(numero1, numero2));

console.log("O Resultado da multiplica√ß√£o √©: " + multiplicar(numero1, numero2));

resultadoDivisao = dividir(numero1, numero2);

if (resultadoDivisao != null)
    console.log("O Resultado da divis√£o √©: " + resultadoDivisao);
else
    console.log("N√£o existe divis√£o por zero");

turma();

```

Note que para utilizarmos as Fun√ß√µes da **Classe Calculos** foi necess√°rio importar cada um deles no inicio da Classe **Calculadora**, atrav√©s da palavra reservada **import**.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
Digite o primeiro numero: 10
Digite o segundo numero: 5
O Resultado da soma √©: 15
O Resultado da subtra√ß√£o √©: 5     
O Resultado da multiplica√ß√£o √©: 50
O Resultado da divis√£o √©: 2       
Calculadora constru√≠da por... 
```

O Resultado do c√≥digo ser√° o mesmo do exemplo anterior, entretanto o nosso c√≥digo est√° organizado e com as funcionalidades separadas.

<br />

| <img src="https://i.imgur.com/L338M2G.png" title="source: imgur.com" width="138px"/> | **DESAFIO:** *Quais melhorias poderiam ser realizadas no c√≥digo da Calculadora? An√°lise o c√≥digo acima e fa√ßa algumas melhorias no c√≥digo e/ou implemente novas fun√ß√µes como C√°lculo da Pot√™ncia, Raiz Quadrada, entre outras. A melhor forma de aprender e compreender uma Linguagem de Programa√ß√£o √© praticando!* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="" target="_blank"><b>C√≥digo Fonte dos Exemplos</b></a></div>

<br />

------

## üîë**Pontos chave:**

1. Uma **Fun√ß√£o** √© um bloco de c√≥digo escrito para executar um conjunto espec√≠fico de tarefas. 
2. Para definir uma fun√ß√£o utilizamos a palavra-chave **function**. 
3. O corpo da fun√ß√£o √© escrito dentro do escopo, delimitado por um par chaves, semelhante aos La√ßos Condicionais de Repeti√ß√£o.
4. **Uma Fun√ß√£o deve realizar apenas uma tarefa para facilitar os processos de testagem e depura√ß√£o**;
5. Uma Fun√ß√£o pode ter um ou mais tipos de retorno (number, boolean, String, entre outros) ou n√£o retornar nada (void);
6. Um M√©todo pode receber nenhum, um ou mais argumentos que correspondam a diferentes tipos de dados de entrada e esses dados podem ser processados e/ou utilizados dentro do c√≥digo do m√©todo.
7. Um Argumento da Fun√ß√£o pode ter mais de um tipo de dado.
8. Um **M√©todo** √© uma Fun√ß√£o associada √† Classe, ou seja, uma a√ß√£o sobre um Objeto definido pela Classe. 

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>	