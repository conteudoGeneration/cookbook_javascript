<h1>Estrutura de Dados</h1>



As estruturas de dados s√£o uma forma de organizar e armazenar dados em computadores, de forma que possamos realizar opera√ß√µes com mais efici√™ncia. As estruturas de dados t√™m um escopo amplo e diversificado, em toda a √°rea de ci√™ncia da computa√ß√£o e engenharia de software. 

Em termos simples, uma estrutura de dados √© um cont√™iner que armazena  dados em um layout espec√≠fico. Esse "layout" permite que a estrutura de  dados seja eficiente em algumas opera√ß√µes e ineficiente em outras. Seu  objetivo √© entender as estruturas de dados de modo que voc√™ consiga  escolher a mais adequada para o problema apresentado.

Estruturas de dados s√£o utilizadas em quase todos os sistemas ou softwares escritos para os mais diversos fins, inclusive em nosso curso voc√™ j√° utilizou algumas e nem percebeu. 

<br />

<h3>Por que precisamos de estruturas de dados ?</h3>

Como as estruturas de dados s√£o usadas para armazenar dados de uma forma  organizada, e como os dados s√£o a entidade mais crucial na Ci√™ncia da Computa√ß√£o, fica claro o verdadeiro valor das estruturas de dados.

Independentemente do problema que voc√™ esteja resolvendo, de uma forma ou de outra, ter√°  que lidar com dados ‚Äî seja o sal√°rio de um empregado, pre√ßos de a√ß√µes, uma lista de compras de um e-commerce, ou mesmo uma simples lista de telefones.

Com  base em diferentes cen√°rios, os dados precisam ser guardados em um  formato espec√≠fico e para este fim existem algumas estruturas de dados que satisfazem as nossas necessidades de armazenar dados em diferentes formatos.

Vamos conhecer algumas das Estruturas de dados mais conhecidas:

<h2>1. Array</h2>



**Array** foi primeira estrutura de dados que estudamos e √© a mais popular, simples e amplamente utilizada no dia a dia pelas pessoas desenvolvedoras. √â uma estrutura de dados baseada em √≠ndice, o que significa que cada elemento √© referenciado por um √≠ndice. √â uma estrutura de tamanho fixo, que cont√©m itens de um mesmo tipo  de dados. Um array pode ser classificado em 3 categorias

1. **Unidimensionais (Vetor):** Um Array composto por uma √∫nica dimens√£o, ou seja, uma √∫nica linha composta por N colunas do mesmo do tipo, onde N √© o n√∫mero m√°ximo de elementos, que o vetor armazenar√°. Para acessar cada elemento, utilizamos o numero da coluna: `vetor[coluna]`.

<div align="center"><img src="https://i.imgur.com/uAj5USU.png" title="source: imgur.com" /></div>

2. **Bidimensionais (Matriz):** Um Array composto por duas dimens√µes, ou seja, o par linha (I) e coluna (J), onde I √© o n√∫mero m√°ximo de linhas e J √© o n√∫mero m√°ximo de colunas que a Matriz possui. Para saber quantos elementos a Matriz pode armazenar, precisamos multiplicar o numero de linhas pelo numero de colunas. **Exemplo:** Matriz 3 x 3 (3 linhas por 3 colunas), possui a capacidade de armazenar at√© 9 elementos (3 * 3 = 9). Para acessar cada elemento, utilizamos o par: `matriz[linha][coluna]`.

<div align="center"><img src="https://i.imgur.com/n96Fbia.png" title="source: imgur.com" /></div>

3. **Multidimensionais:** Um Array que possui 3 ou mais dimens√µes, embora matematicamente s√≥ √© poss√≠vel representar at√© 3 dimens√µes. Um Array tridimensional, por exemplo, pode ser visto como uma matriz composta por N Matrizes. Para acessar cada elemento, utilizamos o trio: `matriz3d[numero_da_matriz][linha][coluna]`.

<div align="center"><img src="https://i.imgur.com/qI8qwAx.png" title="source: imgur.com" /></div>

<br />

No t√≥pico Arrays, vimos como implementar Arrays unidimensionais (vetores) e bidimensionais (matrizes). No t√≥pico Collections, vimos tamb√©m como implementar um Array din√¢mico, ou seja, sem tamanho fixo. 

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="100px"/> | <div align="left">**DICA:** *Caso voc√™ tenha alguma d√∫vida sobre Arrays, consulte o Cookbook sobre Arrays, dispon√≠vel neste [link](09.md).* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h2>2. Hash</h2> 



**Hash** foi a segunda estrutura de dados que estudamos, atrav√©s da Collection **Set**, que √© uma das implementa√ß√µes Hash mais r√°pidas. Ela √© indicada se voc√™ precisa apenas garantir a alta performance sem se importar com a ordem com que os elementos est√£o ordenados. Set √© uma Collection que armazena elementos exclusivos, ao contr√°rio do **Array**, que permitem elementos duplicados.

<br />

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="100px"/> | <div align="left">**DICA:** *Caso voc√™ tenha alguma d√∫vida sobre a Collection Set, consulte o Cookbook sobre Collections, dispon√≠vel neste [link](12.md).* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

Na sequ√™ncia, vamos conhecer outras 2 Estruturas de dados: **Fila** e **Pilha**.

<h2>3. Fila</h2>



Uma **Fila** √© uma estrutura de dados do tipo **FIFO**: *"o primeiro elemento que entra √© o primeiro elemento que sai"* (first in, first out).  A ideia fundamental da fila √© que s√≥ podemos inserir um novo elemento no final da fila e s√≥ podemos retirar um elemento do inicio. A estrutura fila √© uma analogia natural com o conceito de fila que usamos no nosso dia a dia: A primeira pessoa a entrar na fila ser√° a primeira pessoa a ser atendida (sair da fila). 

<div align="center"><img src="https://i.imgur.com/h43C5MC.png" title="source: imgur.com" /></div>

Observe na imagem acima que a Fila permite manipula√ß√£o nas duas extremidades: no in√≠cio (frente) e no fim (cauda). As Inser√ß√µes s√£o feitas na cauda e as Remo√ß√µes s√£o feitas na frente. 

<br />

<h3>3.1. A Classe Queue</h3>



Para a implementarmos a estrutura de dados Fila, vamos criar uma Classe chamada **Queue**,  que √© uma Classe que modela e implementa a estrutura de dados Fila, seguindo o princ√≠pio **FIFO** (**First-In-First-Out**). Vamos criar esta Classe porque o TypeScript/JavaScript n√£o possui uma implementa√ß√£o nativa ou uma Collection, como o Java e o C#, que implementa a Estrutura de dados Fila.

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Implementa√ß√£o da Classe Queue:**

```ts
interface queueInterface<Type> {
   enqueue(dataItem: Type): void;
   dequeue(): Type | undefined;
   isEmpty(): boolean;
   count(): number;
   printQueue(): void;
   peek(): Type | undefined;
   contains(dataItem: Type): boolean;
   clear(): void;
}

export class Queue<Type> implements queueInterface<Type> {

   private QueueData: Array<Type> = [];

   constructor() { }

   isEmpty(): boolean {
      let result = this.QueueData.length <= 0;
      return result;
   }

   enqueue(dataItem: Type): void {
      this.QueueData.push(dataItem);
   }

   dequeue(): Type | undefined {
      if (this.isEmpty()) {
         console.log("A fila est√° vazia");
         return;
      } else {
         var element = this.QueueData.shift();
         return element;
      }
   }

   count(): number {
      let len = this.QueueData.length;
      return len;
   }

   printQueue(): void {
      for (let i = 0; i < this.QueueData.length; i++) {
         console.log(this.QueueData[i]);
      }
   }

   peek(): Type | undefined {
      if (this.isEmpty()) {
         console.log("A fila est√° vazia");
         return;
      } else {
         var element = this.QueueData[0];
         return element;
      }
   }

   contains(dataItem: Type): boolean {
      if (this.QueueData.includes(dataItem)) {
         return true;
      } else {
         return false;
      }
   }

   clear(): void {
      this.QueueData.length = 0;
   }

}
```

Para criar uma nova fila, utilizaremos o construtor abaixo:

**Sintaxe:**

```java
const fila = new Queue<T>();
```

O item **`<T>`** representa um **Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado na Fila. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma de uma **Classe criada pela pessoa desenvolvedora**.

<br />

<h3>M√©todos da Classe Queue</h3>

Na tabela abaixo, listamos os principais M√©todos e Propriedades para trabalharmos com a Classe **Queue**:

| M√©todo / Propriedade   | Descri√ß√£o                                                    |
| ---------------------- | ------------------------------------------------------------ |
| **enqueue(elemento)**  | Este m√©todo √© usado para adicionar um elemento no final da fila. |
| **count()**            | Este m√©todo √© usado para retornar o n√∫mero de elementos da fila. |
| **clear()**            | Este m√©todo √© usado para remover todos os elementos da fila. |
| **dequeue()**          | Este m√©todo √© usado para remover o primeiro elemento da fila. |
| **contains(elemento)** | Este m√©todo √© usado para verificar se a fila cont√©m o elemento fornecido ou n√£o. Retorna `true` se a fila contiver o elemento. |
| **peek()**             | Este m√©todo √© usado para exibir, mas n√£o remover, o elemento que est√° sendo apontado pelo ponteiro HEAD desta fila (o primeiro elemento), ou retornar nulo se esta fila estiver vazia. |
| **isEmpty()**          | Este retorna `true` se a fila est√° vazia.                    |
| **printQueue()**       | Exibe na tela todos os elementos da fila.                    |

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 01 - Fila:

No exemplo abaixo, vamos construir uma **Fila**, contendo uma lista de n√∫meros e faremos alguns testes com os M√©todos da **Classe Queue**.

```ts
import { Queue } from "./Queue";

const fila = new Queue<number>();

for (let i = 1; i <= 10; i++){
    fila.enqueue(i);
}

console.log("\nExibir todos os Elementos da fila: ");

fila.printQueue();

console.log("\nRemover Elemento: " + fila.dequeue());

console.log("\nExibir todos os Elementos da fila: ");

fila.printQueue();

console.log("\nAdicionar Elemento 11: ");
            
fila.enqueue(11);

console.log("\nExibir todos os Elementos da fila: ");

fila.printQueue();

console.log("\nExibir o Primeiro Elemento da fila: " + fila.peek());

console.log("\nExibir o Tamanho da fila: " + fila.count());

console.log("\nChecar se o Elemento 4 existe na fila? " + fila.contains(4));

console.log("\nChecar se o Elemento 14 existe na fila? " + fila.contains(14));

console.log("\nLimpar a fila");

fila.clear();

console.log("\nA fila est√° vazia? " + fila.isEmpty());
```

O resultados deste exemplo, voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exibir todos os Elementos da fila: 
1
2
3
4
5
6
7
8
9
10

Remover Elemento: 1

Exibir todos os Elementos da fila:
2
3
4
5
6
7
8
9
10

Adicionar Elemento 11:

Exibir todos os Elementos da fila:
2
3
4
5
6
7
8
9
10
11

Exibir o Primeiro Elemento da fila: 2

Exibir o Tamanho da fila: 10

Checar se o Elemento 4 existe na fila? true

Checar se o Elemento 14 existe na fila? false

Limpar a fila

A fila est√° vazia? true
```

Observe no c√≥digo acima que um novo elemento sempre ser√° inserido no final da fila e sempre ser√° retirado o primeiro elemento da fila.

<br />

<h2>4. Pilha</h2>



Uma **Pilha** √© uma estrutura de dados do tipo **LIFO**: *"O √∫ltimo elemento inserido na pilha √© o primeiro elemento que ser√° retirado da pilha."* (**Last In -  First Out**). A ideia fundamental da pilha √© que s√≥ podemos inserir ou retirar um elemento do topo da pilha. Essa Estrutura de dados √© chamada de ‚Äúpilha‚Äù porque se assemelha a uma pilha do mundo real, como por exemplo uma pilha de pratos, onde o √∫ltimo prato inserido na pilha, √© o primeiro a ser retirado.

<div align="center"><img src="https://i.imgur.com/y8maSln.png" title="source: imgur.com" /></div>

Observe na imagem acima, que as 2 opera√ß√µes b√°sicas que podem ser realizadas em uma pilha s√£o inserir um elemento na pilha (Push) e retirar um elemento da pilha (Pop). 

- **PUSH** ou empurrar, insere um elemento no topo da pilha. 
- **POP** ou Excluir, retira o elemento do topo da pilha (retornando-o ou n√£o). 

<br />

<h3>4.1. A Classe Stack</h3>



Para a implementarmos a estrutura de dados Pilha, vamos criar uma Classe chamada **Stack**, que √© uma Classe que modela e implementa a estrutura de dados Pilha, seguindo o princ√≠pio **Last In -  First Out**. Vamos criar esta Classe porque o TypeScript/JavaScript n√£o possui uma implementa√ß√£o nativa ou uma Collection, como o Java e o C#, que implementa a Estrutura de dados Fila.

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Implementa√ß√£o da Classe Stack:**

```ts
interface stackInterface<Type> {
    push(dataItem: Type): void;
    pop(): Type | undefined;
    isEmpty(): boolean;
    count(): number;
    printStack(): void;
    peek(): Type | undefined;
    contains(dataItem: Type): boolean;
    clear(): void;
 }
 
 export class Stack<Type> implements stackInterface<Type> {
 
    private StackData: Array<Type> = [];
 
    constructor() { }
 
    isEmpty(): boolean {
       let result = this.StackData.length <= 0;
       return result;
    }
 
    push(dataItem: Type): void {
       this.StackData.push(dataItem);
    }
 
    pop(): Type | undefined {
       if (this.isEmpty()) {
          console.log("A fila est√° vazia");
          return;
       } else {
          var element = this.StackData.pop();
          return element;
       }
    }
 
    count(): number {
       let len = this.StackData.length;
       return len;
    }
 
    printStack(): void {
       for (let i = this.StackData.length - 1; i >= 0 ; i--) {
          console.log(this.StackData[i]);
       }
    }
 
    peek(): Type | undefined {
       if (this.isEmpty()) {
          console.log("A fila est√° vazia");
          return;
       } else {
          var element = this.StackData[this.StackData.length - 1];
          return element;
       }
    }
 
    contains(dataItem: Type): boolean {
       if (this.StackData.includes(dataItem)) {
          return true;
       } else {
          return false;
       }
    }
 
    clear(): void {
       this.StackData.length = 0;
    }
 
 }
```

Para criar uma nova fila, utilizaremos o construtor abaixo:

**Sintaxe:**

```c#
const pilha = new Stack<T>();
```

O construtor sem argumento padr√£o cria um Objeto da Classe **Stack** novo e vazio.

O item **`<T>`** representa um **Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado na Pilha. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma de uma **Classe criada pela pessoa desenvolvedora**.

<br />

<h3>Principais M√©todos e Propriedades da Classe Stack</h3>

Na tabela abaixo, listamos os principais M√©todos e Propriedades para trabalharmos com a Collection **Stack**:

| M√©todo / Propriedade   | Descri√ß√£o                                                    |
| ---------------------- | ------------------------------------------------------------ |
| **push(elemento)**     | Este m√©todo √© usado para adicionar um elemento no topo da pilha. |
| **count**              | Esta propriedade √© usada para retornar o tamanho da pilha.   |
| **clear()**            | Este m√©todo √© usado para remover todos os elementos da pilha. |
| **pop()**              | Este m√©todo √© usado para remover um elemento no topo da pilha. |
| **contains(elemento)** | Este m√©todo √© usado para verificar se a pilha cont√©m o elemento fornecido ou n√£o. Retorna verdadeiro se a pilha contiver o elemento, caso contr√°rio, falso. |
| **peek()**             | Este m√©todo √© usado para exibir, sem remover, o elemento no topo da Pilha, ou retorna nulo se a pilha estiver vazia. |
| **isEmpty()**          | Este retorna `true` se a pilha est√° vazia.                   |
| **printStack()**       | Exibe na tela todos os elementos da pilha.                   |

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 02 - Pilha:

No exemplo abaixo, vamos construir uma **pilha**, contendo uma pilha de pratos identificados pela cor e na sequ√™ncia faremos alguns testes com os M√©todos da Classe Stack.

```ts
import { Stack } from "./Stack";

const pilha = new Stack<string>();

pilha.push("Prato Verde");
pilha.push("Prato Azul");
pilha.push("Prato Branco");
pilha.push("Prato Amarelo");
pilha.push("Prato Vermelho");

console.log("\nExibir todos os Elementos da pilha: ");

pilha.printStack();

console.log("\nRemover Elemento: " + pilha.pop());

console.log("\nExibir todos os Elementos da pilha: ");

pilha.printStack();

console.log("\nAdicionar Elemento 11: ");

pilha.push("Prato Roxo");

console.log("\nExibir todos os Elementos da pilha: ");

pilha.printStack();

console.log("\nExibir o Primeiro Elemento da pilha: " + pilha.peek());

console.log("\nExibir o Tamanho da pilha: " + pilha.count());

console.log("\nChecar se o Elemento Prato Verde existe na pilha? " + pilha.contains("Prato Verde"));

console.log("\nChecar se o Elemento Prato Verde Lim√£o existe na pilha? " + pilha.contains("Prato Verde Lim√£o"));

console.log("\nLimpar a pilha");

pilha.clear();

console.log("\nA pilha est√° vazia? " + pilha.isEmpty());
```

O resultados deste exemplo, voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exibir todos os Elementos da pilha: 
Prato Vermelho
Prato Amarelo
Prato Branco
Prato Azul
Prato Verde

Remover Elemento: Prato Vermelho

Exibir todos os Elementos da pilha:
Prato Amarelo
Prato Branco
Prato Azul
Prato Verde

Adicionar Elemento 11:

Exibir todos os Elementos da pilha:
Prato Roxo
Prato Amarelo
Prato Branco
Prato Azul
Prato Verde

Exibir o Primeiro Elemento da pilha: Prato Roxo

Exibir o Tamanho da pilha: 5

Checar se o Elemento Prato Verde existe na pilha? true

Checar se o Elemento Prato Verde Lim√£o existe na pilha? false     

Limpar a pilha

A pilha est√° vazia? true
```

Observe no c√≥digo acima que um elemento sempre ser√° inserido e retirado do topo da pilha.

<br />

<h2>5. Outras Estruturas de dados</h2>



Vamos conhecer outras Estruturas de Dados, que s√£o muito utilizadas especialmente na pesquisa e manipula√ß√£o de dados. Aqui faremos apenas um overview e indicaremos algumas refer√™ncias, que voc√™ poder√° utilizar para complementar os seus estudos sobre o tema.

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="120px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Orienta√ß√£o ao Futuro em rela√ß√£o as Estruturas de dados. Neste √∫ltimo t√≥pico faremos um breve overview sobre outras Estruturas de Dados. Estruturas de dados √© um recurso muito utilizado no dia a dia pelas pessoas desenvolvedoras, mas √© um assunto muito amplo, que requer tempo, pr√°tica e persist√™ncia.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h3>5.1 Lista Encadeada (Linked List)</h3>



√â uma estrutura sequencial que consiste em uma s√©rie de itens em ordem  linear que est√£o ligadas entre si. Portanto, voc√™ tem que acessar os  dados sequencialmente e o acesso aleat√≥rio n√£o √© poss√≠vel. Os elementos  s√£o conhecidos como **n√≥s**, onde cada n√≥ cont√©m uma **chave** e um **ponteiro**  para o proximo n√≥. O atributo chamado **Head** (cabe√ßa) aponta para o primeiro  elemento da lista e o √∫ltimo elemento √© conhecido como **Tail** (cauda).

Listas Encadeadas podem ser implementadas de 2 formas principais: 

- **LISTA ENCADEADA SIMPLES (SINGLE LINKED)**  -  Seus elementos s√≥ podem ser percorridos em uma dire√ß√£o, atrav√©s de um ponteiro chamado **next** (pr√≥ximo). 

<div align="center"><img src="https://i.imgur.com/75ATOqR.png" title="source: imgur.com" /></div>

- **LISTA DUPLAMENTE ENCADEADAS  (DOUBLE LINKED)** ‚Äì Os n√≥s podem ser pecorridos para frente e para tr√°s,  gra√ßas um ponteiro adicional chamado **prev** (anterior), apontando para o n√≥ anterior ao elemento. 

 <div align="center"><img src="https://i.imgur.com/s67yOIi.png" title="source: imgur.com" /></div>

Neste tipo de estrutura, as opera√ß√µes de inser√ß√£o e exclus√£o de itens s√£o muito mais r√°pidas, porque para inserir um item em qualquer posi√ß√£o da lista, por exemplo, basta copiar os  dados dos ponteiros (prev e next) do n√≥ atual, para os respectivos  endere√ßos do n√≥ a ser inclu√≠do, e substituir os valores nos n√≥s de destino. O mesmo princ√≠pio se aplica a exclus√£o de itens. 

O uso mais comum de uma lista ligada √© **quando precisamos adicionar e remover elementos no in√≠cio ou final da lista,  acessar os elementos no in√≠cio ou final e percorrer uma lista elemento por elemento**. A Estrutura de dados   LinkedList √© muito utilizada para implementar Pilhas e Filas.

<br />

<h3>5.2. √Årvore (Tree)</h3>

Uma √°rvore √© uma estrutura hier√°rquica  em que os dados s√£o organizados hierarquicamente e vinculados entre os  ramos pais e filhos. Essa estrutura √© diferente de uma lista vinculada,  ao passo que, em uma lista vinculada, os itens s√£o vinculados em uma  ordem linear.

V√°rios tipos de √°rvores foram  desenvolvidos ao longo das √∫ltimas d√©cadas, a fim de se adequar a certas aplica√ß√µes e atender a certas restri√ß√µes. Alguns exemplos s√£o:

-  √Årvore de pesquisa bin√°ria;
-  √Årvore red-black; 
-  √Årvore splay;
-  √Årvore AVL

**√Årvores Bin√°rias de Busca**

Uma √°rvore de pesquisa bin√°ria, como o  nome sugere, √© uma √°rvore bin√°ria onde os dados s√£o organizados em uma  estrutura hier√°rquica. Esta estrutura de dados armazena valores em ordem de classifica√ß√£o. Cada n√≥ em uma √°rvore de pesquisa bin√°ria compreende uma **CHAVE (KEY)**, que √© o valor do n√≥, um ponteiro para o n√≥ a direita,  outro para o n√≥ a esquerda (maior e menor) e um ponteiro para o n√≥ pai. As √Årvores bin√°rias s√£o usadas para implementar analisadores e  solucionadores de express√µes.

<div align="center"><img src="https://i.imgur.com/BsD6Z1f.png" title="source: imgur.com" /></div>

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="https://github.com/rafaelq80/exemplos_js/tree/main/typescript/estrutura_dados" target="_blank"><b>C√≥digo Fonte dos Exemplos</b></a></div>

<br />

------

## üîë**Pontos chave:**

- **Estruturas de Dados** s√£o uma forma de organizar e armazenar dados em computadores, de forma que possamos realizar opera√ß√µes com mais efici√™ncia. 
- As estruturas de dados fornecem reutiliza√ß√£o de dados, ou seja, ap√≥s implementar uma determinada estrutura de dados uma vez, podemos us√°-la muitas vezes em qualquer outro lugar. 
- **Array** √© uma estrutura de dados baseada em √≠ndice, o que significa que cada elemento √© referenciado por um √≠ndice. √â uma estrutura de tamanho fixo, que cont√©m itens de um mesmo tipo  de dados.
- **Set** √© uma das Estruturas de Dados mais r√°pidas, porque ela utiliza internamente uma estrutura **Hash** e seus elementos n√£o s√£o ordenados. Ela √© indicada se voc√™ precisa apenas garantir a alta performance sem se importar muito com a ordena√ß√£o e precisa garantir que n√£o hajam elementos duplicados. 
- **Fila** √© uma estrutura de dados do tipo **FIFO**: "o primeiro elemento que entra √© o primeiro elemento que sai" (first in, first out).  A ideia fundamental da fila √© que s√≥ podemos inserir um novo elemento no final da fila e s√≥ podemos retirar um elemento do inicio. 
- **Pilha** √© uma estrutura de dados do tipo **LIFO**: *"O √∫ltimo elemento inserido na pilha √© o primeiro elemento que ser√° retirado da pilha."* (**Last In -  First Out**). A ideia fundamental da pilha √© que s√≥ podemos inserir ou retirar um elemento do topo da pilha.
- Existem outras Estruturas de dados como as **Listas Ligadas**, **Listas Duplamente Ligadas** e as **√Årvores Bin√°rias**, que possuem outras caracter√≠sticas e usos espec√≠ficos.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
