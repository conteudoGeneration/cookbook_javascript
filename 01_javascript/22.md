<h1>Programa√ß√£o Ass√≠ncrona - Parte 01</h1>



Nas √∫ltimas d√©cadas, as Linguagens de Programa√ß√£o tem evolu√≠do muito e nesta evolu√ß√£o se tornou prioridade a cria√ß√£o de ferramentas e recursos, com o objetivo de construir projetos cada vez nais eficientes, robustos e simples de codificar. Neste contexto surgiu dentro do JavaScript e por consequ√™ncia dentro do TypeScript a teoria da **Programa√ß√£o Ass√≠ncrona**, com o objetivo de ajudar voc√™ a dividir projetos grandes e complexos em tarefas menores, que executam de forma simult√¢nea.

Para aplicar esta teoria na pr√°tica e executar essas pequenas tarefas de uma maneira que voc√™ obtenha os melhores resultados com alto desempenho, o TypeScript/JavaScript nos oferece tr√™s t√©cnicas de processamento ass√≠ncrono:

- **Callbacks**;
- **Promisses**;
- **Async / Await**.

Neste conte√∫do, vamos conhecer cada uma delas, mas antes precisamos compreender a diferen√ßa entre **S√≠ncrono e Ass√≠ncrono**.

<br />

<h2>Sistema S√≠ncrono</h2>



Em um **Sistema S√≠ncrono**, as tarefas s√£o conclu√≠das uma ap√≥s a outra. Pense nisso como se voc√™ tivesse apenas uma m√£o para realizar 10 tarefas. Ent√£o, voc√™ tem que completar uma tarefa de cada vez. 

Imagine se criarmos uma aplica√ß√£o TypeScript simples, contendo quatro fun√ß√µes s√≠ncronas e se cada uma dessas fun√ß√µes s√≠ncronas demorar 1 segundo para finalizar, como mostra o gr√°fico abaixo:

<div align="center"><img src="https://i.imgur.com/tq8cQrL.png" title="source: imgur.com" /></div>

No modelo S√≠ncrono o servidor vai executar a primeira fun√ß√£o, aguardar 1 segundo para que ela seja finalizada, e somente quando ela for finalizada, a segunda fun√ß√£o ser√° executada. O servidor aguardar√° novamente a segunda fun√ß√£o finalizar, para s√≥ ent√£o executar a terceira fun√ß√£o. O servidor aguardar√° novamente a terceira fun√ß√£o finalizar, para s√≥ ent√£o executar a quarta fun√ß√£o. Ap√≥s quatro segundos tudo ter√° finalizado. Esse comportamento de aguardar um bloco de c√≥digo finalizar para s√≥ ent√£o continuar a leitura do restante do c√≥digo √© o que chamamos de **Comportamento S√≠ncrono**, que inclusive √© o comportamento padr√£o da Linguagem TypeScript/JavaScript **(single threaded)**. 

<br />

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Exemplo 01 - Simula√ß√£o de um C√≥digo S√≠ncrono:** 


```ts
console.log(" TypeScript ");

console.log(" JavaScript ");

console.log(" Comportamento ");

console.log(" S√≠ncrono ");
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
 TypeScript 
 JavaScript    
 Comportamento 
 S√≠ncrono
```

Observe que cada instru√ß√£o do c√≥digo foi executada somente ap√≥s a anterior ser conclu√≠da.

<br />

<h2>Sistema Ass√≠ncrono</h2>



Em um **Sistema Ass√≠ncrono**, as tarefas s√£o conclu√≠das de forma independente. Pense nisso como se voc√™ tivesse 10 tarefas para serem realizadas e voc√™ tivesse 10 m√£os para realiz√°-las. Assim, cada uma das suas 10 m√£os poderia se encarregar de realizar uma tarefa de forma independente e ao mesmo tempo.

Imagine Se criarmos uma aplica√ß√£o TypeScript simples, contendo quatro fun√ß√µes ass√≠ncronas e se cada uma dessas fun√ß√µes ass√≠ncronas demorar aproximadamente 1 segundo para finalizar, como mostra o gr√°fico abaixo:

<div align="center"><img src="https://i.imgur.com/8ewYsOM.png" title="source: imgur.com" /></div>

O servidor executar√° a primeira fun√ß√£o e n√£o vai esperar que essa fun√ß√£o seja finalizada para executar as demais. Ele executar√° a primeira e no mesmo momento executar√° a segunda, a terceira e a quarta. Como todas ser√£o executadas  no mesmo momento, aproximadamente ap√≥s 1 segundo todas as fun√ß√µes ter√£o sido finalizadas, mas n√£o na mesma ordem em que elas foram chamadas. Esse comportamento de n√£o esperar um bloco de c√≥digo finalizar para executar um outro bloco de c√≥digo √© o que chamamos de **Comportamento Ass√≠ncrono**.

<br />

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Exemplo 02 - Simula√ß√£o de um C√≥digo Ass√≠ncrono:** 


```ts
console.log(" TypeScript ");

setTimeout(() => {
    console.log(" JavaScript ");
}, 2000)

setTimeout(() => {
    console.log(" Comportamento ");
}, 3000)

console.log(" Ass√≠ncrono ");
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
TypeScript 
Ass√≠ncrono 
JavaScript 
Comportamento 
```

Observe que nesta simula√ß√£o, todas as instru√ß√µes do c√≥digo foram executadas sem ficar aguardando a conclus√£o das instru√ß√µes anteriores. Utilizamos o M√©todo **setTimeout()** para simular tempos de conclus√£o diferentes para cada instru√ß√£o, porque mesmo que duas ou mais Fun√ß√µes Ass√≠ncronas sejam executadas no mesmo instante, n√£o h√° garantia que ser√£o finalizadas no mesmo instante. Lembre-se que cada fun√ß√£o tem o seu pr√≥prio tempo de execu√ß√£o e al√©m disso, erros podem acontecer durante o processamento, principalmente nos casos em que a fun√ß√£o depende de recursos de terceiros.

<br />

<h3>Por que o conceito de Processamento Ass√≠ncrono √© t√£o importante?</h3>



O **Processamento Ass√≠ncrono** √© essencial para atividades que s√£o potencialmente pass√≠veis de bloqueio do sistema,  como por exemplo o acesso ao Banco de dados na WEB. O acesso a um recurso da Web √†s vezes √© lento ou atrasado. Se tal atividade for bloqueada em um processo s√≠ncrono, todo o aplicativo dever√° esperar at√© que a atividade seja finalizada. Em um processo ass√≠ncrono, o aplicativo poder√° prosseguir com outra tarefa que n√£o dependa do recurso da Web at√© a tarefa potencialmente causadora do bloqueio terminar, com um resultado de sucesso ou de falha.

Quando falamos de bloqueio da aplica√ß√£o, estamos falando em situa√ß√µes onde seu aplicativo literalmente n√£o  responde (trava), o que poderia levar o usu√°rio a concluir que o sistema falhou quando, na verdade, est√° apenas aguardando uma resposta. Quando voc√™ usa m√©todos ass√≠ncronos, o aplicativo continua a  responder e o usu√°rio poder√° aguardar a sua conclus√£o ou cancelar a opera√ß√£o.

Outro ponto importante √© que tanto aplica√ß√µes Backend quanto Frontend utilizam amplamente as fun√ß√µes ass√≠ncronas, logo √© fundamental compreender este conceito, para desenvolver os projetos dos pr√≥ximos blocos do curso.

<br />

<h2>Callback</h2>



Uma fun√ß√£o **Callback** **√© uma fun√ß√£o passada como argumento de outra fun√ß√£o, que √© ent√£o invocada dentro da fun√ß√£o externa para completar algum tipo de rotina ou a√ß√£o**. Veja na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/CUdga35.png" title="source: imgur.com" /></div>

Observe que a fun√ß√£o chamada **funcaoDois()**, recebe como par√¢metro a fun√ß√£o chamada **funcaoUm()**. A rela√ß√£o entre as duas fun√ß√µes foi criada atrav√©s da fun√ß√£o de Callback chamada **chama_funcaoUm()**.

<br />

<h3>Por que usamos callbacks?</h3>



Ao  fazer uma tarefa complexa, n√≥s quebramos essa tarefa em etapas menores. Para nos ajudar a estabelecer uma rela√ß√£o entre essas etapas, n√≥s utilizamos **Callbacks**.

Para entendermos melhor o funcionamento das Callbacks, vamos criar um projeto simples de uma Sorveteria. Para montar um sorvete, precisamos seguir algumas etapas, como vemos na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/V2rhlmn.png" title="source: imgur.com" width="80%"/></div>

O funcionamento b√°sico de uma Sorveteria depende do **Pedido** de um cliente, onde ele far√° a sele√ß√£o dos **Ingredientes**, que ir√£o compor o sorvete. Uma vez que temos um pedido, come√ßamos a **Produ√ß√£o** e, em seguida, **Servimos** o sorvete. Para come√ßar, vamos criar duas Arrow Functions:

- **pedido()**
- **producao(**)

<br />

<img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/>**Projeto Sorveteria - Callbacks:**

```ts
// Fun√ß√£o Receber Pedido
let pedido = () => { };

// Fun√ß√£o Iniciar a Produ√ß√£o
let producao = () => { };

```

Na sequ√™ncia, vamos estabelecer uma rela√ß√£o entre essas duas fun√ß√µes usando uma Callback:

```ts
// Fun√ß√£o Receber Pedido
let pedido = (executa_producao: any) =>{

    // Chamada da Fun√ß√£o Callback
    executa_producao();
};

// Fun√ß√£o Iniciar a Produ√ß√£o
let producao = () => { };
```

Observe que criamos a rela√ß√£o entre as fun√ß√µes **pedido()** e **producao()** atrav√©s de uma **Fun√ß√£o Callback**, chamada **executa_producao()**. No exemplo acima, ao executar a fun√ß√£o **pedido()**, a fun√ß√£o **producao()** ser√° executada simultaneamente, ao ser chamada pela Fun√ß√£o Callback **executa_producao()**.

Para visualizar este processo, vamos inserir mensagens nas 2 fun√ß√µes e chamar a fun√ß√£o **pedido()**, passando a fun√ß√£o **producao()** como argumento, como mostra o trecho de c√≥digo abaixo:

```ts
// Fun√ß√£o Receber Pedido
let pedido = (executa_producao: any) =>{

    // Mensagem
    console.log("Chegou um Pedido!")

    // Chamada da Fun√ß√£o Callback
    executa_producao();
};

// Fun√ß√£o Iniciar a Produ√ß√£o
let producao = () =>{
    
    // Mensagem
    console.log("Iniciar Produ√ß√£o!");
};

/* *
*  Chamada da Fun√ß√£o Receber Pedido, 
*  passando a Fun√ß√£o Produ√ß√£o como argumento
*/
pedido(producao);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Chegou um Pedido!
Iniciar Produ√ß√£o!
```

Observe que ao executar o nosso c√≥digo, a fun√ß√£o **pedido()** chamou a fun√ß√£o **producao()**, atrav√©s da **Fun√ß√£o Callback**.

<br />

Para produzir o sorvete, precisamos seguir algumas etapas, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/x9tgrUe.png" title="source: imgur.com" width="80%"/></div>

Estes s√£o os pequenos passos que voc√™ precisa executar para fazer o sorvete. Observe tamb√©m que, neste exemplo, a ordem dos passos e o tempo tamb√©m s√£o cruciais. Voc√™ n√£o pode, por exemplo, simplesmente cortar as frutas e servir  o sorvete ao mesmo tempo, ou seja, se um passo anterior n√£o for conclu√≠do, n√£o podemos passar para o pr√≥ximo passo.

Antes de implementarmos a produ√ß√£o, precisamos criar o nosso estoque e adicionar o argumento **fruta** na fun√ß√£o pedido, para que possamos receber a comanda com o pedido, como mostra o c√≥digo abaixo:

```ts

// Objeto que define o estoque da Sorveteria
let estoque = {
    Frutas : ["Morango", "Uva", "Banana", "Ma√ß√£"],
    Liquidos : ["Gelo", "√Ågua"],
    Suporte : ["Casquinha", "Pote", "Ta√ßa"],
    Toppings : ["Chocolate", "Castanha", "Granulado", "Pa√ßoca"],
 };

// Fun√ß√£o Receber Pedido
let pedido = (fruta: number, executa_producao: any) =>{

    // Mensagem
    console.log("Chegou um Pedido!")

    // Chamada da Fun√ß√£o Callback
    executa_producao();
};

// Fun√ß√£o Iniciar a Produ√ß√£o
let producao = () =>{
    
    // Mensagem
    console.log("Iniciar a Produ√ß√£o!");
};

/* *
*  Chamada da Fun√ß√£o Receber Pedido, 
*  passando a Fun√ß√£o Produ√ß√£o e 
*  a fruta como argumentos
*/
pedido(0, producao);
```

Note que criamos um Objeto chamado **estoque**, composto por arrays, que guardam os ingredientes do sorvete. al√©m disso, adicionamos o par√¢metro **fruta**, do tipo number (passaremos o √≠ndice da fruta no array **Frutas**), na fun√ß√£o **pedido()**. Note que a chamada da fun√ß√£o pedido, na ultima linha, tamb√©m foi modificada para receber o novo par√¢metro.

O pr√≥ximo passo, ser√° estabelecer os tempos necess√°rios para a conclus√£o de cada tarefa da produ√ß√£o, conforme a imagem abaixo:

 <div align="center"><img src="https://i.imgur.com/xrpg9My.png" title="source: imgur.com" width="80%"/></div>

Para estabelecer o tempo, vamos utilizar a fun√ß√£o **setTimeout()**, pois ela tamb√©m usa uma Fun√ß√£o Callback, recebendo uma fun√ß√£o como argumento:

**Sintaxe:**


```ts
setTimeout (() => { }, tempo_em_milissegundos)
```

- **() => { }**: Fun√ß√£o Calback
- **tempo_em_milissegundos**: o tempo de execu√ß√£o em milissegundos. **Exemplo:** *1 s ü°¢ 1000 milissegundos*

Na sequ√™ncia, vamos usar a fun√ß√£o **setTimeout**, como mostra o trecho de c√≥digo abaixo:


```ts

// Objeto que define o estoque da Sorveteria
let estoque = {
    Frutas : ["Morango", "Uva", "Banana", "Ma√ß√£"],
    Liquidos : ["Gelo"],
    Suporte : ["Casquinha", "Pote", "Ta√ßa"],
    Toppings : ["Chocolate", "Castanha", "Granulado", "Pa√ßoca"],
 };

// Fun√ß√£o Receber Pedido
let pedido = (fruta: number, executa_producao: any) =>{

    // Mensagem
    console.log("Chegou um Pedido!")

    // Fun√ß√£o de tempo
    setTimeout(function(){

        console.log(`A fruta ${estoque.Frutas[fruta]} foi selecionada`);
    
    // Chamada da Fun√ß√£o Callback
    executa_producao();
      },2000)

};

// Fun√ß√£o Iniciar a Produ√ß√£o
let producao = () =>{
    
    // Mensagem
    console.log("Iniciar Produ√ß√£o!");
};

/* *
*  Chamada da Fun√ß√£o Receber Pedido, 
*  passando a Fun√ß√£o Produ√ß√£o e 
*  a fruta como argumentos
*/
pedido(0, producao);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Chegou um Pedido!
A fruta Morango foi selecionada
Iniciar a Produ√ß√£o!
```

Observe que a mensagem indicando a fruta selecionada ser√° exibida 2 segundos depois da mensagem de inicio da produ√ß√£o.

 Na sequ√™ncia, vamos implementar a fun√ß√£o **produ√ß√£o()**, come√ßando pela tarefa **cortar as frutas**, como mostra o trecho de c√≥digo abaixo:

```ts
/* In√≠cio do C√≥digo...*/

// Fun√ß√£o Iniciar a Produ√ß√£o
let producao = () => {

    setTimeout(() => {
        // Mensagem
        console.log("Iniciar Produ√ß√£o!");

        // Cortar as frutas
        setTimeout(()=>{
            console.log("Cortando as frutas...")
          },2000)
      
    }, 0);
};

/* Final do c√≥digo ...*/
```

Neste trecho estamos visualizando apenas a fun√ß√£o **producao()**. Observe que inserimos a tarefa de **inicio da produ√ß√£o** dentro da fun√ß√£o **setTimeout()**, com o tempo de 0 segundos (0 milissegundos), para que a produ√ß√£o seja iniciada imediatamente. Dentro do inicio da produ√ß√£o, inserimos a tarefa **Cortar frutas** utilizando a fun√ß√£o **setTimeout()**, com o tempo de 2 segundos (2000 milissegundos) para a conclus√£o da tarefa. 

Este processo de inserir uma Fun√ß√£o Callback dentro da outra √© chamado de **Aninhar Fun√ß√µes**. Vamos executar o c√≥digo e visualizar o resultado:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Chegou um Pedido!
A fruta Morango foi selecionada
Iniciar Produ√ß√£o!
Cortando as frutas...
```

Vamos continuar a implementa√ß√£o da fun√ß√£o **producao()** adicionando as demais tarefas:


```ts
/* In√≠cio do C√≥digo...*/

// Fun√ß√£o Iniciar a Produ√ß√£o
let producao = () => {

    setTimeout(() => {
        // Mensagem
        console.log("Iniciar Produ√ß√£o!");
        setTimeout(() => {
            // Cortar as frutas
            console.log("Cortando as frutas...");
            setTimeout(() => {
                // Adicionar √°gua e gelo
                console.log(`Adicionando ${estoque.Liquidos[0]} e ${estoque.Liquidos[1]}...`);
                setTimeout(() => {
                    // Ligar a M√°quina
                    console.log("Ligando a m√°quina");
                    setTimeout(() => {
                        // Selecionar o suporte (casquinha, copinho, entre outros)
                        console.log(`Inserir o sorvete na(o) ${estoque.Suporte[1]}`);
                        setTimeout(() => {
                            // Selecionar os toppings
                            console.log(`Adicionando ${estoque.Toppings[0]}...`);
                            setTimeout(() => {
                                // Servir o sorvete
                                console.log("Servindo o sorvete");
                            }, 2000)
                        }, 3000)
                    }, 2000)
                }, 1000)
            }, 1000)
        }, 2000)
    },0)
};

/* Final do c√≥digo ...*/
```

Abaixo, voc√™ confere a vers√£o final da implementa√ß√£o e o resultado do c√≥digo:

```ts
// Objeto que define o estoque da Sorveteria
let estoque = {
    Frutas: ["Morango", "Uva", "Banana", "Ma√ß√£"],
    Liquidos: ["Gelo", "√Ågua"],
    Suporte: ["Casquinha", "Pote", "Ta√ßa"],
    Toppings: ["Chocolate", "Castanha", "Granulado", "Pa√ßoca"],
};

// Fun√ß√£o Receber Pedido
let pedido = (fruta: number, executa_producao: any) => {

    // Mensagem
    console.log("Chegou um Pedido!")

    setTimeout(function () {

        console.log(`A fruta ${estoque.Frutas[fruta]} foi selecionada`);

        // Chamada da Fun√ß√£o Callback
        executa_producao();
    }, 2000)

};

// Fun√ß√£o Iniciar a Produ√ß√£o
let producao = () => {

    setTimeout(() => {
        // Mensagem
        console.log("Iniciar Produ√ß√£o!");
        setTimeout(() => {
            // Cortar as frutas
            console.log("Cortando as frutas...");
            setTimeout(() => {
                // Adicionar √°gua e gelo
                console.log(`Adicionando ${estoque.Liquidos[0]} e ${estoque.Liquidos[1]}...`);
                setTimeout(() => {
                    // Ligar a M√°quina
                    console.log("Ligando a m√°quina");
                    setTimeout(() => {
                        // Selecionar o suporte (casquinha, copinho, entre outros)
                        console.log(`Inserir o sorvete na(o) ${estoque.Suporte[1]}`);
                        setTimeout(() => {
                            // Selecionar os toppings
                            console.log(`Adicionando ${estoque.Toppings[0]}...`);
                            setTimeout(() => {
                                // Servir o sorvete
                                console.log("Servindo o sorvete");
                            }, 2000)
                        }, 3000)
                    }, 2000)
                }, 1000)
            }, 1000)
        }, 2000)
    },0)
};

/* *
*  Chamada da Fun√ß√£o Receber Pedido, 
*  passando a Fun√ß√£o Produ√ß√£o e 
*  a fruta como argumentos
*/
pedido(0, producao);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Chegou um Pedido!
A fruta Morango foi selecionada
Iniciar Produ√ß√£o!
Cortando as frutas...
Adicionando Gelo e √Ågua...
Ligando a m√°quina
Inserir o sorvete na(o) Pote
Adicionando Chocolate...
Servindo o sorvete
```

Todas as tarefas da produ√ß√£o foram executadas dentro dos tempos estabelecidos.

<br />

<h2 align="center">Um detalhe importante!</h2>

<br />

Percebeu o quanto este c√≥digo √© extenso e confuso? S√£o 7 Fun√ß√µes Callback aninhadas, uma dentro da outra!

O C√≥digo acima √© popularmente conhecido entre as pessoas desenvolvedoras TypeScript/JavaScript de **Callback Hell!** ou **O Inferno das Callbacks!**, que pode ser representado pela imagem abaixo:

 <div align="center"><img src="https://i.imgur.com/VZJZcmC.png" title="source: imgur.com" width="80%"/><figcaption><i>Callback Hell</i></figcaption></div>

Na programa√ß√£o, **O Inferno das Callbacks** refere-se a uma forma extremamente ineficaz de escrever c√≥digo ass√≠ncrono. Acontece quando voc√™ escreve as Fun√ß√µes Callback e cria muitos n√≠veis de **Nesting** (uma fun√ß√£o dentro da outra, que √© colocada dentro de uma terceira e assim sucessivamente), criando uma pir√¢mide fun√ß√µes, como vemos na imagem anterior. Isso torna dif√≠cil a tarefa de controlar o acesso √† uma fun√ß√£o espec√≠fica e dificulta a depura√ß√£o e manuten√ß√£o do c√≥digo.

<br />

<h2 align="center">Qual √© a Solu√ß√£o?</h2>

<br />

A resposta para esta pergunta √©: **Promises**!

Continua no pr√≥ximo cap√≠tulo...

<br />

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function" target="_blank"><b>Documenta√ß√£o: Callbacks</b></a></div>

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="" target="_blank"><b>C√≥digo fonte dos exemplos</b></a></div>

<br />

<br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>

