<h1>Programa√ß√£o Orientada a Objetos - Parte 01</h1>

<br />

<h2>1. Classes, Objetos e Encapsulamento</h2>



Em geral, quanto maior o software, maior a complexidade de seu desenvolvimento, devido ao n√∫mero de partes que o comp√µem e aos relacionamentos entre essas partes.

Uma das principais dificuldades encontradas na implementa√ß√£o, nos testes e na manuten√ß√£o de sistemas √© que, frequentemente, quando o projeto de software √© focado exclusivamente nas funcionalidades, o sistema √© estruturado com base no que ele precisa fazer, sem considerar como representar o processo de forma semelhante ao que ocorre no mundo real, ou seja, no cotidiano das empresas.

O problema dessa abordagem √© que, com o tempo, os processos e procedimentos das empresas mudam. Isso significa que o software tamb√©m precisar√° ser alterado. Se o sistema foi estruturado exclusivamente com base nas funcionalidades que ele precisava executar anteriormente, √© poss√≠vel que agora ele precise ser completamente reestruturado ou at√© refeito. Caso contr√°rio, o √∫nico recurso dispon√≠vel ser√° a "Programa√ß√£o Orientada a Gambiarras" (POG), para manter o software funcionando, mas com um custo elevado de manuten√ß√£o.

> **Exemplo Pr√°tico**
>
> Vamos imaginar um sistema de gerenciamento banc√°rio, no qual o processo de gest√£o das contas envolve clientes, funcion√°rios e contas. 
>
> Esse sistema poderia ser estruturado de forma tradicional, focando exclusivamente nas funcionalidades do processo de gest√£o. No entanto, essa abordagem resultaria em um sistema dif√≠cil de manter e modificar, pois tanto o banco quanto as regulamenta√ß√µes governamentais podem alterar com frequ√™ncia a forma como as contas s√£o abertas, as exig√™ncias para os clientes ou at√© mesmo adicionar novos recursos e servi√ßos. 
>
> Essas mudan√ßas exigiriam ajustes em v√°rias partes do sistema, aumentando sua complexidade e a probabilidade de inconsist√™ncias nos processos.

No entanto, h√° algumas d√©cadas, alguns desenvolvedores come√ßaram a refletir sobre essa quest√£o. Eles pensaram: 

"***Se as fun√ß√µes de uma empresa e de um software mudam com tanta frequ√™ncia, n√£o podemos us√°-las como base para organizar nossa aplica√ß√£o***". 

Essa foi a primeira grande conclus√£o. A partir desse racioc√≠nio, surgiu uma nova pergunta que levou √† segunda grande conclus√£o: 

"***O que, em uma empresa e em seus processos, raramente muda?***" 

Felizmente, a resposta apareceu: 

***As Coisas!***

<br />

<h3>1.1. Mas o que s√£o "as coisas"?</h3>



***Simples: tudo aquilo que √© f√≠sico.*** 

H√° uma grande const√¢ncia no uso de formul√°rios, na produ√ß√£o de determinados produtos, nos funcion√°rios envolvidos em certos processos, entre outros. As entidades, na maioria das vezes, permanecem constantes. Os objetos envolvidos na execu√ß√£o dos processos raramente mudam. A partir dessas observa√ß√µes, surgiu a segunda grande conclus√£o: 

***"Vamos basear a estrutura do software nos objetos envolvidos nos processos e n√£o nos pr√≥prios processos."***

A **Programa√ß√£o Orientada a Objetos (POO)** √© um **paradigma de programa√ß√£o que define a estrutura dos programas de computador com base em conceitos do mundo real, sejam esses conceitos reais ou abstratos**. A ideia central √© simular as entidades e intera√ß√µes do mundo real dentro do ambiente virtual.

- No mundo real, tudo √© composto por objetos que interagem entre si.
- Em um modelo orientado a objetos, a estrutura tamb√©m √© composta por objetos que interagem entre si.

> **Abstrato, segundo o dicion√°rio:**
>
> **Abstrato:** Algo que n√£o √© concreto; que resulta da abstra√ß√£o, que lida exclusivamente com ideias ou associa√ß√µes de ideias, sem se referir diretamente √† realidade sens√≠vel, e que possui um alto grau de generaliza√ß√£o.

Na teoria dos sistemas, um sistema √© definido como **um conjunto de entidades que interagem entre si para produzir um resultado comum**. A partir dessa defini√ß√£o, podemos concluir que √© natural usar "objetos de programa" para compor um sistema computacional.

<br />

<h2>2. Objetos</h2>



No mundo real, objetos podem ser animados ou inanimados, mas **qualquer um deles possui caracter√≠sticas que podem ser classificadas como atributos ou comportamentos**. Na imagem abaixo, vemos alguns exemplos de objetos:

<div align="center"><img src="https://i.imgur.com/MJIvLag.png" title="source: imgur.com" /></div>

Observe que nos exemplos acima cada Objeto foi definido de forma Gen√©rica: Animal, Pessoa, Produto e Conta. 

Analisando o Objeto Conta, por exemplo, n√≥s sabemos que a Conta √© de um Banco, mas n√£o sabemos os detalhes da Conta como:

1) Qual √© o n√∫mero da Conta?
2) Qual √© o numero da Ag√™ncia Banc√°ria?
3) Quem √© o titular da Conta?
4) Qual √© o tipo da Conta?
5) Qual √© o Saldo da Conta?

Observe que o Objeto **Conta** foi definido de maneira **Abstrata** e **Gen√©rica**, com poucos ou nenhum detalhe espec√≠fico. Nesta etapa da modelagem de um sistema orientado a objetos, o foco est√° apenas em identificar os Objetos Gen√©ricos, ou seja, uma generaliza√ß√£o da abstra√ß√£o. Nessa fase, as especificidades n√£o s√£o consideradas; o objetivo √© criar um modelo que possa representar qualquer tipo de **Conta Banc√°ria**.

Modelar um sistema baseado em objetos traz diversas vantagens:

- **Simplifica√ß√£o da concep√ß√£o do sistema:** A transi√ß√£o da realidade para o modelo torna-se mais f√°cil, uma vez que os objetos refletem as entidades do mundo real.
- **Facilidade de compreens√£o do modelo:** Como o modelo √© baseado em conceitos do mundo real, sua compreens√£o se torna mais intuitiva para aqueles que est√£o familiarizados com o problema real, facilitando a comunica√ß√£o e o entendimento.
- **Simplifica√ß√£o do gerenciamento do sistema:** Assim como na realidade, os objetos s√£o mais est√°veis quando se trata de resolver um problema. Ou seja, os objetos mudam muito pouco. Quando surgem problemas ligeiramente diferentes, em vez de modificar os objetos em si, ajusta-se a forma como eles interagem. Isso facilita a manuten√ß√£o e a evolu√ß√£o do sistema, sem a necessidade de grandes altera√ß√µes na estrutura do modelo.

<br />

<h3>2.1. O que s√£o Objetos na Programa√ß√£o Orientada a Objetos?</h3>



Na Programa√ß√£o Orientada a Objetos (POO) ‚Äî e, de certa forma, tamb√©m na vida real ‚Äî, um **Objeto** √© uma **Entidade** caracterizada por um conjunto de opera√ß√µes e um estado. Esse estado e essas opera√ß√µes s√£o representados, respectivamente, por **atributos** e **m√©todos**.

- **Atributos** s√£o os campos ou propriedades que armazenam dados sobre o objeto, como o saldo de uma conta banc√°ria ou o nome de um cliente.
- **M√©todos** s√£o as fun√ß√µes ou a√ß√µes que definem o comportamento do objeto, como sacar, depositar ou consultar o saldo de uma conta.

Al√©m disso, um objeto pode ser composto por outros objetos. Ou seja, os **atributos** de um objeto podem ser objetos de outras classes, formando uma estrutura um pouco mais complexa.

√â importante observar que um objeto se assemelha a uma **estrutura de dados**, mas vai al√©m, pois, al√©m de armazenar dados, um objeto tamb√©m pode armazenar fun√ß√µes (m√©todos). Em resumo, um objeto √© composto por:

- **Atributos**: os dados ou propriedades do objeto.
- **M√©todos**: as fun√ß√µes que representam o comportamento ou as a√ß√µes do objeto.

Todo objeto possui tr√™s caracter√≠sticas fundamentais:

- **Identidade**: o nome ou identifica√ß√£o do objeto, que o torna √∫nico.
- **Estado**: as propriedades ou atributos do objeto, que descrevem sua condi√ß√£o ou valores no momento.
- **Comportamento**: as a√ß√µes ou m√©todos do objeto, que definem o que ele pode fazer ou como ele pode interagir com outros objetos.

<br />

<h2>3. Classes</h2>



As **Classes** podem ser vistas como pequenos programas ou como novos tipos de dados. Elas funcionam como um "molde" para a cria√ß√£o de objetos, ou seja, uma descri√ß√£o de como um objeto pode ser formado. Uma maneira simples de entender √© comparar uma **classe** com a planta de uma casa: a planta define como a casa ser√° constru√≠da, mas ela por si s√≥ n√£o √© a casa. Da mesma forma, a classe descreve as caracter√≠sticas e comportamentos do objeto, mas, sozinha, n√£o representa um objeto real.

<div align="center"><img src="https://i.imgur.com/0zF5E7u.png" title="source: imgur.com" /></div>

Vale notar que a **classe** √© um conceito abstrato. Ela serve como um modelo, mas para se tornar algo concreto e utiliz√°vel, √© necess√°rio criar objetos a partir dela. Esse processo de cria√ß√£o de um objeto a partir de uma classe √© chamado de **instancia√ß√£o da classe**.

Quando voc√™ instancia uma classe, est√° utilizando a classe como uma forma para criar m√∫ltiplos objetos com as mesmas caracter√≠sticas e comportamentos descritos nela, mas com seus pr√≥prios valores e estados √∫nicos.

<div align="center"><img src="https://i.imgur.com/Q40v71w.png" title="source: imgur.com" /></div>

Na analogia da planta da casa, a **classe** funciona como a planta arquitet√¥nica que pode ser usada para construir v√°rias casas. Da mesma forma, uma **classe** pode ser instanciada v√°rias vezes para criar **n** objetos, cada um com suas pr√≥prias caracter√≠sticas e comportamentos.

Assim como toda planta de casa inclui detalhes sobre a constru√ß√£o, uma classe tamb√©m √© composta por dois principais componentes:

1. **Atributos**: S√£o as vari√°veis que definem as caracter√≠sticas do objeto. Por exemplo, no caso de uma classe **Casa**, atributos podem ser o n√∫mero de **quartos**, **banheiros**, **tamanho** e **cor** da casa. Esses atributos identificam as propriedades de cada inst√¢ncia do objeto criado a partir da classe.
2. **M√©todos**: S√£o as fun√ß√µes que definem as a√ß√µes ou comportamentos do objeto. No exemplo de uma casa, um m√©todo poderia ser **abrirPorta()**, que define o comportamento de abrir a porta da casa.

Portanto, os **Atributos** s√£o respons√°veis por armazenar informa√ß√µes que identificam as caracter√≠sticas do objeto, enquanto os **M√©todos** definem as a√ß√µes que o objeto pode realizar. Cada inst√¢ncia de uma classe ter√° seus pr√≥prios valores para os atributos, mas todos os objetos daquela classe ter√£o os mesmos m√©todos. Veja no exemplo abaixo:

<div align="center"><img src="https://i.imgur.com/QBaJPAy.png" title="source: imgur.com" /></div>

Ao definir os **atributos** de um objeto, conseguimos identificar os detalhes que caracterizam aquele objeto e, automaticamente, podemos responder a v√°rias perguntas sobre ele. Na **classe Conta**, por exemplo, definimos os seguintes atributos:

- **Numero**: o n√∫mero da conta.
- **Titular**: o nome da pessoa que possui a conta.
- **Tipo**: tipo da conta (corrente, poupan√ßa, etc.).
- **Banco**: o banco no qual a conta est√° registrada.
- **Ag√™ncia**: a ag√™ncia do banco onde a conta foi aberta.

Esses atributos ajudam a descrever o conceito da **Conta**, fornecendo os dados necess√°rios para identificar cada inst√¢ncia dessa conta.

J√° os **m√©todos** s√£o respons√°veis por definir as **a√ß√µes** que um objeto pode realizar. No caso da **classe Conta**, os m√©todos podem ser a√ß√µes como **sacar()**, **depositar()**, **criar()**, entre outros, como vemos na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/SSijmB3.png" title="source: imgur.com" /></div>

Os **m√©todos** t√™m a fun√ß√£o de **modificar e interagir com os atributos** de um objeto, ou realizar opera√ß√µes espec√≠ficas. No caso da **classe Conta**, por exemplo, temos diversos m√©todos que desempenham a√ß√µes essenciais para o gerenciamento da conta. Esses m√©todos incluem:

- **criar()**: permite criar uma nova conta banc√°ria.
- **consultar()**: permite consultar os dados de uma conta, como o titular, saldo, tipo e ag√™ncia.
- **atualizar()**: permite atualizar informa√ß√µes da conta, como alterar o titular da conta.
- **excluir()**: permite excluir uma conta do sistema.
- **depositar()**: permite adicionar dinheiro ao saldo da conta.
- **sacar()**: permite retirar dinheiro da conta, desde que o saldo seja suficiente.

Em resumo, **atributos** definem as **caracter√≠sticas** do objeto, como o nome do titular ou o saldo da conta, enquanto **m√©todos** definem as **a√ß√µes** que podem ser realizadas com esses atributos, como depositar, sacar ou atualizar dados.

Al√©m disso, na nomenclatura de um sistema orientado a objetos, **atributos** costumam ser identificados por **substantivos** (pois representam **coisas** ou **caracter√≠sticas**, como "titular", "saldo", "ag√™ncia"), enquanto **m√©todos** s√£o identificados por **verbos** (pois representam **a√ß√µes**, como "criar", "consultar", "sacar").

Na **Programa√ß√£o Orientada a Objetos (POO)**, um sistema √© visto como um conjunto de **objetos** que s√£o inst√¢ncias de **classes**. As **classes** s√£o **modelos est√°ticos** que definem as caracter√≠sticas e comportamentos comuns de um conjunto de objetos, enquanto os **objetos** s√£o **entidades din√¢micas**, criadas a partir das classes, que possuem os dados e podem executar os m√©todos definidos.

Em outras palavras, uma **classe** √© uma descri√ß√£o formal de um conceito, e um **objeto** √© a **materializa√ß√£o** desse conceito, com seus pr√≥prios dados e comportamentos. Cada objeto √© uma inst√¢ncia de uma classe, o que significa que ele compartilha a estrutura da classe, mas com valores e estados pr√≥prios.

**Exemplo:** 

<div align="center"><img src="https://i.imgur.com/esIWB81.png" title="source: imgur.com" /></div>

**Conta** **√© uma classe que define um modelo de Objeto.**

**A Conta da Maria Joaquina e a Conta do Jo√£o da Silva s√£o inst√¢ncias da Classe Conta, ou seja, Objetos gerados a partir do modelo definido pela Classe.**

<br />

<h3>3.1. Representa√ß√£o Gr√°fica de uma Classe</h3>



O **Diagrama de Classes** √© uma representa√ß√£o gr√°fica que descreve as classes, seus atributos e m√©todos, e como elas se relacionam no contexto de um sistema orientado a objetos. Ele faz parte da **UML (Unified Modeling Language)**, uma linguagem padronizada para modelagem de sistemas orientados a objetos. 

O Diagrama de Classes ajuda a visualizar as principais caracter√≠sticas e comportamentos da classe, facilitando o entendimento do sistema, tanto para os desenvolvedores quanto para outras partes envolvidas no projeto. Veja o Diagrama de Classes da Classe Conta:

```mermaid
classDiagram
class Conta {
 - numero: number
 - agencia: number
 - tipo: number
 - titular: string
 - saldo: number
 + get numero() number
 + get agencia() number
 + get tipo() number
 + get titular() string
 + get saldo() number
 + set numero(numero: number) void
 + set agencia(agencia: number) void
 + set tipo(tipo: number) void
 + set titular(titular: string) void
 + set saldo(saldo: number) void
 + saque(valor: number) boolean
 + depositar(valor: number) void
 + visualizar() void
}
```

Na imagem abaixo, vemos como um Diagrama de Classes √© organizado:

<div align="center"><img src="https://i.imgur.com/edOFUeU.png" title="source: imgur.com" /></div>

- **Nome da Classe**: O nome da classe √© escrito na parte superior do ret√¢ngulo, representando o tipo de entidade que a classe modela.
- **Atributos**: S√£o os dados ou vari√°veis que definem o estado de uma classe. Eles s√£o descritos na parte do meio do ret√¢ngulo e devem ser acompanhados de seu tipo de dado (`string`, `number`, `boolean`, entre outros.). Os atributos representam as propriedades de um objeto.
- **M√©todos**: S√£o as a√ß√µes ou comportamentos que podem ser realizados sobre os objetos daquela classe. Os m√©todos aparecem na parte inferior do ret√¢ngulo e devem ser descritos com seu nome, tipo de dado de sa√≠da (se houver), e tipo de dado de entrada (se houver).

Note que tanto os **M√©todos** quanto os **Atributos** de uma classe possuem s√≠mbolos que representam o **n√≠vel de acesso**. Esses s√≠mbolos indicam a visibilidade ou o acesso permitido para os componentes da classe, controlando se eles podem ser acessados ou modificados de fora da classe ou apenas de dentro dela. Os s√≠mbolos mais comuns usados para indicar o n√≠vel de acesso no Diagrama de Classes s√£o os seguintes:

- **P√∫blico (`+`)**: O componente √© **acess√≠vel de qualquer lugar** dentro e fora da classe.
- **Privado (`-`)**: O componente √© **acess√≠vel apenas dentro da classe**. Ele n√£o pode ser acessado diretamente de fora da classe.
- **Protegido (`#`)**: O componente √© **acess√≠vel dentro da classe e tamb√©m pelas classes que herdam desta classe** (subclasses).

<br />

<h3>3.2. Declarando Classes e Atributos</h3>



**Sintaxe - Classe**

```ts
export class nome_da_classe{
    // Corpo da Classe
}
```

A palavra reservada **`export`** no TypeScript √© utilizada para tornar uma classe, fun√ß√£o, vari√°vel ou qualquer outro componente acess√≠vel fora do arquivo em que foi declarada, ou seja, p√∫blica. Ela permite que outros m√≥dulos possam importar e utilizar o componente exportado. 

<br />

**Sintaxe - Atributos**

```ts
[modificador_de_visibilidade] nome_do_atributo: tipo_de_dado
```

O tipo de dado s√£o os tipos que vimos no Conte√∫do **Introdu√ß√£o ao TypeScript**. Podemos utilizar tanto os tipos primitivos quanto os tipos n√£o primitivos. 

<br />

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="100px"/> | <div align="left">**DICA:** *Para relembrar os tipos de dados no TypeScript, <a href="09.md">clique aqui</a> e explore os principais tipos de dados que o TypeScript oferece.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h2>4. Modificadores de Visibilidade</h2>



No TypeScript, os modificadores de acesso controlam a visibilidade e o acesso aos atributos e m√©todos de uma classe. Eles definem quais partes do c√≥digo podem acessar ou modificar esses membros, e ajudam a proteger os dados e a l√≥gica da classe. Ao contr√°rio de outras linguagens como Java ou C#, onde os modificadores de acesso podem ser aplicados tamb√©m nas classes, no TypeScript, eles s√£o aplicados apenas aos m√©todos e atributos dentro da classe. 

O TypeScript oferece 3 modificadores de acesso:

| **Modificador** | **Descri√ß√£o**                                                | UML  |
| --------------- | ------------------------------------------------------------ | :--: |
| **public**      | Um M√©todo ou Atributo public poder√° ser acessado por qualquer Classe. |  +   |
| **protected**   | Um M√©todo ou Atributo protected √© protegido. Pode ser acessado dentro da pr√≥pria Classe onde eles foram declarados e por todas as Classes que estendem (Herdam) a Classe onde eles foram declarados. |  #   |
| **private**     | Um M√©todo ou Atributo private possui o acesso restrito. Pode ser acessado somente dentro da pr√≥pria Classe onde eles foram declarados. |  -   |

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="200px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao criar os M√©todos e Atributos do projeto. Os modificadores de acesso (public, protected e private) nunca poder√£o ser combinados.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

Na modelagem de uma classe, conforme observado no **Diagrama UML**, a visibilidade de **m√©todos** e **atributos** √© indicada por s√≠mbolos espec√≠ficos:

- **P√∫blico (`+`)**: O componente √© **acess√≠vel de qualquer lugar** dentro e fora da classe.
- **Privado (`-`)**: O componente √© **acess√≠vel apenas dentro da classe**. Ele n√£o pode ser acessado diretamente de fora da classe.
- **Protegido (`#`)**: O componente √© **acess√≠vel dentro da classe e tamb√©m pelas classes que herdam desta classe** (subclasses).

<br />

> **PONTO DE ATEN√á√ÉO IMPORTANTE**
>
> **Modificadores de acesso** s√£o mecanismos dentro do c√≥digo de programa√ß√£o que controlam a visibilidade e o acesso a atributos e m√©todos de uma classe, limitando quem pode interagir com eles.
>
> **Seguran√ßa da informa√ß√£o** envolve pr√°ticas e pol√≠ticas para proteger dados contra acessos n√£o autorizados, garantindo sua confidencialidade, integridade e disponibilidade.
>
> Enquanto modificadores de acesso regulam o acesso aos dados dentro do c√≥digo, a seguran√ßa da informa√ß√£o abrange a prote√ß√£o de dados em todo o ambiente, incluindo redes e sistemas.

<br />

Na imagem abaixo podemos visualizar a hierarquia dos modificadores de visibilidade:

<div align="center"><img src="https://i.imgur.com/4go1ThA.png" title="source: imgur.com" /></div>

A imagem acima mostra o n√≠vel de visibilidade dos Atributos e M√©todos, do n√≠vel de acesso mais restrito (Private) ao n√≠vel de acesso total e irrestrito (Public). Na tabela abaixo temos um resumo:

| Modificador   | Classe | Sub Classe | Mundo |
| ------------- | :----: | :--------: | :---: |
| **public**    |   ‚úî    |     ‚úî      |   ‚úî   |
| **protected** |   ‚úî    |     ‚úî      |   ‚ùå   |
| **private**   |   ‚úî    |     ‚ùå      |   ‚ùå   |

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="80px"/> | <div align="left"> **ATEN√á√ÉO:** *Os Modificadores de acesso de um Atributo definem quais Classes poder√£o acessar o Atributo, da mesma forma que os Modificadores de acesso de um M√©todo definem quais Classes ter√£o acesso ao M√©todo.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#member-visibility" target="_blank"><b>Documenta√ß√£o: Modificadores de visibilidade</b></a></div>

<br />

<h3>4.1. Conven√ß√£o de Visibilidade</h3>



A conven√ß√£o mais comum na modelagem de classes em **Programa√ß√£o Orientada a Objetos** (POO) √© **manter os atributos como privados** e os **m√©todos como p√∫blicos**, conforme descrito abaixo:

#### **Atributos Privados (-)**

A ideia por tr√°s de manter os atributos privados √© **garantir o Encapsulamento**. Isso significa que os dados internos de um objeto n√£o devem ser acessados diretamente por c√≥digo externo √† classe. Em vez disso, o acesso a esses dados deve ser feito por meio de m√©todos espec√≠ficos (m√©todos p√∫blicos ou protegidos). Esse controle ajuda a proteger os dados e garante que eles sejam manipulados de forma consistente, validada e segura.

#### **M√©todos P√∫blicos (+)**

Os m√©todos, por outro lado, s√£o **p√∫blicos** porque precisam ser acessados por outras partes do sistema para realizar opera√ß√µes, como manipula√ß√£o de dados ou a√ß√µes. No caso de nossa classe `Conta`, um m√©todo p√∫blico pode ser utilizado para depositar ou sacar, permitindo que usu√°rios da classe interajam com ela de maneira controlada e segura.

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 01: Classe Conta com os respectivos Atributos e Modificadores de Acesso

```ts
export class Conta {

    private _numero: number;
    private _agencia: number;
    private _tipo: number;
    private _titular: string;
    private _saldo: number;
  
}
```

Observe que todos os Atributos da Classe iniciam com um **underline** ( _ ), indicando que se tratam de Atributos Privados (private), que possuem **M√©todos Get e  Set** (que ser√£o criados na sequ√™ncia), para acessar e modificar os valores.

A conven√ß√£o de nomear os atributos com um **underline** ( `_` ) no in√≠cio do nome √© uma pr√°tica comum para indicar que um atributo √© privado, ou seja, que ele n√£o deve ser acessado diretamente de fora da classe. Embora o **TypeScript** (ou outras linguagens) permita o uso de modificadores de acesso como `private` para controlar a visibilidade de um atributo, o uso do **underline** √© uma conven√ß√£o que ajuda a indicar visualmente que um atributo √© privado, mesmo que a linguagem n√£o force isso diretamente.

Essa conven√ß√£o √© amplamente utilizada para destacar que o acesso direto ao atributo n√£o √© recomendado, e, em vez disso, deve-se usar os **m√©todos de acesso** conhecidos como **getters** (para acessar o valor de um atributo) e **setters** (para modificar o valor de um atributo). Os **getters** e **setters** s√£o m√©todos p√∫blicos que atuam como intermedi√°rios para acessar e modificar os atributos privados, permitindo **encapsulamento** e **controle sobre as altera√ß√µes** dos dados da classe.

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html" target="_blank"><b>Documenta√ß√£o: Declara√ß√£o de Classes</b></a></div>

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#fields" target="_blank"><b>Documenta√ß√£o: Declara√ß√£o de Atributos</b></a></div>

<br />

<h2>5. M√©todos</h2>



A defini√ß√£o de **M√©todo** em Programa√ß√£o Orientada a Objetos (POO) √© simples, mas fundamental para estruturar e organizar o c√≥digo. Um **M√©todo √© essencialmente uma fun√ß√£o associada a um objeto ou classe que define o comportamento ou as a√ß√µes que o objeto ou inst√¢ncia da classe pode executar**. No TypeScript, como em outras linguagens orientadas a objetos, m√©todos s√£o propriedades da classe que armazenam fun√ß√µes e permitem que o objeto ou classe execute opera√ß√µes sobre seus atributos ou interaja com outros objetos.

<br />

<h3>5.1. Caracter√≠sticas e Benef√≠cios dos M√©todos</h3>



- **Reutiliza√ß√£o:** M√©todos podem ser reutilizados em diferentes partes do programa, o que evita a repeti√ß√£o de c√≥digo e melhora a manuten√ß√£o.
- **Encapsulamento:** Eles ajudam a organizar e encapsular o comportamento dos objetos. O que √© feito dentro de um m√©todo, normalmente, n√£o afeta diretamente outras partes do c√≥digo.
- **Modularidade:** Quando usados corretamente, m√©todos dividem a funcionalidade do sistema em tarefas pequenas e bem definidas, facilitando a organiza√ß√£o e entendimento do c√≥digo.

<br />

<h3>5.2. Regras Importantes para M√©todos</h3>



- **Simplicidade e Clareza:** Cada m√©todo deve realizar apenas uma tarefa espec√≠fica e bem definida. Isso √© importante para garantir que o c√≥digo seja f√°cil de entender, manter e modificar.
- **Nomes Descritivos:** O nome de cada m√©todo deve ser assertivo, ou seja, o nome deve deixar claro qual √© a a√ß√£o que o m√©todo vai realizar. Evite nomes vagos, como `fazerAlgo()` ou `processar()`, e prefira nomes espec√≠ficos, como  `calcularSaldo()`, que descrevem exatamente a tarefa realizada.
- **Limita√ß√£o a uma √∫nica responsabilidade:** Um bom m√©todo deve ser limitado a uma √∫nica responsabilidade, o que significa que ele deve realizar apenas uma opera√ß√£o ou tarefa. Isso est√° alinhado ao princ√≠pio **SRP (Single Responsibility Principle)**, que sugere que uma fun√ß√£o (ou m√©todo) deve ser respons√°vel por uma √∫nica parte do comportamento do sistema.

**Exemplos de M√©todos:**

- **Objeto Carro:** `acelerar()`, `frear()`, `virar()`, `parar()`
- **Objeto Conta Banc√°ria:** `sacar()`, `depositar()`, `transferir()`
- **Objeto E-commerce:** `pagar()`, `adicionarAoCarrinho()`

<br />

<h3>5.3. Declarando M√©todos</h3>



**Sintaxe:**

```ts
[modificadores_de_acesso] nome_do_metodo(argumento: tipo): tipo_de_retorno {
    //Corpo do M√©todo
}
```

Observe que diferente das Fun√ß√µes, ao declarar um M√©todo n√£o se utiliza a palavra reservada **function**.

<br />

<h4>5.3.1. Modificadores de Acesso</h4>



Como visto anteriormente, os Modificadores de acesso alteram a visibilidade dos M√©todos e Atributos de uma Classe, ou seja, qual (is) Classes podem chamar um determinado M√©todo de outra Classe e/ou acessar os seus Atributos.

<br />

<h4>5.3.2. Nome do M√©todo</h4>



√â o nome ou identificador do M√©todo. Para definir o Nome do M√©todo, deve-se seguir as mesmas boas pr√°ticas utilizadas na defini√ß√£o do nome de uma Fun√ß√£o.

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#methods" target="_blank"><b>Documenta√ß√£o: Declara√ß√£o de M√©todos</b></a></div>

<br />

<h4>5.3.3. Argumentos</h4>



Os argumentos do m√©todo s√£o os **par√¢metros**, ou seja, valores que s√£o passados para o m√©todo quando ele √© chamado. Esses par√¢metros s√£o utilizados dentro do m√©todo para realizar opera√ß√µes ou tomar decis√µes baseadas nos valores fornecidos. No TypeScript (e em outras linguagens de programa√ß√£o orientada a objetos), os par√¢metros s√£o definidos de forma similar √† declara√ß√£o de vari√°veis, mas com a diferen√ßa de que s√£o passados para os m√©todos durante a invoca√ß√£o.

Quando um m√©todo √© definido, os par√¢metros s√£o colocados entre par√™nteses, logo ap√≥s o nome do m√©todo. Cada par√¢metro √© representado por uma **vari√°vel** que pode ser de qualquer tipo (primitivo, como `string` ou `number`, ou at√© tipos mais complexos). Os par√¢metros s√£o separados por v√≠rgulas.

**Sintaxe:**

```ts
[modificador_de_acesso] nome_do_metodo(identificador: tipo): tipo_de_retorno {
    //Corpo do M√©todo
}
```

- **Identificador:** Nome da vari√°vel.
- **Tipo:** Tipo da vari√°vel.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ATEN√á√ÉO:** Ao declarar os argumentos do M√©todo n√£o √© necess√°rio adicionar as palavras *var ou let* para indicar que os argumentos s√£o vari√°veis, declare apenas o identificador do argumento, seguido do seu tipo.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean" target="_blank"><b>Documenta√ß√£o - Tipos de dados</b></a></div>

<br />

<h4>5.3.4. Tipo de Retorno</h4>



√â o indicador do Tipo de retorno do M√©todo, ou seja, o tipo do valor que se espera que o M√©todo retorne ao finalizar o processamento dos dados. Assim como as vari√°veis, os M√©todos com tipo de retorno geralmente s√£o declarados com  tipos de dados primitivos, mas eles tamb√©m podem retornar tipos n√£o primitivos como Objetos, array, entre outros. 

Os M√©todos que possuem um tipo de dado, obrigatoriamente precisam retornar um valor equivalente ao seu tipo, ou seja, se o M√©todo for declarado para retornar um valor do tipo **number**, ela precisa retornar um numero ao final do seu processamento. Para retornar este valor, o TypeScript utiliza a palavra reservada **return** seguido do valor de retorno.

Caso o M√©todo **n√£o necessite ter um tipo de dado de retorno, ou seja, um valor que dever√° ser retornado ao final da execu√ß√£o do M√©todo**, na assinatura do M√©todo, defina o tipo de retorno como **void**.

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ATEN√á√ÉO:** *Ao declarar um M√©todo, caso o tipo de retorno n√£o seja informado, o TypeScript definir√° o tipo de retorno por infer√™ncia, baseado nos argumentos e no retorno definido no Corpo do M√©todo.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h2>6. M√©todos Especiais</h2>



Ao construirmos nossas Classes como um modelo para a constru√ß√£o de Objetos, precisamos implementar alguns M√©todos especiais:

<br />

<h3>6.1. M√©todo Construtor</h3>



Para criar (ou instanciar) um novo objeto a partir de uma classe, √© necess√°rio implementar um m√©todo que realize essa tarefa. O m√©todo respons√°vel por essa funcionalidade √© o **M√©todo Construtor**.

Um **M√©todo Construtor** √© um m√©todo especial, exclusivo para cada classe, que √© invocado automaticamente quando um novo objeto √© criado. Ele √© respons√°vel por inicializar o objeto, atribuindo valores iniciais aos seus atributos.

<br />

<h4>6.1.1. Principais Caracter√≠sticas do M√©todo Construtor</h4>



- **Inicializa√ß√£o do Objeto**: O construtor define as a√ß√µes necess√°rias para inicializar o objeto assim que ele for instanciado.
- **Invoca√ß√£o Autom√°tica**: Sempre que um novo objeto √© criado, o m√©todo construtor √© chamado automaticamente, sem a necessidade de ser explicitamente invocado.
- **Assinatura Especial**: A assinatura de um construtor se diferencia de outros m√©todos, pois n√£o possui tipo de retorno (nem mesmo **void**).
- **Nome do M√©todo**: No TypeScript, o nome do m√©todo construtor √© sempre **`constructor`**.
- **Recebe Argumentos**: Assim como outros m√©todos, o construtor pode receber argumentos. Geralmente, ele recebe par√¢metros que correspondem aos atributos da classe, permitindo a atribui√ß√£o de valores iniciais a eles.
- **Obrigat√≥rio**: Toda classe deve ter, no m√≠nimo, um m√©todo construtor definido. Caso n√£o seja definido explicitamente, o TypeScript cria um construtor padr√£o automaticamente.

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 02: M√©todo Construtor da Classe Conta

```ts
export class Conta {

    private _numero: number;
    private _agencia: number;
    private _tipo: number;
    private _titular: string;
    private _saldo: number;
  
    constructor(numero: number, agencia: number, tipo: number, titular: string, saldo: number) {
        this._numero = numero;
        this._agencia = agencia;
        this._tipo = tipo;
        this._titular = titular;
        this._saldo = saldo;
    }

}
```

Observe que em cada atributo foi adicionada a palavra reservada **this**. O motivo √© simples: a palavra reservada **this** √© utilizada para **identificar o atributo da Classe**. Observe que os par√¢metros do M√©todo Construtor tem o mesmo nome, sem o **underline ( _ )**, e o mesmo tipo de dado dos atributos.

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#constructors" target="_blank"><b>Documenta√ß√£o: M√©todo Construtor</b></a></div>

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#this-parameters" target="_blank"><b>Documenta√ß√£o: Palavra reservada this</b></a></div>


<br />

<h3>6.2. M√©todos Get e Set</h3>



Os m√©todos **GET** e **SET** s√£o t√©cnicas padronizadas para gerenciar o acesso e a modifica√ß√£o dos atributos de uma classe. Esses m√©todos permitem controlar como os valores dos atributos privados s√£o acessados e alterados, mantendo a integridade dos dados e a seguran√ßa do sistema. Eles oferecem uma maneira limpa e pr√°tica de interagir com os atributos, sem a necessidade de expor diretamente os detalhes internos da classe.

### Por que os M√©todos GET e SET s√£o importantes?

1. **Encapsulamento**: Ao utilizar os m√©todos GET e SET, os atributos de uma classe s√£o mantidos privados, ou seja, eles n√£o podem ser acessados ou alterados diretamente de fora da classe. Isso garante que a integridade e a seguran√ßa dos dados sejam preservadas.
2. **Valida√ß√£o e Processamento**: O m√©todo SET pode ser utilizado para validar ou processar dados antes de atribu√≠-los ao atributo. Por exemplo, podemos garantir que um valor atribu√≠do ao atributo seja positivo ou dentro de um intervalo v√°lido.
3. **Flexibilidade**: Caso a forma como os atributos devem ser acessados ou modificados mude no futuro, podemos alterar os m√©todos GET e SET sem precisar modificar diretamente o c√≥digo em todas as partes do programa que utilizam esses atributos.

<br />

<h4>6.2.1. M√©todos SET</h4>



Os m√©todos SET servem para modificar os dados dos atributos da Classe. Os m√©todos SET tamb√©m s√£o chamados de **setters**. Note que o nome do M√©todo ser√° uma combina√ß√£o da palavra **set** seguida do nome do atributo. Implicitamente, os M√©todos Set s√£o do tipo **void**, porque n√£o retornam nenhum valor, apenas modificam o valor do atributo.

**M√©todo Set do Atributo Numero da Classe Conta:**

```ts
	public set numero(numero: number) {
        this._numero = numero;
    }
```

Observe que no atributo **_numero** foi adicionada a palavra reservada **this**, para identificar o atributo da classe. Voc√™ deve criar um M√©todo Set para cada Atributo da Classe. Caso voc√™ deixe algum atributo sem o m√©todo set, o valor do atributo n√£o poder√° ser modificado.

<br />

<h4>6.2.2. M√©todos GET</h4>



Agora j√° sabemos como mudar os valores dos atributos, vamos entender como ler os dados dos atributos. Os m√©todos GET servem para ler os dados dos atributos. Os m√©todos GET tamb√©m s√£o chamados de **getters**. Note que o nome do M√©todo ser√° uma combina√ß√£o da palavra **get** seguida do nome do atributo. Implicitamente, os M√©todos Get s√£o do mesmo tipo do atributo que voc√™ est√° lendo os dados.

**M√©todo Get do Atributo Numero da Classe Conta:**

```ts
	public get numero() {
        return this._numero;
    }
```

Observe que foi utilizada a palavra reservada **return**, retornando o valor do atributo **_numero**. No atributo **_numero** foi adicionada a palavra reservada **this**, para identificar o atributo da classe. Voc√™ deve criar um M√©todo Get para cada Atributo da Classe. Caso voc√™ deixe algum atributo sem o m√©todo get, o valor do atributo n√£o poder√° ser visualizado.

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 03: M√©todos Get e Set da Classe Conta

```ts
export class Conta {

    private _numero: number;
    private _agencia: number;
    private _tipo: number;
    private _titular: string;
    private _saldo: number;
  
    constructor(numero: number, agencia: number, tipo: number, titular: string, saldo: number) {
        this._numero = numero;
        this._agencia = agencia;
        this._tipo = tipo;
        this._titular = titular;
        this._saldo = saldo;
    }

    public get numero() {
        return this._numero;
    }

    public set numero(numero: number) {
        this._numero = numero;
    }

    public get agencia() {
        return this._agencia;
    }

    public set agencia(agencia: number) {
        this._agencia = agencia;
    }

    public get tipo() {
        return this._tipo;
    }

    public set tipo(tipo: number) {
        this._tipo = tipo;
    }

    public get titular() {
        return this._titular;
    }

    public set titular(titular: string) {
        this._titular = titular;
    }

    public get saldo() {
        return this._saldo;
    }

    public set saldo(saldo: number) {
        this._saldo = saldo;
    }

}
```

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#getters--setters" target="_blank"><b>Documenta√ß√£o: M√©todos GET e SET</b></a></div>

<br />

<h2>7. Encapsulamento</h2>



**Encapsulamento** √© o processo de proteger os atributos de uma classe contra acessos externos diretos, permitindo sua manipula√ß√£o apenas por meio de m√©todos espec√≠ficos. Essa pr√°tica garante que o acesso e a modifica√ß√£o dos dados sejam realizados de forma controlada e segura.

Ao encapsular os dados de uma aplica√ß√£o, buscamos evitar que esses dados sofram altera√ß√µes n√£o autorizadas ou acidentais. Para isso, criamos uma estrutura que oferece m√©todos de acesso e modifica√ß√£o, que podem ser utilizados por outras classes sem comprometer a integridade e consist√™ncia do sistema.

Na pr√°tica, o encapsulamento √© implementado por meio de dois tipos de m√©todos: **getters** e **setters**, como visto no t√≥pico anterior. 

O **getter** tem a fun√ß√£o de retornar o valor de um atributo de forma controlada, garantindo que a integridade do dado seja preservada. 

J√° o **setter** recebe um valor como argumento, permitindo a modifica√ß√£o do atributo, mas com a possibilidade de incluir valida√ß√µes e controles antes de efetuar a altera√ß√£o. Isso evita o risco de acessos ou modifica√ß√µes indevidas.

Na Classe **Conta**, al√©m dos M√©todos Construtor, Getters e Setters, podemos implementar tr√™s m√©todos auxiliares para manipula√ß√£o dos dados:

- **Sacar**
- **Depositar**
- **Visualizar**

Se a classe permitisse a modifica√ß√£o dos atributos diretamente, sem passar pelos m√©todos **sacar** ou **depositar**, haveria o risco de o saldo ser alterado sem o devido controle. O cen√°rio ideal √© que todas as altera√ß√µes ou consultas aos dados sejam feitas exclusivamente atrav√©s dos M√©todos **get** e **set**, garantindo maior seguran√ßa e consist√™ncia. Para isso, declaramos os atributos como **private** (privados) e tornamos os m√©todos **get** e **set** como **public** (p√∫blicos), permitindo o acesso e a modifica√ß√£o dos atributos de forma controlada.

<br />

<h3>7.1 Vantagens do Encapsulamento</h3>



O encapsulamento oferece v√°rias vantagens, principalmente no que diz respeito √† prote√ß√£o dos dados e √† organiza√ß√£o do c√≥digo. Entre as principais vantagens, podemos destacar:

- **Facilidade de manuten√ß√£o:** O encapsulamento facilita a manuten√ß√£o do c√≥digo, pois, com o acesso controlado aos dados, fica mais f√°cil identificar pontos onde o c√≥digo pode ser melhorado. Sem o encapsulamento, identificar inconsist√™ncias no c√≥digo seria mais dif√≠cil e demorado.
- **Reutiliza√ß√£o de c√≥digo:** Com o encapsulamento, o c√≥digo se torna mais modular e reutiliz√°vel. Isso significa que, ao proteger os dados e a l√≥gica de uma classe, ela poder√° ser reaproveitada em outros projetos, poupando tempo da equipe de desenvolvimento e aumentando a efici√™ncia.
- **Desenvolvimento acelerado e simplificado:** O encapsulamento transforma certas partes do c√≥digo em "caixas pretas", ou seja, as classes externas n√£o precisam acessar ou conhecer a implementa√ß√£o interna dos atributos diretamente. Isso simplifica o desenvolvimento, pois a l√≥gica de manipula√ß√£o dos dados fica centralizada e controlada nos m√©todos da pr√≥pria classe. Assim, qualquer a√ß√£o sobre os dados de um objeto deve passar pelos m√©todos definidos na classe, garantindo maior controle e consist√™ncia.

Em resumo, o encapsulamento √© fundamental para garantir a seguran√ßa, a integridade e a manutenibilidade dos dados em um sistema, facilitando o desenvolvimento e a colabora√ß√£o dentro de equipes de programa√ß√£o.

<br />

> **PONTO DE ATEN√á√ÉO IMPORTANTE**
>
> **Encapsulamento** √© uma t√©cnica da programa√ß√£o orientada a objetos que visa proteger os dados de uma classe, permitindo seu acesso e modifica√ß√£o apenas por meio de m√©todos espec√≠ficos, controlando assim a forma como os dados s√£o manipulados.
>
> J√° **seguran√ßa da informa√ß√£o** √© um campo mais amplo que envolve proteger dados contra acessos n√£o autorizados, perdas ou danos, usando pr√°ticas como criptografia, controle de acesso e auditoria, tanto em n√≠vel de software quanto em n√≠vel de rede e sistemas.
>
> Ambos compartilham o objetivo de proteger os dados, mas o **encapsulamento** √© uma pr√°tica de design de software, enquanto a **seguran√ßa da informa√ß√£o** abrange uma gama mais ampla de medidas de prote√ß√£o de dados em todos os aspectos da infraestrutura e do processo.

<br />

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 04: M√©todos Auxiliares

```ts
export class Conta {

    private _numero: number;
    private _agencia: number;
    private _tipo: number;
    private _titular: string;
    private _saldo: number;
  
    constructor(numero: number, agencia: number, tipo: number, titular: string, saldo: number) {
        this._numero = numero;
        this._agencia = agencia;
        this._tipo = tipo;
        this._titular = titular;
        this._saldo = saldo;
    }

    public get numero() {
        return this._numero;
    }

    public set numero(numero: number) {
        this._numero = numero;
    }

    public get agencia() {
        return this._agencia;
    }

    public set agencia(agencia: number) {
        this._agencia = agencia;
    }

    public get tipo() {
        return this._tipo;
    }

    public set tipo(tipo: number) {
        this._tipo = tipo;
    }

    public get titular() {
        return this._titular;
    }

    public set titular(titular: string) {
        this._titular = titular;
    }

    public get saldo() {
        return this._saldo;
    }

    public set saldo(saldo: number) {
        this._saldo = saldo;
    }
    
	public sacar(valor: number): boolean {

        if (this._saldo < valor) {
            console.log("\n Saldo Insuficiente!");
            return false;
        }

        this._saldo = this._saldo - valor;
        return true;
    }

    public depositar(valor: number): void {
        this._saldo = this._saldo + valor;
    }

    public visualizar(): void {

        let tipo: string = "";

        switch (this._tipo) {
            case 1:
                tipo = "Conta Corrente";
                break;
            case 2:
                tipo = "Conta Poupan√ßa";
                break;
        }

        console.log("\n\n*****************************************************");
        console.log("Dados da Conta:");
        console.log("*****************************************************");
        console.log("Numero da Conta: " + this._numero);
        console.log("Ag√™ncia: " + this._agencia);
        console.log("Tipo da Conta: " + tipo);
        console.log("Titular: " + this._titular);
        console.log("Saldo: " + this._saldo);

    }
}
```

<br />

<h2>8. Instanciando um Objeto</h2>



Instanciar um Objeto √© a a√ß√£o de criar um novo Objeto do mesmo tipo de dado definido em uma Classe.

**Sintaxe**

```ts
const identificador_do_objeto: Classe = new Classe(atributo01, atributo02, ..., atributoN);
```

- O Identificador do Objeto segue os mesmos padr√µes utilizados para definir o identificador de uma vari√°vel.
- Classe √© o nome da Classe que ser√° utilizada para definir o tipo do Objeto. 
- A palavra reservada **new** tem a fun√ß√£o de chamar o M√©todo Construtor da Classe, que √© respons√°vel por criar um novo Objeto.
- Dentro das par√™nteses atribuiremos valores para cada atributo da Classe, conforme definido no M√©todo Construtor.

**Exemplo:**

```ts
const c1: Conta = new Conta(1, 123, 1, "JoaÃÉo da Silva", 1000);
```

Note que os atributos do tipo string s√£o escritos entre aspas.

<br />

Para instanciar os Objetos da Classe Conta, n√≥s utilizaremos a Classe Menu, que funciona como a Classe principal do nosso Projeto:

## <img src="https://i.imgur.com/8eYS3Y6.png" title="source: imgur.com" width="3%"/> Exemplo 05: Instanciar Objetos da Classe Conta

```ts
import { Conta } from './src/model/Conta';

export function main() {

    const conta: Conta = new Conta(1, 123, 1, "JoaÃÉo da Silva", 1000);
    conta.visualizar();
    conta.sacar(500);
    conta.visualizar();
    conta.depositar(1000);
    conta.visualizar();
    
}

main();
```

Note que foi criado 1 Objeto (conta) do tipo Conta. Para instanciar o Objeto, o M√©todo Construtor foi chamado atrav√©s da palavra reservada **new**, seguido do nome da Classe. Dentro dos par√™nteses inserimos os dados do Objeto.

Para acessar os M√©todos da Classe Conta, utiliza-se o padr√£o **objeto.m√©todo()**. 

**Exemplo:** 

```ts
conta.visualizar();
```

<br />

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
// Criar a Conta

*****************************************************
Dados da Conta:
*****************************************************
Numero da Conta: 1
Ag√™ncia: 123
Tipo da Conta: Conta Corrente
Titular: JoaÃÉo da Silva
Saldo: 1000

// Saque

*****************************************************
Dados da Conta:
*****************************************************
Numero da Conta: 1
Ag√™ncia: 123
Tipo da Conta: Conta Corrente
Titular: JoaÃÉo da Silva
Saldo: 500

//Depositar

*****************************************************
Dados da Conta:
*****************************************************
Numero da Conta: 1
Ag√™ncia: 123
Tipo da Conta: Conta Corrente
Titular: JoaÃÉo da Silva
Saldo: 1500
```

<br /><br />

------

## üîë**Pontos chave:**

1. **Programa√ß√£o Orientada a Objetos** (POO) **√© um paradigma de programa√ß√£o que ajuda a definir a estrutura de programas de computadores, baseado nos conceitos do mundo real, sejam eles reais ou abstratos.** A ideia √© simular as coisas que existem e acontecem no mundo real no mundo virtual.
2. Um **Objeto** √© uma abstra√ß√£o utilizada no desenvolvimento de software para representar um objeto da vida real, que possui estados e comportamentos. Os objetos de software costumam ser utilizados para modelar objetos do mundo real encontrados no cotidiano. 
3. Uma **Classe** √© uma planta ou prot√≥tipo a partir do qual os objetos s√£o criados. Basicamente, as classes modelam as caracter√≠sticas e as a√ß√µes de um objeto (estado e comportamento), com **atributos** e **m√©todos**.
4. Objetos s√£o **instanciados** a partir das classes. Eles t√™m valores atribu√≠dos a seus atributos e executam a√ß√µes (ou as a√ß√µes s√£o executadas neles) por meio de m√©todos.
5. Para criar (instanciar) um novo Objeto de uma Classe, precisamos implementar um M√©todo para gerar este novo Objeto. O M√©todo respons√°vel por esta tarefa em uma Classe √© o **M√©todo Construtor**. 
6. Os m√©todos **SET** servem para modificar os atributos. Eles s√£o chamados de setters. Se o nome do atributo √© nome, o nome do setter ser√° **set idade(idade: number)**.
7. Os m√©todos **GET** servem para ler os dados dos atributos. Eles tamb√©m s√£o chamados de getters. Se o nome do atributo √© nome, o nome do getter ser√° **get nome()**.
8. **Encapsular**, nada mais √© do que proteger membros de uma classe de acesso externo, permitindo somente sua manipula√ß√£o de forma indireta. 
9. Encapsular os dados de uma aplica√ß√£o significa evitar que estes sofram acessos indevidos. Para isso, √© criada uma estrutura que cont√©m m√©todos que podem ser utilizados por qualquer outra classe (GET e SET), sem causar inconsist√™ncias no desenvolvimento de um c√≥digo.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
